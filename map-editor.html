<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #toolbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
            z-index: 100;
            border-bottom: 2px solid #444;
        }

        .toolbar-btn {
            padding: 8px 16px;
            background: #4a9eff;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .toolbar-btn:hover {
            background: #3a8eef;
        }

        .toolbar-btn.danger {
            background: #ff4a4a;
        }

        .toolbar-btn.danger:hover {
            background: #ef3a3a;
        }

        #left-panel {
            width: 250px;
            background: #252525;
            padding: 70px 15px 15px;
            overflow-y: auto;
            border-right: 1px solid #444;
        }

        #right-panel {
            width: 280px;
            background: #252525;
            padding: 70px 15px 15px;
            overflow-y: auto;
            border-left: 1px solid #444;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            margin-top: 50px;
        }

        canvas {
            display: block;
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #4a9eff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .object-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: #333;
            border: 2px solid #444;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            transition: all 0.2s;
        }

        .object-btn:hover {
            background: #444;
            border-color: #4a9eff;
        }

        .object-btn.selected {
            background: #4a9eff;
            border-color: #4a9eff;
        }

        .object-list-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .object-list-item:hover {
            background: #444;
        }

        .object-list-item.selected {
            border-color: #4a9eff;
            background: #3a3a3a;
        }

        .object-list-item .object-name {
            font-weight: bold;
            margin-bottom: 4px;
            color: #4a9eff;
        }

        .object-list-item .object-pos {
            font-size: 12px;
            color: #aaa;
        }

        .property-editor {
            margin-top: 15px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 4px;
        }

        .property-row {
            margin-bottom: 10px;
        }

        .property-label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #aaa;
        }

        .property-input {
            width: 100%;
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            color: white;
            font-size: 13px;
        }

        .property-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        #info-overlay {
            position: absolute;
            bottom: 20px;
            left: 270px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 12px;
            color: #aaa;
            pointer-events: none;
        }

        .hidden {
            display: none;
        }

        input[type="file"] {
            display: none;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <button class="toolbar-btn" onclick="newMap()">새 맵</button>
        <button class="toolbar-btn" onclick="exportMap()">맵 내보내기</button>
        <button class="toolbar-btn" onclick="document.getElementById('importFile').click()">맵 불러오기</button>
        <input type="file" id="importFile" accept=".json" onchange="importMap(event)">
        <div style="flex: 1"></div>
        <button class="toolbar-btn danger" onclick="deleteSelected()">삭제 (Del)</button>
    </div>

    <div id="container">
        <div id="left-panel">
            <div class="panel-title">오브젝트 타입</div>
            <button class="object-btn" onclick="selectObjectType('crate')">Crate (상자)</button>
            <button class="object-btn" onclick="selectObjectType('smallCrate')">Small Crate (작은 상자)</button>
            <button class="object-btn" onclick="selectObjectType('coverWall')">Cover Wall (엄폐물)</button>
            <button class="object-btn" onclick="selectObjectType('platform')">Platform (플랫폼)</button>
            <button class="object-btn" onclick="selectObjectType('pillar')">Pillar (기둥)</button>
            <button class="object-btn" onclick="selectObjectType('container')">Container (컨테이너)</button>
            <button class="object-btn" onclick="selectObjectType('wall')">Wall (벽)</button>
        </div>

        <div id="canvas-container"></div>

        <div id="right-panel">
            <div class="panel-title">배치된 오브젝트</div>
            <div id="object-list"></div>
            <div id="property-editor" class="property-editor hidden">
                <div class="panel-title" style="margin-bottom: 10px;">속성 편집</div>
                <div class="property-row">
                    <label class="property-label">X 위치</label>
                    <input type="number" class="property-input" id="prop-x" step="0.5">
                </div>
                <div class="property-row">
                    <label class="property-label">Y 위치</label>
                    <input type="number" class="property-input" id="prop-y" step="0.5">
                </div>
                <div class="property-row">
                    <label class="property-label">Z 위치</label>
                    <input type="number" class="property-input" id="prop-z" step="0.5">
                </div>
                <div class="property-row">
                    <label class="property-label">Y 회전 (도)</label>
                    <input type="number" class="property-input" id="prop-rot" step="90">
                </div>
            </div>
        </div>
    </div>

    <div id="info-overlay">
        클릭: 배치 | 드래그: 선택 오브젝트 이동 | R: 회전 | Delete: 삭제 | 휠: 줌
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let placedObjects = [];
        let selectedObject = null;
        let currentObjectType = 'crate';
        let raycaster, mouse;
        let gridHelper, floor;
        let isDragging = false;
        let dragPlane;

        // Object type definitions
        const objectTypes = {
            'crate': { size: [3, 3, 3], color: 0x885544, name: 'Crate' },
            'smallCrate': { size: [1.5, 1.5, 1.5], color: 0x885544, name: 'Small Crate' },
            'coverWall': { size: [6, 1.5, 0.3], color: 0x333333, name: 'Cover Wall' },
            'platform': { size: [8, 0.5, 8], color: 0x556677, name: 'Platform' },
            'pillar': { size: [2, 6, 2], color: 0x333333, name: 'Pillar' },
            'container': { size: [6, 4, 3], color: 0x556677, name: 'Container' },
            'wall': { size: [20, 4, 1], color: 0x20252a, name: 'Wall' }
        };

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera (top-down view)
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 100, 0);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 200;
            controls.maxPolarAngle = Math.PI / 2.2; // Prevent going below ground

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid
            gridHelper = new THREE.GridHelper(200, 40, 0x888888, 0x444444);
            scene.add(gridHelper);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Drag plane (invisible plane for dragging objects)
            const dragPlaneGeometry = new THREE.PlaneGeometry(1000, 1000);
            const dragPlaneMaterial = new THREE.MeshBasicMaterial({
                visible: false
            });
            dragPlane = new THREE.Mesh(dragPlaneGeometry, dragPlaneMaterial);
            dragPlane.rotation.x = -Math.PI / 2;
            scene.add(dragPlane);

            // Events
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('resize', onResize);

            // Property inputs
            document.getElementById('prop-x').addEventListener('change', updateSelectedObjectProperty);
            document.getElementById('prop-y').addEventListener('change', updateSelectedObjectProperty);
            document.getElementById('prop-z').addEventListener('change', updateSelectedObjectProperty);
            document.getElementById('prop-rot').addEventListener('change', updateSelectedObjectProperty);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function selectObjectType(type) {
            currentObjectType = type;
            document.querySelectorAll('.object-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function onClick(event) {
            if (isDragging) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check if clicking on existing object
            const objectMeshes = placedObjects.map(obj => obj.mesh);
            const intersects = raycaster.intersectObjects(objectMeshes);

            if (intersects.length > 0) {
                // Select existing object
                selectObject(intersects[0].object.userData.objectData);
            } else {
                // Place new object on floor
                const floorIntersects = raycaster.intersectObject(floor);
                if (floorIntersects.length > 0) {
                    placeObject(floorIntersects[0].point);
                }
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left click
            if (!selectedObject) return;

            isDragging = true;
        }

        function onMouseMove(event) {
            if (!isDragging || !selectedObject) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(dragPlane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                // Snap to grid
                const snappedX = Math.round(point.x / 0.5) * 0.5;
                const snappedZ = Math.round(point.z / 0.5) * 0.5;

                selectedObject.mesh.position.x = snappedX;
                selectedObject.mesh.position.z = snappedZ;
                selectedObject.pos[0] = snappedX;
                selectedObject.pos[2] = snappedZ;

                updatePropertyInputs();
                updateObjectList();
            }
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onKeyDown(event) {
            if (event.key === 'r' || event.key === 'R') {
                if (selectedObject) {
                    rotateSelected();
                }
            } else if (event.key === 'Delete') {
                deleteSelected();
            }
        }

        function placeObject(point) {
            const typeData = objectTypes[currentObjectType];

            // Snap to grid
            const snappedX = Math.round(point.x / 0.5) * 0.5;
            const snappedZ = Math.round(point.z / 0.5) * 0.5;
            const y = typeData.size[1] / 2; // Half height

            // Create mesh
            const geometry = new THREE.BoxGeometry(...typeData.size);
            const material = new THREE.MeshStandardMaterial({
                color: typeData.color,
                roughness: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(snappedX, y, snappedZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // Object data
            const objectData = {
                type: currentObjectType,
                pos: [snappedX, y, snappedZ],
                rot: [0, 0, 0],
                size: typeData.size,
                mesh: mesh
            };

            mesh.userData.objectData = objectData;
            placedObjects.push(objectData);
            scene.add(mesh);

            updateObjectList();
            selectObject(objectData);
        }

        function selectObject(objectData) {
            // Deselect previous
            if (selectedObject && selectedObject.mesh.material.emissive) {
                selectedObject.mesh.material.emissive.setHex(0x000000);
            }

            selectedObject = objectData;

            // Highlight selected
            if (selectedObject.mesh.material.emissive) {
                selectedObject.mesh.material.emissive.setHex(0x00ff00);
            }

            updatePropertyInputs();
            updateObjectList();

            document.getElementById('property-editor').classList.remove('hidden');
        }

        function rotateSelected() {
            if (!selectedObject) return;

            selectedObject.rot[1] += Math.PI / 2; // 90 degrees
            if (selectedObject.rot[1] >= Math.PI * 2) {
                selectedObject.rot[1] = 0;
            }

            selectedObject.mesh.rotation.y = selectedObject.rot[1];
            updatePropertyInputs();
        }

        function deleteSelected() {
            if (!selectedObject) return;

            scene.remove(selectedObject.mesh);
            const index = placedObjects.indexOf(selectedObject);
            if (index > -1) {
                placedObjects.splice(index, 1);
            }

            selectedObject = null;
            document.getElementById('property-editor').classList.add('hidden');
            updateObjectList();
        }

        function updatePropertyInputs() {
            if (!selectedObject) return;

            document.getElementById('prop-x').value = selectedObject.pos[0].toFixed(1);
            document.getElementById('prop-y').value = selectedObject.pos[1].toFixed(1);
            document.getElementById('prop-z').value = selectedObject.pos[2].toFixed(1);
            document.getElementById('prop-rot').value = (selectedObject.rot[1] * 180 / Math.PI).toFixed(0);
        }

        function updateSelectedObjectProperty() {
            if (!selectedObject) return;

            const x = parseFloat(document.getElementById('prop-x').value);
            const y = parseFloat(document.getElementById('prop-y').value);
            const z = parseFloat(document.getElementById('prop-z').value);
            const rot = parseFloat(document.getElementById('prop-rot').value) * Math.PI / 180;

            selectedObject.pos = [x, y, z];
            selectedObject.rot[1] = rot;

            selectedObject.mesh.position.set(x, y, z);
            selectedObject.mesh.rotation.y = rot;

            updateObjectList();
        }

        function updateObjectList() {
            const listContainer = document.getElementById('object-list');
            listContainer.innerHTML = '';

            placedObjects.forEach((obj, index) => {
                const typeData = objectTypes[obj.type];
                const div = document.createElement('div');
                div.className = 'object-list-item';
                if (obj === selectedObject) {
                    div.classList.add('selected');
                }

                div.innerHTML = `
                    <div class="object-name">${typeData.name}</div>
                    <div class="object-pos">
                        X: ${obj.pos[0].toFixed(1)}, 
                        Y: ${obj.pos[1].toFixed(1)}, 
                        Z: ${obj.pos[2].toFixed(1)}
                    </div>
                `;

                div.onclick = () => selectObject(obj);
                listContainer.appendChild(div);
            });
        }

        function newMap() {
            if (!confirm('현재 맵을 초기화하시겠습니까?')) return;

            // Remove all objects
            placedObjects.forEach(obj => {
                scene.remove(obj.mesh);
            });

            placedObjects = [];
            selectedObject = null;
            document.getElementById('property-editor').classList.add('hidden');
            updateObjectList();
        }

        function exportMap() {
            const mapData = [
                { type: 'floor', pos: [0, 0, 0], size: [200, 200] },
                ...placedObjects.map(obj => ({
                    type: obj.type,
                    pos: obj.pos,
                    rot: obj.rot,
                    size: obj.size
                }))
            ];

            const jsonStr = JSON.stringify(mapData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'custom-map.json';
            a.click();
            URL.revokeObjectURL(url);

            console.log('맵 내보내기 완료:', mapData.length, '오브젝트');
        }

        function importMap(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const mapData = JSON.parse(reader.result);

                    // Clear current map
                    placedObjects.forEach(obj => scene.remove(obj.mesh));
                    placedObjects = [];
                    selectedObject = null;

                    // Load objects (skip floor)
                    mapData.forEach(objData => {
                        if (objData.type === 'floor') return;

                        const typeData = objectTypes[objData.type];
                        if (!typeData) return;

                        const geometry = new THREE.BoxGeometry(...objData.size);
                        const material = new THREE.MeshStandardMaterial({
                            color: typeData.color,
                            roughness: 0.8
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set(...objData.pos);
                        mesh.rotation.set(...objData.rot);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;

                        const objectData = {
                            type: objData.type,
                            pos: objData.pos,
                            rot: objData.rot,
                            size: objData.size,
                            mesh: mesh
                        };

                        mesh.userData.objectData = objectData;
                        placedObjects.push(objectData);
                        scene.add(mesh);
                    });

                    updateObjectList();
                    document.getElementById('property-editor').classList.add('hidden');

                    // Auto-adjust camera to fit all objects
                    if (placedObjects.length > 0) {
                        const bbox = new THREE.Box3();
                        placedObjects.forEach(obj => {
                            bbox.expandByObject(obj.mesh);
                        });

                        const center = bbox.getCenter(new THREE.Vector3());
                        const size = bbox.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const fov = camera.fov * (Math.PI / 180);
                        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                        cameraZ *= 1.5; // Zoom out a bit more for margin

                        camera.position.set(center.x, cameraZ, center.z);
                        camera.lookAt(center);
                        controls.target.copy(center);
                        controls.update();
                    }

                    console.log('맵 불러오기 완료:', placedObjects.length, '오브젝트');

                } catch (err) {
                    alert('맵 파일을 불러올 수 없습니다: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function onResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
    </script>
</body>

</html>