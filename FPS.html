<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>FPS Ultimate Final Fix v4 (Pistol Sight Fix)</title>
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Î™®Î∞îÏùº Í∞ÄÎ°ú Î™®Îìú ÎåÄÏùë */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Î™®Î∞îÏùº Í∞ÄÎ°ú Î™®Îìú ÏµúÏ†ÅÌôî */
        @media (orientation: landscape) and (max-height: 500px) {

            html,
            body {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transition: opacity 0.1s;
        }

        @media (max-width: 768px) {
            #crosshair {
                display: none !important;
            }
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px black;
        }

        #crosshair::before {
            width: 16px;
            height: 1.5px;
        }

        #crosshair::after {
            width: 1.5px;
            height: 16px;
        }

        #crosshair.enemy-detected::before,
        #crosshair.enemy-detected::after {
            background: #ff0000;
            box-shadow: 0 0 4px red;
        }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s, filter 0.1s;
            z-index: 10;
        }

        #hit-marker::before,
        #hit-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: #ff3333;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px red, 0 0 12px rgba(255, 0, 0, 0.6);
        }

        #hit-marker::before {
            width: 28px;
            height: 4px;
        }

        #hit-marker::after {
            width: 4px;
            height: 28px;
        }

        #scope-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 20;
            background: radial-gradient(circle, transparent 30%, black 31%);
        }

        #scope-line-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(-50%);
        }

        #scope-line-v {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateX(-50%);
        }

        #scope-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, black 150%);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 5;
            pointer-events: none;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 6;
            pointer-events: none;
        }

        #headshot-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            color: #ff0000;
            font-size: 40px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 2px 2px 0 #000;
            opacity: 0;
            transition: transform 0.1s, opacity 0.1s;
            z-index: 15;
            pointer-events: none;
        }

        #headshot-msg.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }

        #ammo-info {
            position: absolute;
            bottom: 40px;
            right: 40px;
            color: white;
            font-size: 40px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 2px 2px 0px #000;
            letter-spacing: 2px;
            text-align: right;
        }

        #weapon-label {
            font-size: 18px;
            color: #fbbc05;
            display: block;
            margin-bottom: 5px;
        }

        #ammo-val {
            display: block;
        }

        .no-ammo {
            color: #ff3333;
            animation: shake 0.2s;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        #hp-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: #4caf50;
            transition: width 0.2s, background-color 0.2s;
        }

        #hp-text {
            position: absolute;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: red;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 60px;
            font-weight: 900;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99;
            font-size: 40px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        #mode-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-size: 28px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        #mode-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .mode-btn {
            margin: 20px;
            padding: 20px 60px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.5);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 8px;
            min-width: 250px;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }

        .mode-btn:active {
            transform: scale(0.98);
        }

        #room-creation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
            font-size: 24px;
            pointer-events: auto;
        }

        #room-creation h2 {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #room-creation .input-group {
            margin: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #room-creation label {
            font-size: 20px;
        }

        #room-creation input {
            padding: 10px 15px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 5px;
            width: 80px;
            text-align: center;
        }

        #room-creation button {
            margin: 10px;
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(0, 150, 0, 0.7);
            border: 2px solid rgba(0, 255, 0, 0.5);
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
        }

        #room-creation button:hover {
            background: rgba(0, 200, 0, 0.8);
            border-color: rgba(0, 255, 0, 0.8);
        }

        #room-creation button.cancel {
            background: rgba(150, 0, 0, 0.7);
            border-color: rgba(255, 0, 0, 0.5);
        }

        #room-creation button.cancel:hover {
            background: rgba(200, 0, 0, 0.8);
            border-color: rgba(255, 0, 0, 0.8);
        }

        #room-waiting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 202;
            font-size: 24px;
            pointer-events: auto;
        }

        #room-waiting h2 {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #players-list {
            margin: 30px;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        #countdown {
            font-size: 72px;
            color: #ff3333;
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.8);
            margin: 30px;
        }

        #restart-btn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 20px;
            background: white;
            border: none;
            cursor: pointer;
        }

        #stats-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: flex;
            gap: 30px;
            z-index: 10;
        }

        #play-time,
        #kill-count {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #controls-guide {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            line-height: 1.6;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }

        .key {
            color: #fbbc05;
            font-weight: bold;
        }

        /* PC Í∞êÎèÑ Ï°∞Ï†ï UI */
        #sensitivity-control {
            position: absolute;
            top: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            pointer-events: auto;
        }

        #sensitivity-control label {
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }

        #sensitivity-slider {
            width: 150px;
            margin-right: 10px;
        }

        #sensitivity-value {
            color: #fbbc05;
            font-weight: bold;
            font-size: 14px;
            min-width: 40px;
            display: inline-block;
        }

        /* Ï°∞Î™Ö ÌÜ†Í∏Ä Î≤ÑÌäº */
        #light-toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffaa00;
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            user-select: none;
            transition: background 0.2s, border-color 0.2s;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        #light-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
        }

        #light-toggle-btn.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
            color: #ffcc44;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* Î™®Î∞îÏùº Ïª®Ìä∏Î°§ */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            pointer-events: none;
        }

        #touch-left,
        #touch-right {
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        /* Î™®Î∞îÏùº Î≤ÑÌäº */
        .mobile-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            pointer-events: auto;
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        /* Î¨¥Í∏∞ ÍµêÏ≤¥ Î≤ÑÌäº - ÏÉÅÎã® Ï§ëÏïô */
        #btn-weapon1 {
            top: 10px;
            left: 50%;
            transform: translateX(-150%);
        }

        #btn-weapon2 {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        #btn-weapon3 {
            top: 10px;
            left: 50%;
            transform: translateX(50%);
        }

        #btn-weapon4 {
            top: 10px;
            left: 50%;
            transform: translateX(150%);
        }

        /* Í∏∞ÌÉÄ Î≤ÑÌäº - ÌïòÎã® */
        #btn-jump {
            bottom: 20px;
            right: 20px;
        }

        #btn-reload {
            bottom: 20px;
            right: 90px;
        }

        #btn-aim {
            bottom: 20px;
            right: 160px;
        }

        /* Î™®Î∞îÏùº UI Ï°∞Ï†ï */
        @media (max-width: 768px) {
            #ammo-info {
                bottom: 80px;
                right: 20px;
                font-size: 24px;
            }

            #weapon-label {
                font-size: 14px;
            }

            #hp-container {
                width: 200px;
                height: 15px;
                bottom: 80px;
                left: 20px;
            }

            #hp-text {
                bottom: 100px;
                left: 20px;
                font-size: 14px;
            }

            #controls-guide {
                font-size: 11px;
                top: 10px;
                left: 10px;
                padding: 8px;
            }

            .mobile-btn {
                display: flex;
            }

            /* Î¨¥Í∏∞ Î≤ÑÌäº ÏÉÅÎã® Ï§ëÏïô Ï†ïÎ†¨ */
            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                width: 45px;
                height: 45px;
                font-size: 16px;
                top: 10px;
            }
        }

        /* Í∞ÄÎ°ú Î™®Îìú */
        @media (orientation: landscape) and (max-width: 1024px) {
            .mobile-btn {
                display: flex !important;
                width: 50px;
                height: 50px;
                font-size: 16px;
            }

            #btn-jump {
                bottom: 15px;
                right: 15px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-reload {
                bottom: 15px;
                right: 75px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-aim {
                bottom: 15px;
                right: 135px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                width: 45px;
                height: 45px;
                font-size: 16px;
                top: 10px;
            }

            #ammo-info {
                bottom: 70px;
                right: 15px;
                font-size: 20px;
            }

            #hp-container {
                width: 180px;
                height: 12px;
                bottom: 70px;
                left: 15px;
            }

            #hp-text {
                bottom: 85px;
                left: 15px;
                font-size: 12px;
            }
        }

        /* ÏÑ∏Î°ú Î™®Îìú */
        @media (orientation: portrait) and (max-width: 768px) {
            #btn-jump {
                bottom: 15px;
                right: 15px;
            }

            #btn-reload {
                bottom: 15px;
                right: 75px;
            }

            #btn-aim {
                bottom: 15px;
                right: 135px;
            }

            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                top: 8px;
            }

            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
        }

        @media (max-width: 768px) {
            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
        }

        @media (hover: hover) and (pointer: fine) {

            #controls,
            .mobile-btn {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="game-container"></div>
    <div id="vignette"></div>
    <div id="damage-overlay"></div>
    <div id="scope-overlay">
        <div id="scope-line-h"></div>
        <div id="scope-line-v"></div>
        <div id="scope-dot"></div>
    </div>
    <div id="headshot-msg">HEADSHOT!</div>
    <div id="hit-marker"></div>

    <div id="game-over">
        YOU DIED
        <button id="restart-btn">TRY AGAIN</button>
    </div>

    <div id="pause-overlay">
        PAUSED
    </div>

    <!-- Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ -->
    <div id="mode-selection">
        <h1>Í≤åÏûÑ Î™®Îìú ÏÑ†ÌÉù</h1>
        <button class="mode-btn" id="btn-single-player">ÌòºÏûêÌïòÍ∏∞</button>
        <button class="mode-btn" id="btn-multi-player">Ìï®ÍªòÌïòÍ∏∞</button>
    </div>

    <!-- Î∞© ÏÉùÏÑ± ÌôîÎ©¥ -->
    <div id="room-creation">
        <h2>Î©ÄÌã∞ÌîåÎ†àÏù¥ ÏÑ§Ï†ï</h2>
        <div class="input-group">
            <label>ÏÑúÎ≤Ñ Ï£ºÏÜå:</label>
            <input type="text" id="server-ip" placeholder="Ïòà: 192.168.0.10:3000" style="width: 250px;">
        </div>
        <div class="input-group">
            <label>ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ:</label>
            <input type="text" id="player-name" placeholder="Ïù¥Î¶Ñ ÏûÖÎ†•" style="width: 200px;">
        </div>
        <button id="btn-create-room">ÏÑúÎ≤Ñ Ï†ëÏÜç</button>
        <button class="cancel" id="btn-cancel-create">Ï∑®ÏÜå</button>
    </div>

    <!-- Î∞© ÎåÄÍ∏∞ ÌôîÎ©¥ -->
    <div id="room-waiting">
        <h2>ÎåÄÍ∏∞ Ï§ë...</h2>
        <div id="players-list"></div>
        <div id="countdown" style="display: none;"></div>
        <button class="cancel" id="btn-leave-room">ÎÇòÍ∞ÄÍ∏∞</button>
    </div>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="ammo-info">
            <span id="weapon-label">ASSAULT RIFLE</span>
            <span id="ammo-val">30 / 120</span>
        </div>

        <div id="hp-text">HP: 100</div>
        <div id="hp-container">
            <div id="hp-bar"></div>
        </div>

        <div id="stats-info">
            <div id="play-time">Time: 00:00</div>
            <div id="kill-count">Kills: 0</div>
        </div>

        <div id="controls-guide">
            <span class="key">1</span>ÏÜåÏ¥ù <span class="key">2</span>Í∂åÏ¥ù <span class="key">3</span>Ï†ÄÍ≤© <span
                class="key">4</span>Ïπº<br>
            <span class="key">WASD</span> Ïù¥Îèô <br>
            <span class="key">Space</span> Ï†êÌîÑ / <span class="key">Shift</span> Îã¨Î¶¨Í∏∞ <br>
            <span class="key">R</span> Ïû¨Ïû•Ï†Ñ <br>
            <span class="key">Click</span> Î∞úÏÇ¨/Ï°∞Ï§Ä
        </div>

        <!-- PC Í∞êÎèÑ Ï°∞Ï†ï UI -->
        <div id="sensitivity-control" style="display: none;">
            <label for="sensitivity-slider">ÎßàÏö∞Ïä§ Í∞êÎèÑ:</label>
            <input type="range" id="sensitivity-slider" min="0.0005" max="0.01" step="0.0005" value="0.002">
            <span id="sensitivity-value">1.0</span>
        </div>
    </div>

    <!-- Ï°∞Î™Ö ÌÜ†Í∏Ä Î≤ÑÌäº -->
    <button id="light-toggle-btn" class="light-toggle-btn" title="Ï°∞Î™Ö ÏºúÍ∏∞/ÎÅÑÍ∏∞">üí°</button>

    <div id="controls">
        <div id="touch-left"></div>
        <div id="touch-right"></div>
    </div>

    <!-- Î™®Î∞îÏùº Ïª®Ìä∏Î°§ -->
    <button class="mobile-btn" id="btn-weapon1">1</button>
    <button class="mobile-btn" id="btn-weapon2">2</button>
    <button class="mobile-btn" id="btn-weapon3">3</button>
    <button class="mobile-btn" id="btn-weapon4">4</button>
    <button class="mobile-btn" id="btn-jump">‚Üë</button>
    <button class="mobile-btn" id="btn-reload">R</button>
    <button class="mobile-btn" id="btn-aim">üéØ</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let camera, scene, renderer;
        let ceilingLight = null;
        let lastTime = performance.now();

        // ÌôïÏû• Í∏∞Îä• Î≥ÄÏàò
        let gltfLoader, textureLoader;
        let composer; // ÌõÑÏ≤òÎ¶¨ Ïª¥Ìè¨Ï†Ä
        let physicsWorld; // Î¨ºÎ¶¨ ÏóîÏßÑ ÏÑ∏Í≥Ñ
        let usePhysics = true; // Î¨ºÎ¶¨ ÏóîÏßÑ ÏÇ¨Ïö© Ïó¨Î∂Ä (ÌôúÏÑ±Ìôî)
        let usePostProcessing = true; // ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º ÏÇ¨Ïö© Ïó¨Î∂Ä (ÌôúÏÑ±Ìôî)

        // Í∞êÎèÑ ÏÑ§Ï†ï (Í∏∞Î≥∏Í∞í)
        let SENSITIVITY_MOUSE = 0.002;
        let SENSITIVITY_ADS = 0.0005;

        // localStorageÏóêÏÑú Í∞êÎèÑ Î°úÎìú
        const savedSensitivity = localStorage.getItem('mouseSensitivity');
        if (savedSensitivity) {
            const sensitivity = parseFloat(savedSensitivity);
            if (!isNaN(sensitivity) && sensitivity > 0) {
                SENSITIVITY_MOUSE = sensitivity;
                SENSITIVITY_ADS = sensitivity * 0.25; // ADSÎäî ÏùºÎ∞ò Í∞êÎèÑÏùò 25%
            }
        }

        // Player State
        let position = new THREE.Vector3(0, 1.7, 5);
        let rotation = { x: 0, y: 0 };
        let velocityY = 0;
        let isGrounded = false;
        let playerHP = 100;
        let isDead = false;
        let isPaused = false;
        let gameMode = null; // 'single' or 'multi'
        let isRoomHost = false;
        let maxPlayers = 4;
        let currentPlayers = 1;
        let playersList = [];
        let countdownTimer = null;

        // Multiplayer Socket
        let socket = null;
        let myId = null;
        let otherPlayersMap = {}; // id -> mesh
        const PLAYER_RADIUS = 0.4;

        // Footsteps
        let moveDistance = 0;
        const STEP_INTERVAL = 2.5;

        const keys = { w: 0, a: 0, s: 0, d: 0, shift: false, ctrl: false, space: false };

        // --- Weapon System ---
        const WEAPONS = [
            {
                id: 0, name: "ASSAULT RIFLE",
                type: 'RIFLE', maxAmmo: 30, ammo: 30, automatic: true,
                posHip: new THREE.Vector3(0.2, -0.25, -0.45),
                posAds: new THREE.Vector3(0, -0.0621, -0.05),
                fovAds: 20, fireRate: 0.08, recoil: 0.06, damage: 30
            },
            {
                id: 1, name: "TACTICAL PISTOL",
                type: 'PISTOL', maxAmmo: 12, ammo: 12, automatic: false,
                posHip: new THREE.Vector3(0.15, -0.2, -0.35),
                // ÏàòÏ†ï: ADS Ï¢åÌëú Ï†ïÎ∞Ä Î≥¥Ï†ï (Í∞ÄÎä†Ïûê ÎÜíÏù¥ÏôÄ ÏùºÏπò)
                posAds: new THREE.Vector3(0, -0.0482, -0.35),
                fovAds: 35, fireRate: 0.15, recoil: 0.1, damage: 20
            },
            {
                id: 2, name: "TAC-50 SNIPER",
                type: 'SNIPER', maxAmmo: 5, ammo: 5, automatic: false,
                posHip: new THREE.Vector3(0.2, -0.3, -0.5),
                posAds: new THREE.Vector3(0, -0.06, -0.15),
                fovAds: 8, fireRate: 2.0, recoil: 0.4, damage: 100
            },
            {
                id: 3, name: "KARAMBIT",
                type: 'KNIFE', maxAmmo: 0, ammo: 0, automatic: true,
                posHip: new THREE.Vector3(0.25, -0.25, -0.5),
                posAds: new THREE.Vector3(0.25, -0.25, -0.45),
                fovAds: 65, fireRate: 0.4, recoil: 0, damage: 15
            }
        ];
        let curWeaponIdx = 0;

        let weaponContainer, weaponModel;
        let currentPos = WEAPONS[0].posHip.clone();

        let isAiming = false;
        let isFiring = false;
        let hasFiredSemi = false;
        let isReloading = false;
        let knifeSwing = 0;
        let hasClickedEmpty = false;
        let sniperReloadGesture = false; // PC Î™®Îìú Ï†ÄÍ≤©Ï¥ù Ïû¨Ïû•Ï†Ñ Ï†úÏä§Ï≤ò ÌîåÎûòÍ∑∏

        let fireCooldown = 0;

        let recoil = { x: 0, z: 0 };
        let muzzleFlash;
        let hitShake = { x: 0, y: 0, intensity: 0 }; // ÌîºÍ≤© Ïãú ÌôîÎ©¥ ÌùîÎì§Î¶º

        let shells = [];
        let shellGeo, shellMat;
        let bloodParticles = [];
        let decals = [];
        let healthPills = [];
        const matHealthPill = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.2, metalness: 0.8, emissive: 0xff00ff, emissiveIntensity: 0.5 });

        let enemies = [];
        const ZOMBIE_SPEED = 2.5;
        const ZOMBIE_DMG = 10;
        const ATTACK_RANGE = 2.5;
        const ENEMY_RADIUS = 0.4;

        const MAX_ENEMIES = 20;
        const SPAWN_INTERVAL = 2.0;
        let spawnTimer = 0;

        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÌîåÎ†àÏù¥Ïñ¥ Î∞∞Ïó¥
        let otherPlayers = [];

        // ÌîåÎ†àÏù¥Ïñ¥ Î™®Îç∏Ïö© Ïû¨Ïßà (Îã§Î•∏ ÏÉâÏÉÅÏúºÎ°ú Íµ¨Î∂Ñ)
        const matPlayerBody = new THREE.MeshStandardMaterial({ color: 0x4a90e2, roughness: 0.4, metalness: 0.6 });
        const matPlayerSkin = new THREE.MeshStandardMaterial({ color: 0xf4a460, roughness: 0.7 });

        // Í≤åÏûÑ ÌÜµÍ≥Ñ
        let gameStartTime = 0;
        let killCount = 0;
        let playTime = 0;

        let colliders = [];

        // UI - init() Ìï®Ïàò ÎÇ¥Î∂ÄÏóêÏÑú Ï¥àÍ∏∞Ìôî
        let elAmmoVal, elWeaponLabel, elCrosshair, elVignette, elScope;
        let elHpBar, elHpText, elDamage, elPlayTime, elKillCount;
        let elGameOver, elPauseOverlay, elHeadshot, elHitMarker;

        // Materials
        const matBody = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.6 });
        const matParts = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.8 });
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.9 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xcbb093, roughness: 0.7 });
        const matSleeve = new THREE.MeshStandardMaterial({ color: 0x1c1f1c, roughness: 1.0 });
        const matGlove = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.9 });
        const matSight = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const matBlade = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, metalness: 1.0 });
        const matHandle = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const matLens = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.1, metalness: 0.9 });
        const matDecal = new THREE.MeshBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1 });

        const matZombieSkin = new THREE.MeshStandardMaterial({ color: 0x5e7052, roughness: 0.8 });
        const matZombieClothes = new THREE.MeshStandardMaterial({ color: 0x4a3b2a, roughness: 0.9 });
        const matHpBg = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const matHpFg = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        const SoundGen = {
            ctx: null,
            audioBuffers: {}, // Î°úÎìúÎêú Ïò§ÎîîÏò§ ÌååÏùº Ï∫êÏãú
            masterVolume: 1.0, // ÎßàÏä§ÌÑ∞ Î≥ºÎ•® (0.0 ~ 1.0)
            reloadVolume: 0.8, // Ïû¨Ïû•Ï†Ñ Î≥ºÎ•® (0.0 ~ 1.0)
            init: function () {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } catch (e) {
                    console.warn('AudioContext initialization failed:', e);
                }
            },
            // Ïô∏Î∂Ä Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú Ìï®Ïàò
            loadAudioFile: function (url, name) {
                if (!this.ensureContext()) {
                    console.warn('AudioContext not available');
                    return Promise.reject('AudioContext not available');
                }

                // Ïù¥ÎØ∏ Î°úÎìúÎêú Í≤ΩÏö∞ Ï∫êÏãúÏóêÏÑú Î∞òÌôò
                if (this.audioBuffers[name]) {
                    return Promise.resolve(this.audioBuffers[name]);
                }

                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        return this.ctx.decodeAudioData(arrayBuffer);
                    })
                    .then(audioBuffer => {
                        this.audioBuffers[name] = audioBuffer;
                        console.log(`Audio file loaded: ${name}`);
                        return audioBuffer;
                    })
                    .catch(error => {
                        console.error(`Failed to load audio file ${url}:`, error);
                        throw error;
                    });
            },
            // Î°úÎìúÎêú Ïò§ÎîîÏò§ ÌååÏùº Ïû¨ÏÉù Ìï®Ïàò
            playAudioFile: function (name, volume = 1.0, loop = false) {
                if (!this.ensureContext()) return;

                const audioBuffer = this.audioBuffers[name];
                if (!audioBuffer) {
                    console.warn(`Audio file not loaded: ${name}. Use loadAudioFile() first.`);
                    return;
                }

                try {
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();

                    source.buffer = audioBuffer;
                    source.loop = loop;
                    // ÎßàÏä§ÌÑ∞ Î≥ºÎ•® Ï†ÅÏö©
                    gainNode.gain.value = volume * this.masterVolume;

                    source.connect(gainNode);
                    gainNode.connect(this.ctx.destination);

                    source.start(0);

                    return source; // Ïû¨ÏÉù Ï§ëÏßÄ Îì±ÏùÑ ÏúÑÌï¥ Î∞òÌôò
                } catch (e) {
                    console.error(`Failed to play audio file ${name}:`, e);
                }
            },
            ensureContext: function () {
                if (!this.ctx) {
                    this.init();
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.warn('AudioContext resume failed:', e));
                }
                return !!this.ctx;
            },
            playShoot: function (type) {
                if (!this.ensureContext()) return;

                // Ï†ÄÍ≤©Ï¥ùÏùÄ Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (type === 'SNIPER' && this.audioBuffers['rifle']) {
                    this.playAudioFile('rifle', 0.25); // Î≥ºÎ•® 25%
                    return;
                }

                // Í∂åÏ¥ùÏùÄ Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (type === 'PISTOL' && this.audioBuffers['gunshot']) {
                    this.playAudioFile('gunshot', 0.8);
                    return;
                }

                // Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ± (Ìè¥Î∞±)
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                filter.type = 'lowpass';
                if (type === 'SNIPER') {
                    filter.frequency.value = 600;
                    gain.gain.setValueAtTime(1.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
                } else if (type === 'RIFLE') {
                    filter.frequency.value = 1000;
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                } else {
                    filter.frequency.value = 1500;
                    gain.gain.setValueAtTime(0.8, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                }

                noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            },
            playDryFire: function () {
                if (!this.ensureContext()) return;

                // Îπà Í≤©Î∞ú Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (this.audioBuffers['empty']) {
                    this.playAudioFile('empty', 0.8);
                } else {
                    // Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ± (Ìè¥Î∞±)
                    const t = this.ctx.currentTime;

                    // Í∏∞Í≥ÑÏùåÏùò Ìã±Ìã± Í∞ôÏùÄ Ï≤†Ï†ú ÏÜåÎ¶¨
                    try {
                        // Ï≤´ Î≤àÏß∏ Ìã± - ÏßßÍ≥† ÎÇ†Ïπ¥Î°úÏö¥ ÏÜåÎ¶¨
                        const osc1 = this.ctx.createOscillator();
                        const gain1 = this.ctx.createGain();
                        osc1.type = 'square'; // Í∏∞Í≥ÑÏùå ÎäêÎÇå
                        osc1.frequency.setValueAtTime(1200, t);
                        osc1.frequency.exponentialRampToValueAtTime(800, t + 0.02);
                        gain1.gain.setValueAtTime(0.2, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
                        osc1.connect(gain1);
                        gain1.connect(this.ctx.destination);
                        osc1.start(t);
                        osc1.stop(t + 0.03);

                        // Îëê Î≤àÏß∏ Ìã± - ÏïΩÍ∞Ñ ÏßÄÏó∞Îêú Î©îÌÉàÎ¶≠ ÏÜåÎ¶¨
                        const osc2 = this.ctx.createOscillator();
                        const gain2 = this.ctx.createGain();
                        osc2.type = 'sawtooth'; // Ï≤†Ï†ú ÎäêÎÇå
                        osc2.frequency.setValueAtTime(1500, t + 0.01);
                        osc2.frequency.exponentialRampToValueAtTime(600, t + 0.04);
                        gain2.gain.setValueAtTime(0.15, t + 0.01);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc2.connect(gain2);
                        gain2.connect(this.ctx.destination);
                        osc2.start(t + 0.01);
                        osc2.stop(t + 0.05);

                        // Î©îÌÉàÎ¶≠ Í≥µÎ™Ö Ìö®Í≥º
                        const osc3 = this.ctx.createOscillator();
                        const gain3 = this.ctx.createGain();
                        osc3.type = 'sine';
                        osc3.frequency.setValueAtTime(2000, t);
                        osc3.frequency.exponentialRampToValueAtTime(1000, t + 0.04);
                        gain3.gain.setValueAtTime(0.1, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.04);
                        osc3.connect(gain3);
                        gain3.connect(this.ctx.destination);
                        osc3.start(t);
                        osc3.stop(t + 0.04);
                    } catch (e) {
                        console.warn('Dry fire sound error:', e);
                    }
                }
            },
            playBoltAction: function () {
                if (!this.ensureContext()) return;

                // Ï†ÄÍ≤©Ï¥ù Î≥ºÌä∏ Ïï°ÏÖò Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö© (c-rifle.mp3), ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (this.audioBuffers['c-rifle']) {
                    this.playAudioFile('c-rifle', 0.8);
                } else {
                    // Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ± (Ìè¥Î∞±)
                    const t = this.ctx.currentTime;
                    const osc1 = this.ctx.createOscillator();
                    const gain1 = this.ctx.createGain();
                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(150, t);
                    gain1.gain.setValueAtTime(0.2, t);
                    gain1.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc1.connect(gain1); gain1.connect(this.ctx.destination);
                    osc1.start(t); osc1.stop(t + 0.1);

                    const osc2 = this.ctx.createOscillator();
                    const gain2 = this.ctx.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(200, t + 0.15);
                    gain2.gain.setValueAtTime(0.2, t + 0.15);
                    gain2.gain.linearRampToValueAtTime(0, t + 0.25);
                    osc2.connect(gain2); gain2.connect(this.ctx.destination);
                    osc2.start(t + 0.15); osc2.stop(t + 0.25);
                }
            },
            playZombieAttack: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.1);
            },
            playKnife: function () {
                if (!this.ensureContext()) return;

                // ÎÇòÏù¥ÌîÑ ÌúòÎëêÎ•¥Í∏∞ Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (this.audioBuffers['sword']) {
                    this.playAudioFile('sword', 0.8);
                } else {
                    // Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ± (Ìè¥Î∞±)
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.2);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.2);
                }
            },
            playJump: function (land) {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(land ? 0.2 : 0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playStep: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                noise.start();
            },
            playReload: function () {
                if (!this.ensureContext()) return;

                // Ïò§ÎîîÏò§ ÌååÏùºÏù¥ Î°úÎìúÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ±
                if (this.audioBuffers['reload']) {
                    this.playAudioFile('reload', this.reloadVolume);
                } else {
                    // Í∏∞Ï°¥ ÏÜåÎ¶¨ ÏÉùÏÑ± (Ìè¥Î∞±)
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.1);
                }
            },
            playHeadshot: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;

                // Íπ®ÏßÄÎäî ÏÜåÎ¶¨ - ÎÖ∏Ïù¥Ï¶à Í∏∞Î∞ò
                const bufferSize = this.ctx.sampleRate * 0.15;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Íπ®ÏßÄÎäî ÎäêÎÇåÏùò ÎÖ∏Ïù¥Ï¶à ÏÉùÏÑ±
                for (let i = 0; i < bufferSize; i++) {
                    const progress = i / bufferSize;
                    // Íπ®ÏßÄÎäî ÏÜåÎ¶¨: Í≥†Ï£ºÌåå ÎÖ∏Ïù¥Ï¶à + Í∏âÍ≤©Ìïú Í∞êÏá†
                    const noise = (Math.random() * 2 - 1) * (1 - progress * 0.8);
                    // Í≥†Ï£ºÌåå Í∞ïÏ°∞
                    const highFreq = Math.sin(progress * Math.PI * 20) * 0.3;
                    data[i] = noise * (1 - progress) + highFreq * (1 - progress);
                }

                const noiseSource = this.ctx.createBufferSource();
                noiseSource.buffer = buffer;

                // Í≥†Ïó≠ ÌïÑÌÑ∞Î°ú Íπ®ÏßÄÎäî ÎäêÎÇå Í∞ïÏ°∞
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(2000, t);
                filter.frequency.exponentialRampToValueAtTime(800, t + 0.15);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noiseSource.start(t);
                noiseSource.stop(t + 0.15);

                // Ï∂îÍ∞Ä Íπ®ÏßÄÎäî ÏÜåÎ¶¨ Î†àÏù¥Ïñ¥
                const osc = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(3000, t);
                osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            },
            playHit: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                // ÌîºÍ≤© ÏÇ¨Ïö¥Îìú - ÏßßÍ≥† ÎÇ†Ïπ¥Î°úÏö¥ ÏÜåÎ¶¨ (Î≥ºÎ•® ÏïΩÍ∞Ñ Í∞êÏÜå)
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'square';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(400, t + 0.05);
                gain1.gain.setValueAtTime(0.12, t); // 0.2 -> 0.12 (Î≥ºÎ•® Í∞êÏÜå)
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.08);

                // Ï∂îÍ∞Ä ÌÉÄÍ≤©Ïùå (Î≥ºÎ•® ÏïΩÍ∞Ñ Í∞êÏÜå)
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(200, t);
                osc2.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain2.gain.setValueAtTime(0.09, t); // 0.15 -> 0.09 (Î≥ºÎ•® Í∞êÏÜå)
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.1);
            },
            playSwitch: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                // Mechanical Clank
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.15);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playHealthPill: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
                gain1.gain.setValueAtTime(0.3, t);
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.3);

                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(600, t);
                osc2.frequency.exponentialRampToValueAtTime(400, t + 0.2);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.25);
            }
        };

        // ============================================
        // Î≥ºÎ•® Ï°∞Ï†à Î∞©Î≤ï:
        // ============================================
        // 
        // 1. Ïû¨Ïû•Ï†Ñ Î≥ºÎ•® Ï°∞Ï†à:
        SoundGen.reloadVolume = 0.3; // 0.0 (Î¨¥Ïùå) ~ 1.0 (ÏµúÎåÄ)
        //
        // 2. ÎßàÏä§ÌÑ∞ Î≥ºÎ•® Ï°∞Ï†à (Î™®Îì† Ïò§ÎîîÏò§ ÌååÏùºÏóê Ï†ÅÏö©):
        //    SoundGen.masterVolume = 0.7; // 0.0 (Î¨¥Ïùå) ~ 1.0 (ÏµúÎåÄ)
        //
        // 3. Î∏åÎùºÏö∞Ï†Ä ÏΩòÏÜîÏóêÏÑú Ïã§ÏãúÍ∞Ñ Ï°∞Ï†à:
        //    Í∞úÎ∞úÏûê ÎèÑÍµ¨(F12) > Console ÌÉ≠ÏóêÏÑú:
        //    SoundGen.reloadVolume = 0.3; // Ïû¨Ïû•Ï†Ñ ÏÜåÎ¶¨Îßå ÏûëÍ≤å
        //    SoundGen.masterVolume = 0.5; // Î™®Îì† ÏÜåÎ¶¨ ÏûëÍ≤å
        //
        // ============================================
        // Ïô∏Î∂Ä Ïò§ÎîîÏò§ ÌååÏùº ÏÇ¨Ïö© ÏòàÏãú:
        // ============================================
        // 
        // 1. Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú (Í≤åÏûÑ ÏãúÏûë Ïãú ÎòêÎäî ÌïÑÏöîÌï† Îïå):
        // SoundGen.loadAudioFile('sounds/shoot.mp3', 'shootSound')
        //     .then(() => console.log('Sound loaded!'))
        //     .catch(err => console.error('Failed to load sound:', err));
        //
        // 2. Î°úÎìúÎêú Ïò§ÎîîÏò§ ÌååÏùº Ïû¨ÏÉù:
        // SoundGen.playAudioFile('shootSound', 0.8); // Î≥ºÎ•® 0.8Î°ú Ïû¨ÏÉù
        //
        // 3. Ïó¨Îü¨ Ïò§ÎîîÏò§ ÌååÏùº ÎèôÏãú Î°úÎìú:
        // Promise.all([
        //     SoundGen.loadAudioFile('sounds/shoot.mp3', 'shoot'),
        //     SoundGen.loadAudioFile('sounds/reload.mp3', 'reload'),
        //     SoundGen.loadAudioFile('sounds/hit.mp3', 'hit')
        // ]).then(() => console.log('All sounds loaded!'));
        //
        // 4. Í∏∞Ï°¥ Ìï®ÏàòÎ•º Ïò§ÎîîÏò§ ÌååÏùºÎ°ú ÎåÄÏ≤¥ÌïòÎ†§Î©¥:
        // playShoot: function(type) {
        //     // Í∏∞Ï°¥ ÏΩîÎìú ÎåÄÏã†:
        //     SoundGen.playAudioFile('shootSound', 1.0);
        // }

        // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Î¶¨ÏÜåÏä§ Î°úÎî© ÏôÑÎ£å ÌõÑ Ï¥àÍ∏∞Ìôî
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            // Ïù¥ÎØ∏ Î°úÎìú ÏôÑÎ£åÎêòÏóàÏúºÎ©¥ Î∞îÎ°ú Ìò∏Ï∂ú
            init();
        }

        function init() {
            // Î™®Îìú ÏÑ†ÌÉù ÌôîÎ©¥ ÌëúÏãú
            const modeSelection = document.getElementById('mode-selection');
            const roomCreation = document.getElementById('room-creation');
            const roomWaiting = document.getElementById('room-waiting');

            modeSelection.style.display = 'flex';

            // Î™®Îìú ÏÑ†ÌÉù Î≤ÑÌäº Ïù¥Î≤§Ìä∏
            document.getElementById('btn-single-player').addEventListener('click', () => {
                gameMode = 'single';
                modeSelection.style.display = 'none';
                startGame();
            });

            document.getElementById('btn-multi-player').addEventListener('click', () => {
                modeSelection.style.display = 'none';
                roomCreation.style.display = 'flex';
            });

            // Î∞© ÏÉùÏÑ± Ï∑®ÏÜå
            document.getElementById('btn-cancel-create').addEventListener('click', () => {
                roomCreation.style.display = 'none';
                modeSelection.style.display = 'flex';
            });

            // Î∞© ÏÉùÏÑ± (Ïã§Ï†úÎ°úÎäî ÏÑúÎ≤Ñ Ï†ëÏÜç)
            document.getElementById('btn-create-room').addEventListener('click', () => {
                let serverAddr = document.getElementById('server-ip').value || 'localhost:3000';
                // Ìè¨Ìä∏Í∞Ä ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í :3000 Ï∂îÍ∞Ä
                if (!serverAddr.includes(':')) serverAddr += ':3000';
                const playerName = document.getElementById('player-name').value || 'User';

                gameMode = 'multi';
                roomCreation.style.display = 'none';
                roomWaiting.style.display = 'flex';
                document.getElementById('room-waiting').querySelector('h2').innerText = 'ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...';

                initMultiplayer(serverAddr, playerName);
            });

            function initMultiplayer(addr, name) {
                try {
                    // http:// ÌîÑÎ°úÌÜ†ÏΩú Í∞ïÏ†ú
                    const connectionUrl = addr.startsWith('http') ? addr : `http://${addr}`;
                    socket = io(connectionUrl, {
                        reconnectionAttempts: 5,
                        timeout: 10000
                    });

                    socket.on('connect', () => {
                        console.log('Connected to server');
                        socket.emit('join', { name: name });
                        document.getElementById('room-waiting').querySelector('h2').innerText = 'ÎåÄÍ∏∞Ïã§';
                    });

                    socket.on('connect_error', (error) => {
                        console.error('Connection Error:', error);
                        document.getElementById('room-waiting').querySelector('h2').innerText = 'Ïó∞Í≤∞ Ïã§Ìå®: ' + error.message;
                        // 5Ï¥à ÌõÑ Îã§Ïãú ÏãúÎèÑ Î≤ÑÌäº ÌôúÏÑ±Ìôî Îì± Í∞ÄÎä•
                    });

                    socket.on('connect_timeout', () => {
                        console.error('Connection Timeout');
                        document.getElementById('room-waiting').querySelector('h2').innerText = 'Ïó∞Í≤∞ ÏãúÍ∞Ñ Ï¥àÍ≥º';
                    });

                    socket.on('currentPlayers', (players) => {
                        playersList = Object.values(players);
                        currentPlayers = playersList.length;
                        myId = socket.id;
                        updatePlayersList();

                        // Í∏∞Ï°¥ ÌîåÎ†àÏù¥Ïñ¥ Î™®Îç∏ ÏÉùÏÑ±
                        playersList.forEach(p => {
                            if (p.id !== myId) createRemotePlayer(p);
                        });

                        // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Îäî Ïù∏Ïõê ÏÉÅÍ¥ÄÏóÜÏù¥ ÏãúÏûë Í∞ÄÎä•ÌïòÎèÑÎ°ù Ìï® (ÎòêÎäî ÏÑúÎ≤ÑÏóêÏÑú ÏãúÏûë Ïù¥Î≤§Ìä∏ Ï§Ñ Ïàò ÏûàÏùå)
                        // Ïó¨Í∏∞ÏÑúÎäî ÏùºÎã® Ï†ëÏÜçÎêòÎ©¥ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏóÜÏù¥ Î∞îÎ°ú ÏãúÏûë Í∞ÄÎä•ÌïòÎèÑÎ°ù Î≤ÑÌäº UIÎ•º Î∞îÍøÄ ÏàòÎèÑ ÏûàÏßÄÎßå
                        // Í∏∞Ï°¥ startCountdown()ÏùÑ ÌôúÏö©ÌïòÍ±∞ÎÇò Ï¶âÏãú ÏãúÏûë
                        if (currentPlayers >= 1) { // ÏµúÏÜå 1Î™Ö(Î≥∏Ïù∏) Ïù¥ÏÉÅÏù¥Î©¥ Î∞îÎ°ú ÏãúÏûë Î≤ÑÌäº ÎÖ∏Ï∂ú Îì± Í∞ÄÎä•
                            // ÏùºÎã® 3Ï¥à Îí§ ÏûêÎèô ÏãúÏûë
                            setTimeout(startCountdown, 2000);
                        }
                    });

                    socket.on('newPlayer', (p) => {
                        playersList.push(p);
                        currentPlayers = playersList.length;
                        updatePlayersList();
                        createRemotePlayer(p);
                    });

                    socket.on('playerMoved', (p) => {
                        const mesh = otherPlayersMap[p.id];
                        if (mesh) {
                            mesh.position.copy(p.position);
                            mesh.rotation.y = p.rotation.y;
                            // Î®∏Î¶¨ ÌöåÏ†Ñ Îì± Ï∂îÍ∞Ä Í∞ÄÎä•
                            if (mesh.userData.head) {
                                mesh.userData.head.rotation.x = p.rotation.x;
                            }
                        }
                    });

                    socket.on('playerActioned', (data) => {
                        const mesh = otherPlayersMap[data.id];
                        if (mesh) {
                            // Î∞úÏÇ¨ Ìö®Í≥ºÏùå Îì± ÏõêÍ≤© Ïû¨ÏÉù
                            if (data.action === 'shoot') {
                                // THREE.PositionalAudio Îì±ÏùÑ Ïì∞Î©¥ Ï¢ãÏßÄÎßå Ïó¨Í∏∞ÏÑ† Îã®Ïàú Ïû¨ÏÉù
                                SoundGen.playShoot(WEAPONS[data.weaponIdx].type);
                                // Î®∏Ï¶ê ÌîåÎûòÏãú Ìö®Í≥º ÏõêÍ≤© Ïû¨ÌòÑ Í∞ÄÎä•
                            }
                        }
                    });

                    socket.on('playerDamaged', (data) => {
                        if (data.id === myId) {
                            damagePlayer(0); // ÌîºÍ≤© Ìö®Í≥ºÎßå (Ïã§Ï†ú Ï≤¥Î†•ÏùÄ ÏÑúÎ≤Ñ Í∂åÏúÑÎ°ú ÌïòÍ±∞ÎÇò ÌÅ¥ÎùºÏóêÏÑú ÍπéÏùå)
                            // ÏÑúÎ≤ÑÏóêÏÑú Ï§Ä hpÎ°ú ÎèôÍ∏∞Ìôî
                            playerHP = data.hp;
                            updateHPUI();
                        } else {
                            const mesh = otherPlayersMap[data.id];
                            if (mesh) {
                                mesh.userData.hp = data.hp;
                                const hpPercent = Math.max(0, mesh.userData.hp / 100);
                                mesh.userData.hpBar.scale.x = hpPercent;
                            }
                        }
                    });

                    socket.on('playerDied', (data) => {
                        if (data.id === myId) {
                            playerHP = 0;
                            updateHPUI();
                            isDead = true;
                            elGameOver.style.display = 'flex';
                        } else {
                            const mesh = otherPlayersMap[data.id];
                            if (mesh) {
                                scene.remove(mesh);
                                delete otherPlayersMap[data.id];
                            }
                        }
                    });

                    socket.on('playerDisconnected', (id) => {
                        const mesh = otherPlayersMap[id];
                        if (mesh) {
                            scene.remove(mesh);
                            delete otherPlayersMap[id];
                        }
                        playersList = playersList.filter(p => p.id !== id);
                        currentPlayers = playersList.length;
                        updatePlayersList();
                    });

                } catch (e) {
                    alert('ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®: ' + e.message);
                    roomWaiting.style.display = 'none';
                    modeSelection.style.display = 'flex';
                }
            }

            function createRemotePlayer(p) {
                const group = new THREE.Group();

                // Í∞ÑÎã®Ìïú ÌîåÎ†àÏù¥Ïñ¥ Î™®Îç∏ (Í∏∞Î≥∏ Ï†Å Î™®Îç∏ Ïû¨ÏÇ¨Ïö©)
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), matPlayerBody);
                body.position.y = 0.6;
                group.add(body);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matPlayerSkin);
                head.position.y = 1.4;
                head.name = 'head';
                group.add(head);
                group.userData.head = head;

                // HP Bar
                const hpBg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.1), matHpBg);
                hpBg.position.y = 1.8;
                group.add(hpBg);
                const hpFg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.1), matHpFg);
                hpFg.position.y = 1.8;
                hpFg.position.z = 0.01;
                group.add(hpFg);

                group.userData.hp = p.hp;
                group.userData.hpBar = hpFg;
                group.userData.playerId = p.id;

                group.position.copy(p.position);
                scene.add(group);
                otherPlayersMap[p.id] = group;
                otherPlayers.push(group);
            }

            // Î∞© ÎÇòÍ∞ÄÍ∏∞
            document.getElementById('btn-leave-room').addEventListener('click', () => {
                if (countdownTimer) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
                roomWaiting.style.display = 'none';
                modeSelection.style.display = 'flex';
                gameMode = null;
                isRoomHost = false;
                currentPlayers = 1;
                playersList = [];
                document.getElementById('countdown').style.display = 'none';
            });

            // UI ÏöîÏÜå Ï¥àÍ∏∞Ìôî (DOMÏù¥ Î°úÎìúÎêú ÌõÑ)
            elAmmoVal = document.getElementById('ammo-val');
            elWeaponLabel = document.getElementById('weapon-label');
            elCrosshair = document.getElementById('crosshair');
            elVignette = document.getElementById('vignette');
            elScope = document.getElementById('scope-overlay');
            elHpBar = document.getElementById('hp-bar');
            elHpText = document.getElementById('hp-text');
            elDamage = document.getElementById('damage-overlay');
            elPlayTime = document.getElementById('play-time');
            elKillCount = document.getElementById('kill-count');
            elGameOver = document.getElementById('game-over');
            elPauseOverlay = document.getElementById('pause-overlay');
            elHeadshot = document.getElementById('headshot-msg');
            elHitMarker = document.getElementById('hit-marker');

            scene = new THREE.Scene();
            const fogColor = 0x10151a;
            scene.background = new THREE.Color(fogColor);
            scene.fog = new THREE.FogExp2(fogColor, 0.025);

            // Ï¥àÍ∏∞ Ïπ¥Î©îÎùº ÏÑ§Ï†ï (Î™®Î∞îÏùº Í∞ÄÎ°ú Î™®Îìú ÎåÄÏùë)
            let initAspect = window.innerWidth / window.innerHeight;
            if (window.visualViewport) {
                initAspect = window.visualViewport.width / window.visualViewport.height;
            }
            camera = new THREE.PerspectiveCamera(70, initAspect, 0.005, 1000);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            ceilingLight = new THREE.PointLight(0xffaa00, 2.0, 50);
            ceilingLight.position.set(0, 10, 0);
            ceilingLight.castShadow = true;
            ceilingLight.visible = false; // Ï¥àÍ∏∞ÏóêÎäî Í∫ºÏ†∏ÏûàÏùå
            scene.add(ceilingLight);
            const blueLight = new THREE.DirectionalLight(0x4455ff, 0.5);
            blueLight.position.set(-10, 5, -10);
            scene.add(blueLight);

            // ÌôïÏû• Í∏∞Îä• Ï¥àÍ∏∞Ìôî (Îßµ ÏÉùÏÑ± Ï†ÑÏóê ÌÖçÏä§Ï≤ò ÏãúÏä§ÌÖúÏùÑ Î®ºÏ†Ä Ï¥àÍ∏∞Ìôî)
            try {
                initTextureSystem();
                initModelLoader();
                initPhysics();
            } catch (error) {
                console.warn('Some extension features failed to initialize:', error);
            }

            createFactoryMap();

            weaponContainer = new THREE.Group();
            scene.add(weaponContainer);
            weaponModel = new THREE.Group();
            weaponContainer.add(weaponModel);

            shellGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.025, 6);
            shellGeo.rotateX(Math.PI / 2);
            shellMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.3 });

            buildWeapon(0);
            updateUI();

            // Í≤åÏûÑ ÏãúÏûë ÏãúÍ∞Ñ ÏÑ§Ï†ï
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
            if (elKillCount) elKillCount.innerText = "Kills: 0";

            // Ï†Å ÏÉùÏÑ±ÏùÄ startGame()ÏóêÏÑú Ï≤òÎ¶¨

            // ÏÑ±Îä• ÏµúÏ†ÅÌôî: Î†åÎçîÎü¨ ÏÑ§Ï†ï
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance" // Í≥†ÏÑ±Îä• Î™®Îìú
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Î™®Î∞îÏùº ÏÑ±Îä• ÏµúÏ†ÅÌôî: ÌîΩÏÖÄ ÎπÑÏú® Ï°∞Ï†ï
            const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false; // ÏÑ±Îä• Ìñ•ÏÉÅ
            renderer.shadowMap.needsUpdate = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Ï¥àÍ∏∞Ìôî (ÌôúÏÑ±Ìôî)
            try {
                initPostProcessing();
            } catch (error) {
                console.warn('Post-processing initialization failed:', error);
                usePostProcessing = false;
            }

            // Î¶¨ÏÇ¨Ïù¥Ï¶à Ïù¥Î≤§Ìä∏Îäî init() ÎÅùÎ∂ÄÎ∂ÑÏóêÏÑú Î≥ÑÎèÑÎ°ú Ï≤òÎ¶¨ (Ï§ëÎ≥µ Î∞©ÏßÄ)
            document.addEventListener('contextmenu', e => e.preventDefault());

            const loadAudioFiles = () => {
                if (!SoundGen.ctx) SoundGen.init();
                if (SoundGen.ctx.state === 'suspended') SoundGen.ctx.resume();

                // Ïû¨Ïû•Ï†Ñ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('reload1.mp3', 'reload')
                    .catch(err => console.warn('Failed to load reload sound:', err));

                // Ï†ÄÍ≤©Ï¥ù Î∞úÏÇ¨ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('rifle.mp3', 'rifle')
                    .catch(err => console.warn('Failed to load rifle sound:', err));

                // ÎÇòÏù¥ÌîÑ ÌúòÎëêÎ•¥Í∏∞ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('sword.mp3', 'sword')
                    .catch(err => console.warn('Failed to load sword sound:', err));

                // ÎÇòÏù¥ÌîÑ ÍµêÏ≤¥ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('c-sword.mp3', 'c-sword')
                    .catch(err => console.warn('Failed to load c-sword sound:', err));

                // ÏÜåÏ¥ù ÍµêÏ≤¥ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('c-sochong.mp3', 'c-sochong')
                    .catch(err => console.warn('Failed to load c-sochong sound:', err));

                // Í∂åÏ¥ù ÍµêÏ≤¥ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('c-gun.mp3', 'c-gun')
                    .catch(err => console.warn('Failed to load c-gun sound:', err));

                // Ï†ÄÍ≤©Ï¥ù ÍµêÏ≤¥ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('c-rifle.mp3', 'c-rifle')
                    .catch(err => console.warn('Failed to load c-rifle sound:', err));

                // Îπà Í≤©Î∞ú Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('empty.mp3', 'empty')
                    .catch(err => console.warn('Failed to load empty sound:', err));

                // Í∂åÏ¥ù Î∞úÏÇ¨ Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
                SoundGen.loadAudioFile('gunshot.mp3', 'gunshot')
                    .catch(err => console.warn('Failed to load gunshot sound:', err));
            };

            // Îç∞Ïä§ÌÅ¨ÌÜ±Í≥º Î™®Î∞îÏùº Î™®ÎëêÏóêÏÑú Ïò§ÎîîÏò§ ÌååÏùº Î°úÎìú
            document.body.addEventListener('mousedown', loadAudioFiles, { once: true });
            document.body.addEventListener('touchstart', loadAudioFiles, { once: true });

            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // Ï°∞Î™Ö ÌÜ†Í∏Ä Î≤ÑÌäº Ïù¥Î≤§Ìä∏
            const lightToggleBtn = document.getElementById('light-toggle-btn');
            if (lightToggleBtn) {
                const toggleLight = () => {
                    if (ceilingLight && ambientLight) {
                        ceilingLight.visible = !ceilingLight.visible;
                        if (ceilingLight.visible) {
                            // Ï°∞Î™Ö Ïº§ Îïå Îçî Î∞ùÍ≤å
                            ceilingLight.intensity = 2.5;
                            ambientLight.intensity = 0.7;
                        } else {
                            // Ï°∞Î™Ö ÎÅå Îïå ÏõêÎûòÎåÄÎ°ú
                            ceilingLight.intensity = 2.0;
                            ambientLight.intensity = 0.4;
                        }
                        lightToggleBtn.classList.toggle('active', ceilingLight.visible);
                    }
                };
                lightToggleBtn.addEventListener('click', toggleLight);
                lightToggleBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleLight();
                }, { passive: false });
            }

            // setupControlsÏôÄ animateÎäî startGame()ÏóêÏÑú Ìò∏Ï∂úÎê®

            // ÌôîÎ©¥ ÌöåÏ†Ñ Í∞êÏßÄ Î∞è Î†àÏù¥ÏïÑÏõÉ Ï°∞Ï†ï
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    onResize();
                    // Î™®Î∞îÏùº Ïª®Ìä∏Î°§ ÏúÑÏπò Ïû¨Ï°∞Ï†ï (ÌïÑÏöîÏãú Ï∂îÍ∞Ä)
                }, 300); // Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞Ω Ïï†ÎãàÎ©îÏù¥ÏÖò ÎåÄÍ∏∞
            });

            // visualViewport Î≥ÄÍ≤Ω Í∞êÏßÄ (Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞Ω ÌëúÏãú/Ïà®ÍπÄ)
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => {
                    onResize();
                });
                window.visualViewport.addEventListener('scroll', () => {
                    // Ïä§ÌÅ¨Î°§ Î∞©ÏßÄ
                    window.scrollTo(0, 0);
                });
            }

            // Ï∂îÍ∞Ä Î¶¨ÏÇ¨Ïù¥Ï¶à Ïù¥Î≤§Ìä∏ (Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞Ω ÎåÄÏùë)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    onResize();
                }, 100);
            });
        }

        // --- ÌÖçÏä§Ï≤ò ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ---
        function initTextureSystem() {
            textureLoader = new THREE.TextureLoader();

            // Ï†àÏ∞®Ï†Å ÌÖçÏä§Ï≤ò ÏÉùÏÑ± (ÌååÏùº ÏóÜÏù¥ ÏÇ¨Ïö© Í∞ÄÎä•)
            // CanvasÎ•º ÏÇ¨Ïö©Ìïú Í∞ÑÎã®Ìïú ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // ÏΩòÌÅ¨Î¶¨Ìä∏ ÌÖçÏä§Ï≤ò Ìå®ÌÑ¥
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.3)`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
            }
            window.concreteTexture = new THREE.CanvasTexture(canvas);
            window.concreteTexture.wrapS = THREE.RepeatWrapping;
            window.concreteTexture.wrapT = THREE.RepeatWrapping;
            window.concreteTexture.repeat.set(4, 4);

            // Î©îÌÉà ÌÖçÏä§Ï≤ò Ìå®ÌÑ¥
            const metalCanvas = document.createElement('canvas');
            metalCanvas.width = 256;
            metalCanvas.height = 256;
            const metalCtx = metalCanvas.getContext('2d');
            const gradient = metalCtx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#556677');
            gradient.addColorStop(0.5, '#778899');
            gradient.addColorStop(1, '#445566');
            metalCtx.fillStyle = gradient;
            metalCtx.fillRect(0, 0, 256, 256);
            window.metalTexture = new THREE.CanvasTexture(metalCanvas);
            window.metalTexture.wrapS = THREE.RepeatWrapping;
            window.metalTexture.wrapT = THREE.RepeatWrapping;
        }

        // --- 3D Î™®Îç∏ Î°úÎçî Ï¥àÍ∏∞Ìôî (GLTF ÌååÏùº Î°úÎî©) ---
        function initModelLoader() {
            // GLTFLoaderÎäî Three.js ÏòàÏ†ú ÌååÏùºÏù¥ ÌïÑÏöîÌïòÏßÄÎßå,
            // Í∏∞Î≥∏ Íµ¨Ï°∞ÏôÄ ÏÇ¨Ïö©Î≤ïÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.

            // ÏÇ¨Ïö© ÏòàÏ†ú:
            // 1. Three.js examples Ìè¥ÎçîÏóêÏÑú GLTFLoader.js Îã§Ïö¥Î°úÎìú
            // 2. Î°úÏª¨ ÌååÏùºÎ°ú Ï∂îÍ∞Ä: script ÌÉúÍ∑∏Î°ú GLTFLoader.js Ìè¨Ìï®
            // 3. loadGLTFModel('model.gltf', (model) => { scene.add(model); });

            console.log('Model loader system ready (GLTFLoader.js file required)');
        }

        // --- 3D Î™®Îç∏ Î°úÎìú Ìï®Ïàò ---
        function loadGLTFModel(url, callback, onError) {
            // GLTFLoader ÏÇ¨Ïö© ÏòàÏ†ú Ìï®Ïàò
            // Ïã§Ï†ú ÏÇ¨Ïö©ÌïòÎ†§Î©¥ GLTFLoader.js ÌååÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§

            if (typeof THREE.GLTFLoader !== 'undefined') {
                if (!gltfLoader) {
                    gltfLoader = new THREE.GLTFLoader();
                }
                gltfLoader.load(
                    url,
                    (gltf) => {
                        callback(gltf.scene);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading GLTF model:', error);
                        if (onError) onError(error);
                    }
                );
            } else {
                console.warn('GLTFLoader not available. Please include GLTFLoader.js');
                if (onError) onError(new Error('GLTFLoader not available'));
            }
        }

        // --- Ï†àÏ∞®Ï†Å 3D Î™®Îç∏ ÏÉùÏÑ± Ìï®Ïàò (GLTF ÏóÜÏù¥ ÏÇ¨Ïö© Í∞ÄÎä•) ---
        function createProceduralModel(type, options = {}) {
            // GLTF ÌååÏùº ÏóÜÏù¥ Ï†àÏ∞®Ï†ÅÏúºÎ°ú Î™®Îç∏ÏùÑ ÏÉùÏÑ±ÌïòÎäî Ìï®Ïàò
            const group = new THREE.Group();

            switch (type) {
                case 'crate':
                    const size = options.size || 1;
                    const crateGeo = new THREE.BoxGeometry(size, size, size);
                    const crateMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x8B4513,
                        roughness: 0.8
                    });
                    const crate = new THREE.Mesh(crateGeo, crateMat);
                    group.add(crate);
                    break;

                case 'barrel':
                    const radius = options.radius || 0.5;
                    const height = options.height || 1;
                    const barrelGeo = new THREE.CylinderGeometry(radius, radius, height, 16);
                    const barrelMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x654321,
                        roughness: 0.7
                    });
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    group.add(barrel);
                    break;
            }

            return group;
        }

        // --- Í∞ÑÎã®Ìïú Î¨ºÎ¶¨ ÏóîÏßÑ Íµ¨ÌòÑ (Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏóÜÏù¥) ---
        const physicsBodies = []; // Î¨ºÎ¶¨ Î∞îÎîî Î∞∞Ïó¥

        function initPhysics() {
            // Í∞ÑÎã®Ìïú Î¨ºÎ¶¨ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
            physicsWorld = {
                gravity: new THREE.Vector3(0, -9.82, 0),
                bodies: []
            };
            usePhysics = true;
            console.log('Simple physics system initialized');
        }

        // --- Î¨ºÎ¶¨ Î∞îÎîî ÏÉùÏÑ± Ìï®Ïàò ---
        function createPhysicsBody(mesh, mass = 1, useGravity = true) {
            if (!usePhysics) return null;

            const body = {
                mesh: mesh,
                velocity: new THREE.Vector3(0, 0, 0),
                mass: mass,
                useGravity: useGravity,
                position: mesh.position.clone(),
                active: true
            };

            physicsWorld.bodies.push(body);
            return body;
        }

        // --- Î¨ºÎ¶¨ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò ---
        function updatePhysics(dt) {
            if (!usePhysics || !physicsWorld) return;

            for (let i = 0; i < physicsWorld.bodies.length; i++) {
                const body = physicsWorld.bodies[i];
                if (!body.active) continue;

                // Ï§ëÎ†• Ï†ÅÏö©
                if (body.useGravity && body.mass > 0) {
                    body.velocity.y += physicsWorld.gravity.y * dt;
                }

                // ÏÜçÎèÑÎ°ú ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
                body.position.x += body.velocity.x * dt;
                body.position.y += body.velocity.y * dt;
                body.position.z += body.velocity.z * dt;

                // Î©îÏãú ÏúÑÏπò ÎèôÍ∏∞Ìôî
                body.mesh.position.copy(body.position);

                // Î∞îÎã• Ï∂©Îèå (Í∞ÑÎã®Ìïú ÏòàÏ†ú)
                if (body.position.y < 0.5) {
                    body.position.y = 0.5;
                    body.velocity.y = 0;
                }

                // Í≥µÍ∏∞ Ï†ÄÌï≠
                body.velocity.multiplyScalar(0.98);
            }
        }

        // --- Í∞ÑÎã®Ìïú ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Íµ¨ÌòÑ (WebGL ÏâêÏù¥Îçî ÏÇ¨Ïö©) ---
        let postProcessingCanvas, postProcessingCtx;
        let postProcessingEnabled = false;

        function initPostProcessing() {
            try {
                // CanvasÎ•º ÏÇ¨Ïö©Ìïú Í∞ÑÎã®Ìïú ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º
                postProcessingCanvas = document.createElement('canvas');
                postProcessingCanvas.width = window.innerWidth;
                postProcessingCanvas.height = window.innerHeight;
                postProcessingCtx = postProcessingCanvas.getContext('2d');

                // ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Î≥ÄÏàò (Í≤åÏûÑ Î∂ÑÏúÑÍ∏∞Ïóê ÎßûÍ≤å Ï°∞Ï†ï)
                window.postProcessingEffects = {
                    brightness: 1.1,      // ÏïΩÍ∞Ñ Î∞ùÍ≤å
                    contrast: 1.05,       // ÏïΩÍ∞Ñ ÎåÄÎπÑ Ï¶ùÍ∞Ä
                    saturation: 1.1,     // ÏïΩÍ∞Ñ Ï±ÑÎèÑ Ï¶ùÍ∞Ä
                    vignette: 0.2        // ÏïΩÌïú ÎπÑÎÑ§ÌåÖ Ìö®Í≥º
                };

                usePostProcessing = true;
                postProcessingEnabled = true;
                console.log('Post-processing system initialized with enhanced quality');
            } catch (error) {
                console.warn('Post-processing initialization failed:', error);
                usePostProcessing = false;
            }
        }

        // --- ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Ï†ÅÏö© Ìï®Ïàò ---
        function applyPostProcessing() {
            if (!usePostProcessing || !postProcessingEnabled) return;

            const effects = window.postProcessingEffects;
            if (!effects) return;

            // Ï†ÑÏ≤¥ Ïû•Î©¥Ïùò Î∞ùÍ∏∞ Ï°∞Ï†ï (Îçî Î∂ÄÎìúÎü¨Ïö¥ Ìö®Í≥º)
            scene.traverse((object) => {
                if (object.isMesh && object.material) {
                    // emissiveÎ•º ÏÇ¨Ïö©Ìïú Í∞ÑÏ†ëÏ†ÅÏù∏ Î∞ùÍ∏∞ Ï°∞Ï†ï
                    if (object.material.emissive && effects.brightness !== 1.0) {
                        const baseEmissive = object.userData.baseEmissive || new THREE.Color(0x000000);
                        if (!object.userData.baseEmissive) {
                            object.userData.baseEmissive = object.material.emissive.clone();
                        }
                        object.material.emissive.copy(baseEmissive).multiplyScalar(effects.brightness * 0.1);
                    }
                }
            });
        }

        // --- Map with Collision ---
        function createFactoryMap() {
            colliders = []; // Init array

            // ÌÖçÏä§Ï≤ò Ï†ÅÏö© (Ï†àÏ∞®Ï†Å ÏÉùÏÑ±Îêú ÌÖçÏä§Ï≤ò ÏÇ¨Ïö©)
            const matConcrete = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                map: window.concreteTexture || null // ÌÖçÏä§Ï≤ò Ï†ÅÏö© (ÏûàÎäî Í≤ΩÏö∞)
            });
            const matMetal = new THREE.MeshStandardMaterial({
                color: 0x556677,
                roughness: 0.4,
                metalness: 0.7,
                map: window.metalTexture || null // Î©îÌÉà ÌÖçÏä§Ï≤ò Ï†ÅÏö©
            });
            // Rust ÌÖçÏä§Ï≤ò ÏÉùÏÑ±
            const rustCanvas = document.createElement('canvas');
            rustCanvas.width = 256;
            rustCanvas.height = 256;
            const rustCtx = rustCanvas.getContext('2d');
            rustCtx.fillStyle = '#885544';
            rustCtx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 500; i++) {
                rustCtx.fillStyle = `rgba(${100 + Math.random() * 30}, ${60 + Math.random() * 20}, ${40 + Math.random() * 15}, 0.5)`;
                rustCtx.fillRect(Math.random() * 256, Math.random() * 256, 3, 3);
            }
            window.rustTexture = new THREE.CanvasTexture(rustCanvas);
            window.rustTexture.wrapS = THREE.RepeatWrapping;
            window.rustTexture.wrapT = THREE.RepeatWrapping;

            const matRust = new THREE.MeshStandardMaterial({
                color: 0x885544,
                roughness: 0.8,
                metalness: 0.2,
                map: window.rustTexture || null
            });
            const matWall = new THREE.MeshStandardMaterial({
                color: 0x20252a,
                roughness: 0.9,
                map: window.concreteTexture || null // Î≤ΩÏóêÎèÑ ÏΩòÌÅ¨Î¶¨Ìä∏ ÌÖçÏä§Ï≤ò Ï†ÅÏö©
            });

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), matConcrete);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            function addBoxCollider(mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                colliders.push(box);
            }

            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            for (let x = -20; x <= 20; x += 10) {
                for (let z = -20; z <= 20; z += 10) {
                    if (x === 0 && z === 0) continue;
                    const pillar = new THREE.Mesh(pillarGeo, matMetal);
                    pillar.position.set(x, 5, z);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    scene.add(pillar);
                    addBoxCollider(pillar);
                }
            }

            const beamGeo = new THREE.BoxGeometry(100, 0.5, 0.5);
            for (let z = -20; z <= 20; z += 5) {
                const beam = new THREE.Mesh(beamGeo, matMetal);
                beam.position.set(0, 9, z);
                scene.add(beam);
            }

            const wallGeo = new THREE.BoxGeometry(100, 20, 1);
            const createWall = (x, y, z, rotY) => {
                const w = new THREE.Mesh(wallGeo, matWall);
                w.position.set(x, y, z);
                if (rotY) w.rotation.y = rotY;
                scene.add(w);
                addBoxCollider(w);
            };
            createWall(0, 5, -25, 0);
            createWall(0, 5, 25, 0);
            createWall(-25, 5, 0, Math.PI / 2);
            createWall(25, 5, 0, Math.PI / 2);

            // Í∏∞Ï°¥ Î∞ïÏä§Îì§
            const boxGeo = new THREE.BoxGeometry(2, 2, 2);
            const boxPos = [{ x: -5, z: -5 }, { x: 5, z: 5 }, { x: -8, z: 8 }, { x: 8, z: -8 }, { x: -2, z: 12 }, { x: 12, z: -2 }];
            boxPos.forEach(p => {
                const box = new THREE.Mesh(boxGeo, matRust);
                box.position.set(p.x, 1, p.z);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                addBoxCollider(box);
            });

            // Ï†àÏ∞®Ï†Å Î™®Îç∏ Ï∂îÍ∞Ä (crate, barrel) - Í≤åÏûÑ ÌÄÑÎ¶¨Ìã∞ Ìñ•ÏÉÅ
            const cratePositions = [
                { x: -10, z: -10 }, { x: 10, z: 10 }, { x: -15, z: 5 },
                { x: 15, z: -5 }, { x: -3, z: 15 }, { x: 3, z: -15 }
            ];
            cratePositions.forEach(p => {
                const crate = createProceduralModel('crate', { size: 1.5, color: 0x8B4513 });
                crate.position.set(p.x, 0.75, p.z);
                crate.castShadow = true;
                crate.receiveShadow = true;
                scene.add(crate);
                addBoxCollider(crate);

                // Î¨ºÎ¶¨ Î∞îÎîî Ï∂îÍ∞Ä (ÏÑ†ÌÉùÏ†Å)
                if (usePhysics) {
                    createPhysicsBody(crate, 0, false); // Ï†ïÏ†Å Í∞ùÏ≤¥
                }
            });

            const barrelPositions = [
                { x: -12, z: 8 }, { x: 12, z: -8 }, { x: -7, z: -12 },
                { x: 7, z: 12 }, { x: 0, z: 18 }
            ];
            barrelPositions.forEach(p => {
                const barrel = createProceduralModel('barrel', { radius: 0.6, height: 1.2, color: 0x654321 });
                barrel.position.set(p.x, 0.6, p.z);
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                scene.add(barrel);

                // ÏõêÌÜµÌòï Ï∂©Îèå Î∞ïÏä§ (Í∞ÑÎã®Ìïú Î∞ïÏä§Î°ú Í∑ºÏÇ¨)
                const barrelCollider = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(p.x, 0.6, p.z),
                    new THREE.Vector3(1.2, 1.2, 1.2)
                );
                colliders.push(barrelCollider);

                // Î¨ºÎ¶¨ Î∞îÎîî Ï∂îÍ∞Ä
                if (usePhysics) {
                    createPhysicsBody(barrel, 0, false);
                }
            });
        }

        // --- Weapon Building ---
        function buildWeapon(idx) {
            while (weaponModel.children.length > 0) weaponModel.remove(weaponModel.children[0]);

            const wData = WEAPONS[idx];
            if (wData.type === 'RIFLE') buildRifle();
            else if (wData.type === 'PISTOL') buildPistol();
            else if (wData.type === 'KNIFE') buildKnife();
            else if (wData.type === 'SNIPER') buildSniper();

            if (wData.type !== 'KNIFE') {
                const fGeo = new THREE.PlaneGeometry(0.5, 0.5);
                const fMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, transparent: true, opacity: 0, side: THREE.DoubleSide });
                muzzleFlash = new THREE.Mesh(fGeo, fMat);
                muzzleFlash.visible = false;
                let zPos = -0.65;
                if (wData.type === 'PISTOL') zPos = -0.25;
                if (wData.type === 'SNIPER') zPos = -0.85;
                const yPos = (wData.type === 'PISTOL') ? 0.045 : 0.02;
                muzzleFlash.position.set(0, yPos, zPos);
                weaponModel.add(muzzleFlash);
            }
        }

        function buildRifle() {
            // Î¶¨ÏãúÎ≤Ñ (Î≥∏Ï≤¥)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.06, 0.3), matBody);
            weaponModel.add(receiver);

            // Î∞∞Îü¥ (Îçî ÏÉÅÏÑ∏ÌïòÍ≤å)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.4);
            weaponModel.add(barrel);

            // Î∞∞Îü¥ Í∞ÄÎìú (Barrel Guard) - Î∞∞Îü¥ Î≥¥Ìò∏ÎåÄ
            const barrelGuard = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.4, 16), matParts);
            barrelGuard.rotation.x = Math.PI / 2; barrelGuard.position.set(0, 0.015, -0.35);
            weaponModel.add(barrelGuard);

            // Í∞ÄÏä§ Î∏îÎ°ù (Gas Block)
            const gasBlock = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.025, 0.03), matSilver);
            gasBlock.position.set(0, 0.015, -0.2);
            weaponModel.add(gasBlock);

            // ÌÉÑÏ∞Ω (Magazine)
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.18, 0.06), matParts);
            mag.rotation.x = 0.25; mag.position.set(0, -0.1, 0.05);
            weaponModel.add(mag);

            // ÌÉÑÏ∞Ω ÌÅ¥Î¶Ω ÎîîÌÖåÏùº
            const magClip = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.07), matSilver);
            magClip.position.set(0, -0.18, 0.05);
            weaponModel.add(magClip);

            // Í∞úÎ®∏Î¶¨Ìåê (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.2), matParts);
            stock.position.set(0, -0.02, 0.25);
            weaponModel.add(stock);

            // Í∞úÎ®∏Î¶¨Ìåê Ìå®Îìú
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.042, 0.12, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.36);
            weaponModel.add(stockPad);

            // Ìï∏ÎìúÍ∞ÄÎìú (Handguard)
            const hg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.25), matParts);
            hg.position.set(0, 0.005, -0.28);
            weaponModel.add(hg);

            // Ìï∏ÎìúÍ∞ÄÎìú ÎùºÏùº (Rail) - ÏÉÅÎã®
            const railTop = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.01, 0.2), matSilver);
            railTop.position.set(0, 0.04, -0.28);
            weaponModel.add(railTop);

            // Ìä∏Î¶¨Í±∞ Í∞ÄÎìú (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // Ìä∏Î¶¨Í±∞ (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.02), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // Î≥ºÌä∏ Ìï∏Îì§ (Bolt Handle)
            const boltHandle = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.008, 0.03), matSilver);
            boltHandle.position.set(0.025, 0.03, 0.1);
            weaponModel.add(boltHandle);

            // Í∞ÄÎä†Ïûê (Rear Sight) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const rs = new THREE.Mesh(new THREE.TorusGeometry(0.012, 0.003, 8, 16), matParts);
            rs.position.set(0, 0.062, 0.14);
            weaponModel.add(rs);

            // Í∞ÄÎä†Ïá† (Front Sight) - Îπ®Í∞Ñ Ï†ê
            const fs = new THREE.Mesh(new THREE.BoxGeometry(0.0025, 0.0025, 0.0025), matSight);
            fs.position.set(0, 0.0621, -0.45);
            fs.userData.isSight = true;
            weaponModel.add(fs);

            // Í∞ÄÎä†Ïá† Í∏∞Îë•
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.015, 0.002), matParts);
            fsPost.position.set(0, 0.055, -0.45);
            weaponModel.add(fsPost);

            // Í∞ÄÎä†Ïá† Î≤†Ïù¥Ïä§
            const fsBase = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.003, 0.008), matParts);
            fsBase.position.set(0, 0.048, -0.45);
            weaponModel.add(fsBase);

            createArm(-0.1, -0.15, -0.2, 0.5, 0.5, -0.2, false);
            createArm(0.12, -0.15, 0.22, 0.2, -0.2, 0.4, true);
        }

        function buildSniper() {
            // Î¶¨ÏãúÎ≤Ñ (Î≥∏Ï≤¥)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.07, 0.4), matBody);
            weaponModel.add(receiver);

            // Î∞∞Îü¥ (Îçî ÏÉÅÏÑ∏ÌïòÍ≤å)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.8, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.6);
            weaponModel.add(barrel);

            // Î®∏Ï¶ê Î∏åÎ†àÏù¥ÌÅ¨ (Muzzle Brake) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const brake = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.08, 16), matSilver);
            brake.rotation.x = Math.PI / 2; brake.position.set(0, 0.015, -1.0);
            weaponModel.add(brake);

            // Î®∏Ï¶ê Î∏åÎ†àÏù¥ÌÅ¨ Íµ¨Î©çÎì§
            for (let i = 0; i < 3; i++) {
                const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.1, 8), matBody);
                hole.rotation.x = Math.PI / 2;
                hole.rotation.z = (i - 1) * 0.3;
                hole.position.set(0, 0.015 + (i - 1) * 0.01, -1.0);
                weaponModel.add(hole);
            }

            // Ïä§ÏΩîÌîÑ Î™∏Ï≤¥ (Scope Body)
            const scopeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.25, 16), matParts);
            scopeBody.rotation.x = Math.PI / 2; scopeBody.position.set(0, 0.075, 0);
            weaponModel.add(scopeBody);

            // Ïä§ÏΩîÌîÑ ÎßÅ (Scope Rings)
            const scopeRing1 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing1.rotation.x = Math.PI / 2; scopeRing1.position.set(0, 0.075, -0.1);
            weaponModel.add(scopeRing1);
            const scopeRing2 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing2.rotation.x = Math.PI / 2; scopeRing2.position.set(0, 0.075, 0.1);
            weaponModel.add(scopeRing2);

            // Ïä§ÏΩîÌîÑ Î†åÏ¶à (Ï†ÑÎ©¥)
            const lensF = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.01, 16), matParts);
            lensF.rotation.x = Math.PI / 2; lensF.position.set(0, 0.075, -0.13);
            weaponModel.add(lensF);

            // Ïä§ÏΩîÌîÑ Ïú†Î¶¨ (ÌõÑÎ©¥)
            const glass = new THREE.Mesh(new THREE.CircleGeometry(0.02, 16), matLens);
            glass.position.set(0, 0.075, 0.13);
            weaponModel.add(glass);

            // Ï°∞Ï†ï ÎÖ∏Î∏å (Adjustment Knobs)
            const knob1 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob1.rotation.x = Math.PI / 2; knob1.position.set(0.03, 0.075, 0);
            weaponModel.add(knob1);
            const knob2 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob2.rotation.x = Math.PI / 2; knob2.position.set(-0.03, 0.075, 0);
            weaponModel.add(knob2);

            // Î≥ºÌä∏ (Bolt)
            const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), matSilver);
            bolt.position.set(0.04, 0.02, 0.1);
            weaponModel.add(bolt);

            // Î≥ºÌä∏ Ìï∏Îì§
            const boltHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.03, 8), matSilver);
            boltHandle.rotation.x = Math.PI / 2; boltHandle.position.set(0.06, 0.02, 0.1);
            weaponModel.add(boltHandle);

            // Í∞úÎ®∏Î¶¨Ìåê (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.12, 0.25), matParts);
            stock.position.set(0, -0.02, 0.3);
            weaponModel.add(stock);

            // Í∞úÎ®∏Î¶¨Ìåê Ï≤¥ÌÅ¨ Î†àÏä§Ìä∏
            const cheekRest = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.04, 0.15), matParts);
            cheekRest.position.set(0, 0.05, 0.25);
            weaponModel.add(cheekRest);

            // Í∞úÎ®∏Î¶¨Ìåê Ìå®Îìú
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.14, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.42);
            weaponModel.add(stockPad);

            // Î∞îÏù¥Ìè¨Îìú (Bipod) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const bipodBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.15), matParts);
            bipodBase.position.set(0, -0.05, -0.4);
            weaponModel.add(bipodBase);

            // Î∞îÏù¥Ìè¨Îìú Îã§Î¶¨Îì§
            const bipodLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg1.position.set(-0.015, -0.13, -0.4);
            bipodLeg1.rotation.z = 0.3;
            weaponModel.add(bipodLeg1);
            const bipodLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg2.position.set(0.015, -0.13, -0.4);
            bipodLeg2.rotation.z = -0.3;
            weaponModel.add(bipodLeg2);

            // Ìä∏Î¶¨Í±∞ Í∞ÄÎìú
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // Ìä∏Î¶¨Í±∞
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.02), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            createArm(-0.1, -0.15, -0.2, 0.5, 0.5, -0.2, false);
            createArm(0.12, -0.15, 0.25, 0.2, -0.2, 0.4, true);
        }

        function buildPistol() {
            // Ïä¨ÎùºÏù¥Îìú (Slide) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const slide = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.04, 0.18), matSilver);
            slide.position.y = 0.02;
            weaponModel.add(slide);

            // Ïä¨ÎùºÏù¥Îìú ÏÑ∏Î¶¨Î†àÏù¥ÏÖò (Serrations)
            for (let i = 0; i < 8; i++) {
                const serration = new THREE.Mesh(new THREE.BoxGeometry(0.001, 0.01, 0.02), matBody);
                serration.position.set(0, 0.02, 0.05 - i * 0.015);
                weaponModel.add(serration);
            }

            // Î∞∞Îü¥
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.15, 12), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.02, -0.08);
            weaponModel.add(barrel);

            // ÌîÑÎ†àÏûÑ (Frame)
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.08, 0.12), matBody);
            frame.position.set(0, -0.02, 0.03);
            weaponModel.add(frame);

            // Í∑∏Î¶Ω (Grip) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.1, 0.05), matParts);
            grip.position.set(0, -0.04, 0.05); grip.rotation.x = 0.1;
            weaponModel.add(grip);

            // Í∑∏Î¶Ω ÌÖçÏä§Ï≤ò (Ìå®ÌÑ¥)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    const gripDot = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, 0.01, 8), matParts);
                    gripDot.rotation.x = Math.PI / 2;
                    gripDot.position.set((j - 0.5) * 0.015, -0.04 + i * 0.03, 0.05);
                    weaponModel.add(gripDot);
                }
            }

            // Ìï¥Î®∏ (Hammer)
            const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.01), matSilver);
            hammer.position.set(0, 0.01, 0.1);
            hammer.rotation.x = 0.3;
            weaponModel.add(hammer);

            // Ìä∏Î¶¨Í±∞ Í∞ÄÎìú (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // Ìä∏Î¶¨Í±∞ (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.012, 0.015), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // Í∞ÄÎä†Ïûê (Rear Sight) - „Ñ∑Ïûê ÌòïÌÉú
            const rsBase = new THREE.Mesh(new THREE.BoxGeometry(0.022, 0.003, 0.008), matParts);
            rsBase.position.set(0, 0.048, 0.08);
            weaponModel.add(rsBase);
            // ÏôºÏ™Ω Í∏∞Îë•
            const rsL = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsL.position.set(-0.01, 0.048, 0.08);
            weaponModel.add(rsL);
            // Ïò§Î•∏Ï™Ω Í∏∞Îë•
            const rsR = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsR.position.set(0.01, 0.048, 0.08);
            weaponModel.add(rsR);

            // Í∞ÄÎä†Ïá† (Front Sight) - Îπ®Í∞Ñ Ï†ê
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.012, 0.003), matParts);
            fsPost.position.set(0, 0.045, -0.09);
            weaponModel.add(fsPost);
            const fsDot = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.003, 0.001), matSight);
            fsDot.position.set(0, 0.0482, -0.09);
            fsDot.userData.isSight = true;
            weaponModel.add(fsDot);

            // ÌÉÑÏ∞Ω (Magazine)
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.08, 0.04), matParts);
            magazine.position.set(0, -0.08, 0.05);
            weaponModel.add(magazine);

            // ÌÉÑÏ∞Ω Î∞îÎã• ÌîåÎ†àÏù¥Ìä∏
            const magPlate = new THREE.Mesh(new THREE.BoxGeometry(0.027, 0.01, 0.042), matSilver);
            magPlate.position.set(0, -0.12, 0.05);
            weaponModel.add(magPlate);

            const lArm = createArm(-0.05, -0.15, 0.1, 0.1, 0.8, -0.1, false);
            lArm.rotation.y = -0.1;
            const rArm = createArm(0.05, -0.15, 0.1, 0.1, -0.8, 0.1, true);
            rArm.rotation.y = 0.1;
        }

        function buildKnife() {
            const knifeGroup = new THREE.Group();

            // === Ìï∏Îì§ (Í∑∏Î¶Ω) - Îçî ÌòÑÏã§Ï†ÅÏù¥Í≥† ÏÑ∏Î∞ÄÌïòÍ≤å ===
            const handleLength = 0.13;
            const handleWidth = 0.032;
            const handleHeight = 0.045;

            // Ìï∏Îì§ Î©îÏù∏ Î∞îÎîî (ÌÉÄÏõêÌòïÏóê Í∞ÄÍπùÍ≤å)
            const handleGeo = new THREE.BoxGeometry(handleWidth, handleHeight, handleLength);
            const handle = new THREE.Mesh(handleGeo, matHandle);
            handle.position.set(0, -0.02, handleLength / 2 - 0.01);
            knifeGroup.add(handle);

            // Ìï∏Îì§ Í∑∏Î¶Ω ÌÖçÏä§Ï≤ò (Îçî ÎßéÏùÄ ÎîîÌÖåÏùº, 6Í∞úÎ°ú Ï¶ùÍ∞Ä)
            for (let i = 0; i < 6; i++) {
                const grip = new THREE.Mesh(
                    new THREE.BoxGeometry(handleWidth + 0.003, handleHeight * 0.6, 0.015),
                    matHandle
                );
                grip.position.set(0, -0.01, 0.005 + i * 0.02);
                knifeGroup.add(grip);
            }

            // Ìï∏Îì§ Î¶¨Î≤≥ (3Í∞úÎ°ú Ï¶ùÍ∞Ä, Îçî ÌòÑÏã§Ï†ÅÏúºÎ°ú)
            for (let i = 0; i < 3; i++) {
                const rivet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.004, 0.004, 0.012, 12),
                    matSilver
                );
                rivet.rotation.x = Math.PI / 2;
                rivet.position.set((i - 1) * 0.012, -0.02, 0.02 + i * 0.03);
                knifeGroup.add(rivet);
            }

            // Ìï∏Îì§ ÎÅù Î∂ÄÎ∂Ñ (Pommel) - Îçî ÏÑ∏Î∞ÄÌïòÍ≤å
            const pommel = new THREE.Mesh(
                new THREE.CylinderGeometry(handleWidth * 0.8, handleWidth * 0.6, 0.015, 12),
                matSilver
            );
            pommel.rotation.x = Math.PI / 2;
            pommel.position.set(0, -0.02, handleLength - 0.005);
            knifeGroup.add(pommel);

            // === Í∞ÄÎìú (ÏÜêÎ≥¥Ìò∏ÎåÄ) - Îçî ÌòÑÏã§Ï†ÅÏúºÎ°ú ===
            const guardWidth = 0.04;
            const guard = new THREE.Mesh(
                new THREE.BoxGeometry(guardWidth, 0.012, 0.025),
                matSilver
            );
            guard.position.set(0, 0.005, 0);
            knifeGroup.add(guard);

            // Í∞ÄÎìú ÎÅùÎ∂ÄÎ∂Ñ (ÏñëÏ™ΩÏúºÎ°ú ÌôïÏû•)
            for (let side = -1; side <= 1; side += 2) {
                const guardTip = new THREE.Mesh(
                    new THREE.BoxGeometry(0.012, 0.012, 0.008),
                    matSilver
                );
                guardTip.position.set(side * (guardWidth / 2 + 0.006), 0.005, 0.012);
                knifeGroup.add(guardTip);
            }

            // === ÏπºÎÇ† Î≥∏Ï≤¥ - Îçî ÌòÑÏã§Ï†ÅÏù¥Í≥† ÎÇ†Ïπ¥Î°≠Í≤å ===
            const bladeLength = 0.22; // Îçî Í∏∏Í≤å
            const bladeWidth = 0.018; // Îçî ÎÑìÍ≤å
            const bladeThickness = 0.004; // Îçî ÎëêÍªçÍ≤å

            // ÏπºÎÇ† Î©îÏù∏ Î∞îÎîî (ÌÖåÏù¥ÌçºÎßÅÎêú ÌòïÌÉú)
            const bladeBody = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness, bladeWidth, bladeLength),
                matBlade
            );
            bladeBody.position.set(0, 0.025, -bladeLength / 2);
            knifeGroup.add(bladeBody);

            // ÏπºÎÇ† Îì± (Spine) - Îçî Î∂ÄÎìúÎüΩÍ≥† ÌòÑÏã§Ï†ÅÏúºÎ°ú
            const bladeSpine = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.6, bladeWidth * 0.25, bladeLength * 0.85),
                matBlade
            );
            bladeSpine.position.set(-bladeThickness * 0.2, 0.03, -bladeLength * 0.35);
            knifeGroup.add(bladeSpine);

            // ÏπºÎÇ† ÎÅù (Tip) - Îçî ÎÇ†Ïπ¥Î°≠Í≥† Îæ∞Ï°±ÌïòÍ≤å
            const bladeTip = new THREE.Mesh(
                new THREE.ConeGeometry(bladeWidth * 0.4, bladeLength * 0.25, 8),
                matBlade
            );
            bladeTip.rotation.x = Math.PI / 2;
            bladeTip.position.set(0, 0.025, -bladeLength);
            knifeGroup.add(bladeTip);

            // ÏπºÎÇ† ÎÇ† (Cutting Edge) - Îçî ÎÇ†Ïπ¥Î°≠Í≤å
            const bladeEdge = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.15, bladeWidth * 0.2, bladeLength * 0.98),
                matBlade
            );
            bladeEdge.position.set(bladeThickness * 0.125, 0.015, -bladeLength * 0.49);
            knifeGroup.add(bladeEdge);

            // ÏπºÎÇ† Ìôà (Fuller/Blood Groove) - Îçî ÍπäÍ≥† Î™ÖÌôïÌïòÍ≤å
            const fuller = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.4, bladeWidth * 0.25, bladeLength * 0.65),
                matBlade
            );
            fuller.position.set(0, 0.025, -bladeLength * 0.45);
            fuller.material = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.3,
                metalness: 0.7
            });
            knifeGroup.add(fuller);

            // ÏπºÎÇ† Î≤†Ïù¥Ïä§ (Ricasso) - ÏπºÎÇ†Í≥º Ìï∏Îì§ ÏÇ¨Ïù¥ Î∂ÄÎ∂Ñ
            const ricasso = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.9, bladeWidth * 0.9, bladeLength * 0.18),
                matBlade
            );
            ricasso.position.set(0, 0.025, -bladeLength * 0.09);
            knifeGroup.add(ricasso);

            // ÏπºÎÇ† Ï∏°Î©¥ Î≤†Î≤® (Bevel) - Îçî ÌòÑÏã§Ï†ÅÏù∏ ÎÇ† ÌëúÌòÑ
            for (let side = -1; side <= 1; side += 2) {
                const bevel = new THREE.Mesh(
                    new THREE.BoxGeometry(bladeThickness * 0.3, bladeWidth * 0.15, bladeLength * 0.9),
                    matBlade
                );
                bevel.position.set(side * bladeThickness * 0.35, 0.02, -bladeLength * 0.45);
                knifeGroup.add(bevel);
            }

            // === ÎÇòÏù¥ÌîÑ Í∞ÅÎèÑ Ï°∞Ï†ï - Îçî ÏûêÏó∞Ïä§ÎüΩÍ≤å ===
            knifeGroup.rotation.y = Math.PI * 0.25; // Ïò§Î•∏Ï™ΩÏúºÎ°ú ÌöåÏ†Ñ
            knifeGroup.rotation.z = -0.15; // ÏÜêÎ™© Í∞ÅÎèÑ
            knifeGroup.rotation.x = 0.25; // ÏúÑÎ°ú Í∏∞Ïö∏ÏûÑ

            // ÎÇòÏù¥ÌîÑ ÌÅ¨Í∏∞ Ï°∞Ï†ï - Îçî ÌÅ¨Í≥† Î™ÖÌôïÌïòÍ≤å
            knifeGroup.scale.set(2.0, 2.0, 2.0);

            const knifeHolder = new THREE.Group();
            knifeHolder.add(knifeGroup);
            // ÎÇòÏù¥ÌîÑ ÏúÑÏπò Ï°∞Ï†ï - Îçî Ïûò Î≥¥Ïù¥ÎèÑÎ°ù
            knifeHolder.position.set(0.3, -0.2, -0.35);
            weaponModel.add(knifeHolder);

            // === ÏÜê Î™®Îç∏ - ÎÇòÏù¥ÌîÑÎ•º Îçî ÏûêÏó∞Ïä§ÎüΩÍ≤å Ï•êÎèÑÎ°ù ===
            // Ïò§Î•∏ÏÜê (ÎÇòÏù¥ÌîÑÎ•º Ï•êÎäî ÏÜê) - ÏúÑÏπòÏôÄ Í∞ÅÎèÑ Í∞úÏÑ†
            const rightArm = createArm(0.35, -0.2, -0.35, 0.08, -0.15, 0.2, false);
            rightArm.userData.isKnifeHand = true;

            // ÏôºÏÜê - Îëê ÏÜêÏùÑ ÌÅ¨Í≤å Î≤åÎ¶∞ Î™®Ïäµ
            const leftArm = createArm(-0.4, -0.18, -0.25, 0.15, 0.4, -0.1, false);
            leftArm.userData.isLeftHand = true;
        }

        function createArm(x, y, z, rotX, rotY, rotZ, isTrigger) {
            const grp = new THREE.Group();
            const sleeve = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.06, 0.5, 12), matSleeve);
            sleeve.rotation.x = Math.PI / 2; sleeve.position.z = 0.25;
            grp.add(sleeve);
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.08), matGlove);
            hand.position.z = -0.05;
            grp.add(hand);

            if (isTrigger) {
                const finger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.015, 0.05), matSkin);
                finger.position.set(0.01, 0.01, -0.1);
                grp.add(finger);
            } else {
                // ÎÇòÏù¥ÌîÑÎ•º Ï•êÎäî ÏÜêÏù∏ Í≤ΩÏö∞ ÏÜêÍ∞ÄÎùΩÏùÑ Îçî Î™ÖÌôïÌïòÍ≤å
                if (grp.userData && grp.userData.isKnifeHand) {
                    // ÏÜê Î≥∏Ï≤¥ - ÎÇòÏù¥ÌîÑ ÏÜêÏû°Ïù¥Î•º Í∞êÏã∏Îäî ÌòïÌÉú
                    const handSize = 0.14;
                    const handMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(handSize, 0.07, handSize * 0.8),
                        matGlove
                    );
                    handMesh.position.z = -0.04;
                    grp.add(handMesh);

                    // ÎÇòÏù¥ÌîÑÎ•º Ï•êÎäî ÏÜêÍ∞ÄÎùΩÎì§ - Îçî ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏúÑÏπòÏôÄ Í∞ÅÎèÑ
                    for (let i = 0; i < 4; i++) {
                        const finger = new THREE.Mesh(
                            new THREE.BoxGeometry(0.02, 0.02, 0.07),
                            matSkin
                        );
                        // ÏÜêÍ∞ÄÎùΩÏù¥ ÎÇòÏù¥ÌîÑ ÏÜêÏû°Ïù¥Î•º Í∞êÏã∏Îäî ÌòïÌÉúÎ°ú Î∞∞Ïπò
                        finger.position.set((i - 1.5) * 0.022, 0.025, -0.13);
                        finger.rotation.x = 0.1; // ÏïΩÍ∞Ñ Íµ¨Î∂ÄÎ¶∞ ÌòïÌÉú
                        grp.add(finger);
                    }
                    // ÏóÑÏßÄ - ÎÇòÏù¥ÌîÑ Î∞òÎåÄÌé∏Ïóê ÏúÑÏπò
                    const thumb = new THREE.Mesh(
                        new THREE.BoxGeometry(0.018, 0.018, 0.06),
                        matSkin
                    );
                    thumb.position.set(0.06, 0.025, -0.1);
                    thumb.rotation.z = 0.4; // Îçî Íµ¨Î∂ÄÎ¶∞ ÌòïÌÉú
                    thumb.rotation.x = 0.2;
                    grp.add(thumb);
                } else if (grp.userData && grp.userData.isLeftHand) {
                    // ÏôºÏÜê (ÎÇòÏù¥ÌîÑÎ•º Ï•êÏßÄ ÏïäÏßÄÎßå Î≥¥ÏûÑ)
                    const handSize = 0.1;
                    const handMesh = new THREE.Mesh(new THREE.BoxGeometry(handSize, 0.05, handSize), matGlove);
                    handMesh.position.z = -0.05;
                    grp.add(handMesh);

                    // ÏôºÏÜê ÏÜêÍ∞ÄÎùΩÎì§
                    for (let i = 0; i < 4; i++) {
                        const finger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.015, 0.05), matSkin);
                        finger.position.set((i - 1.5) * 0.018, 0.015, -0.1);
                        grp.add(finger);
                    }
                    // ÏôºÏÜê ÏóÑÏßÄ
                    const thumb = new THREE.Mesh(new THREE.BoxGeometry(0.012, 0.012, 0.04), matSkin);
                    thumb.position.set(0.04, 0.015, -0.08);
                    thumb.rotation.z = -0.3;
                    grp.add(thumb);
                } else {
                    const fist = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.04), matGlove);
                    fist.position.set(0, -0.02, -0.08);
                    grp.add(fist);
                }
            }

            grp.position.set(x, y, z);
            grp.rotation.set(rotX, rotY, rotZ);
            weaponModel.add(grp);
            return grp;
        }

        // --- Enemy AI & Parts ---
        function createEnemyAI() {
            const enemy = new THREE.Group();

            // FIX: Clone Materials to prevent shared color change
            const mClothes = matZombieClothes.clone();
            const mSkin = matZombieSkin.clone();

            // Î™∏ÌÜµ (Body) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.25), mClothes);
            body.position.y = 1.1; body.name = 'body'; enemy.add(body);

            // Í∞ÄÏä¥ Î∂ÄÎ∂Ñ ÎîîÌÖåÏùº
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.3, 0.22), mClothes);
            chest.position.set(0, 1.25, 0.01);
            enemy.add(chest);

            // Ïñ¥Íπ® (Shoulders)
            const lShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mClothes);
            lShoulder.position.set(-0.25, 1.4, 0);
            enemy.add(lShoulder);
            const rShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mClothes);
            rShoulder.position.set(0.25, 1.4, 0);
            enemy.add(rShoulder);

            // Î®∏Î¶¨ (Head) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), mSkin);
            head.position.y = 1.6; head.name = 'head'; enemy.add(head);

            // Î®∏Î¶¨ ÌòïÌÉú Í∞úÏÑ† (ÏïΩÍ∞Ñ Íµ¨ÌòïÏúºÎ°ú)
            const headShape = new THREE.Mesh(new THREE.SphereGeometry(0.13, 8, 8), mSkin);
            headShape.position.set(0, 1.6, 0);
            enemy.add(headShape);

            // Îàà (Eyes) - Îπ®Í∞ÑÏÉâÏúºÎ°ú
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const lEye = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), eyeMat);
            lEye.position.set(-0.05, 1.62, 0.12);
            enemy.add(lEye);
            const rEye = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), eyeMat);
            rEye.position.set(0.05, 1.62, 0.12);
            enemy.add(rEye);

            // Î™© (Neck)
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.15, 8), mSkin);
            neck.rotation.z = Math.PI / 2;
            neck.position.set(0, 1.45, 0);
            enemy.add(neck);

            // Ïò§Î•∏Ìåî (Right Arm) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const rUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8), mClothes);
            rUpperArm.rotation.z = Math.PI / 2;
            rUpperArm.position.set(0.3, 1.3, 0.2);
            rUpperArm.rotation.x = -1.2;
            rUpperArm.name = 'limb';
            enemy.add(rUpperArm);

            const rForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.25, 8), mClothes);
            rForearm.rotation.z = Math.PI / 2;
            rForearm.position.set(0.35, 1.15, 0.4);
            rForearm.rotation.x = -1.8;
            rForearm.name = 'limb';
            enemy.add(rForearm);
            enemy.userData.rArm = rForearm;

            // ÏôºÌåî (Left Arm) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const lUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8), mClothes);
            lUpperArm.rotation.z = Math.PI / 2;
            lUpperArm.position.set(-0.3, 1.3, 0.2);
            lUpperArm.rotation.x = -1.2;
            lUpperArm.name = 'limb';
            enemy.add(lUpperArm);

            const lForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.25, 8), mClothes);
            lForearm.rotation.z = Math.PI / 2;
            lForearm.position.set(-0.35, 1.15, 0.4);
            lForearm.rotation.x = -1.8;
            lForearm.name = 'limb';
            enemy.add(lForearm);
            enemy.userData.lArm = lForearm;

            // ÏÜê (Hands)
            const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.08), mSkin);
            rHand.position.set(0.4, 1.05, 0.5);
            enemy.add(rHand);
            const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.08), mSkin);
            lHand.position.set(-0.4, 1.05, 0.5);
            enemy.add(lHand);

            // ÏôºÎã§Î¶¨ (Left Leg) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const lThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.4, 8), mClothes);
            lThigh.position.set(-0.15, 0.55, 0);
            lThigh.name = 'limb';
            enemy.add(lThigh);

            const lShin = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8), mClothes);
            lShin.position.set(-0.15, 0.175, 0);
            lShin.name = 'limb';
            enemy.add(lShin);

            // Ïò§Î•∏Îã§Î¶¨ (Right Leg) - Îçî ÏÉÅÏÑ∏ÌïòÍ≤å
            const rThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.4, 8), mClothes);
            rThigh.position.set(0.15, 0.55, 0);
            rThigh.name = 'limb';
            enemy.add(rThigh);

            const rShin = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8), mClothes);
            rShin.position.set(0.15, 0.175, 0);
            rShin.name = 'limb';
            enemy.add(rShin);

            // Î∞ú (Feet)
            const lFoot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.2), mClothes);
            lFoot.position.set(-0.15, 0, 0.1);
            enemy.add(lFoot);
            const rFoot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.2), mClothes);
            rFoot.position.set(0.15, 0, 0.1);
            enemy.add(rFoot);

            // HP Bar (Billboard)
            const hpGroup = new THREE.Group();
            const bgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpBg);
            const fgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpFg);
            fgBar.position.z = 0.01;
            hpGroup.add(bgBar);
            const fgWrapper = new THREE.Group();
            fgWrapper.add(fgBar);
            fgBar.position.x = 0.3; fgWrapper.position.x = -0.3; fgWrapper.position.z = 0.01;
            hpGroup.add(fgWrapper);
            hpGroup.position.set(0, 2.0, 0);
            enemy.add(hpGroup);
            enemy.userData.hpGroup = hpGroup;
            enemy.userData.hpBar = fgWrapper;

            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 20;
            enemy.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);

            // Generate safe spawn - Îçî ÎßéÏùÄ ÏãúÎèÑÏôÄ Îçî Ï†ïÌôïÌïú Ï≤¥ÌÅ¨
            let safe = false;
            for (let i = 0; i < 50; i++) {
                // Check if inside collider - Îçî Ï†ïÌôïÌïú ÌÅ¨Í∏∞Î°ú Ï≤¥ÌÅ¨
                const testBox = new THREE.Box3(
                    new THREE.Vector3(enemy.position.x - ENEMY_RADIUS, enemy.position.y, enemy.position.z - ENEMY_RADIUS),
                    new THREE.Vector3(enemy.position.x + ENEMY_RADIUS, enemy.position.y + 1.8, enemy.position.z + ENEMY_RADIUS)
                );
                let hits = false;
                for (let c of colliders) {
                    if (testBox.intersectsBox(c)) {
                        hits = true;
                        break;
                    }
                }
                if (!hits) {
                    safe = true;
                    break;
                }

                // Retry pos - Îçî ÎÑìÏùÄ Î≤îÏúÑÏóêÏÑú ÏãúÎèÑ
                const ang = Math.random() * Math.PI * 2;
                const d = 15 + Math.random() * 35;
                enemy.position.set(Math.cos(ang) * d, 0, Math.sin(ang) * d);
            }

            // ÏïàÏ†ÑÌïú ÏúÑÏπòÎ•º Ï∞æÏßÄ Î™ªÌï¥ÎèÑ ÏµúÏ¢Ö ÏúÑÏπòÏóêÏÑú Ïä§Ìè∞ ÏãúÎèÑ (Í≤åÏûÑ ÏßÑÌñâÏùÑ ÏúÑÌï¥)
            if (!safe) {
                // ÏµúÌõÑÏùò ÏàòÎã®: ÏõêÏ†êÏóêÏÑú Îçî Î®º Í±∞Î¶¨ÏóêÏÑú ÏãúÎèÑ
                const finalAngle = Math.random() * Math.PI * 2;
                const finalDist = 25 + Math.random() * 20;
                enemy.position.set(Math.cos(finalAngle) * finalDist, 0, Math.sin(finalAngle) * finalDist);
                // Í∑∏ÎûòÎèÑ Ïïà ÎêòÎ©¥ Í∑∏ÎÉ• Ïä§Ìè∞ (Í≤åÏûÑ ÏßÑÌñâÏùÑ ÏúÑÌï¥)
            }

            enemy.userData.hp = 100;
            enemy.userData.maxHp = 100;
            enemy.userData.attackTimer = 0;
            enemy.userData.isDead = false;
            enemy.userData.moveSpeed = ZOMBIE_SPEED + Math.random();
            enemy.userData.animState = 0;
            enemy.userData.flashTimer = 0;
            enemy.userData.stuckTimer = 0; // ÎÅºÏñ¥ÏûàÎäî ÏãúÍ∞Ñ Ï∂îÏ†Å
            enemy.userData.lastValidPos = enemy.position.clone(); // ÎßàÏßÄÎßâ Ïú†Ìö®Ìïú ÏúÑÏπò

            scene.add(enemy);
            enemies.push(enemy);
        }

        function updateEnemies(dt) {
            if (isDead) return;

            // Spawn - ÌÉÄÏù¥Î®∏Îäî Ìï≠ÏÉÅ Ï¶ùÍ∞Ä, Ï†Å ÏÉùÏÑ±Îßå ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê Îïå
            // Î¶¨Ï†† Ïàò Ï†úÌïú ÏóÜÏùå - Í≤åÏûÑÏù¥ ÎÅùÎÇ† ÎïåÍπåÏßÄ Í≥ÑÏÜç Ïä§Ìè∞
            if (!isPaused) {
                spawnTimer += dt;
                if (spawnTimer >= SPAWN_INTERVAL) {
                    spawnTimer = 0; // ÌÉÄÏù¥Î®∏ Î¶¨ÏÖã (ÏÉùÏÑ± Ïó¨Î∂ÄÏôÄ Î¨¥Í¥Ä)
                    createEnemyAI();
                }
            }

            if (isPaused) return; // ÏùºÏãúÏ†ïÏßÄÎäî Ï†Å Ïù¥Îèô/Í≥µÍ≤©Îßå Ï§ëÏßÄ

            enemies.forEach(e => {
                if (e.userData.isDead) return;

                // Color Flash Update
                if (e.userData.flashTimer > 0) {
                    e.userData.flashTimer -= dt;
                    if (e.userData.flashTimer <= 0) {
                        e.children.forEach(c => {
                            if (c.isMesh && c.material && c.material.emissive) c.material.emissive.setHex(0x000000);
                        });
                    }
                }

                e.lookAt(position.x, e.position.y, position.z);
                e.userData.hpGroup.lookAt(camera.position);

                const dist = e.position.distanceTo(position);

                // --- Simple Enemy Collision vs Walls ---
                // Calculate desired move
                let nextPos = e.position.clone();
                if (dist > ATTACK_RANGE && e.userData.animState <= 0) {
                    const dir = new THREE.Vector3().subVectors(position, e.position).normalize();
                    const moveStep = dir.multiplyScalar(e.userData.moveSpeed * dt);

                    // ÌòÑÏû¨ ÏúÑÏπòÍ∞Ä Î≤ΩÏóê ÎÅºÏñ¥ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
                    const currentBox = new THREE.Box3(
                        new THREE.Vector3(e.position.x - ENEMY_RADIUS * 1.2, e.position.y, e.position.z - ENEMY_RADIUS * 1.2),
                        new THREE.Vector3(e.position.x + ENEMY_RADIUS * 1.2, e.position.y + 1.8, e.position.z + ENEMY_RADIUS * 1.2)
                    );
                    let isStuck = false;
                    for (const c of colliders) {
                        if (currentBox.intersectsBox(c)) {
                            isStuck = true;
                            break;
                        }
                    }

                    // Î≤ΩÏóê ÎÅºÏñ¥ÏûàÏúºÎ©¥ Î≤ΩÏóêÏÑú Î≤óÏñ¥ÎÇòÎèÑÎ°ù Ïù¥Îèô
                    if (isStuck) {
                        e.userData.stuckTimer += dt;

                        // 2Ï¥à Ïù¥ÏÉÅ ÎÅºÏñ¥ÏûàÏúºÎ©¥ Í∞ïÏ†ú Ïû¨Î∞∞Ïπò
                        if (e.userData.stuckTimer > 2.0) {
                            // ÏïàÏ†ÑÌïú ÏúÑÏπòÎ°ú Ïû¨Î∞∞Ïπò
                            let newPos = null;
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 20 + Math.random() * 25;
                                const testPos = new THREE.Vector3(
                                    Math.cos(angle) * dist,
                                    0,
                                    Math.sin(angle) * dist
                                );
                                const testBox = new THREE.Box3(
                                    new THREE.Vector3(testPos.x - ENEMY_RADIUS * 1.5, testPos.y, testPos.z - ENEMY_RADIUS * 1.5),
                                    new THREE.Vector3(testPos.x + ENEMY_RADIUS * 1.5, testPos.y + 1.8, testPos.z + ENEMY_RADIUS * 1.5)
                                );
                                let canSpawn = true;
                                for (const c of colliders) {
                                    if (testBox.intersectsBox(c)) {
                                        canSpawn = false;
                                        break;
                                    }
                                }
                                if (canSpawn) {
                                    newPos = testPos;
                                    break;
                                }
                            }
                            if (newPos) {
                                e.position.copy(newPos);
                                e.userData.stuckTimer = 0;
                                e.userData.lastValidPos = newPos.clone();
                            }
                        } else {
                            // Î≤ΩÏóêÏÑú Î≤óÏñ¥ÎÇòÍ∏∞ ÏúÑÌï¥ Îçî ÎßéÏùÄ Î∞©Ìñ•Í≥º Îçî Îπ†Î•∏ ÏÜçÎèÑÎ°ú ÏãúÎèÑ
                            const escapeDirs = [
                                new THREE.Vector3(1, 0, 0),
                                new THREE.Vector3(-1, 0, 0),
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3(0, 0, -1),
                                new THREE.Vector3(1, 0, 1).normalize(),
                                new THREE.Vector3(-1, 0, 1).normalize(),
                                new THREE.Vector3(1, 0, -1).normalize(),
                                new THREE.Vector3(-1, 0, -1).normalize(),
                                new THREE.Vector3(0.707, 0, 0.707),
                                new THREE.Vector3(-0.707, 0, 0.707),
                                new THREE.Vector3(0.707, 0, -0.707),
                                new THREE.Vector3(-0.707, 0, -0.707)
                            ];

                            let escaped = false;
                            for (const escapeDir of escapeDirs) {
                                // Îçî Îπ†Î•∏ ÌÉàÏ∂ú ÏÜçÎèÑ
                                const escapeStep = escapeDir.multiplyScalar(e.userData.moveSpeed * dt * 5);
                                const escapePos = e.position.clone().add(escapeStep);
                                const escapeBox = new THREE.Box3(
                                    new THREE.Vector3(escapePos.x - ENEMY_RADIUS * 1.2, escapePos.y, escapePos.z - ENEMY_RADIUS * 1.2),
                                    new THREE.Vector3(escapePos.x + ENEMY_RADIUS * 1.2, escapePos.y + 1.8, escapePos.z + ENEMY_RADIUS * 1.2)
                                );
                                let canEscape = true;
                                for (const c of colliders) {
                                    if (escapeBox.intersectsBox(c)) {
                                        canEscape = false;
                                        break;
                                    }
                                }
                                if (canEscape) {
                                    e.position.copy(escapePos);
                                    e.userData.lastValidPos = escapePos.clone();
                                    escaped = true;
                                    break;
                                }
                            }

                            // Î≤ΩÏóêÏÑú Î≤óÏñ¥ÎÇòÏßÄ Î™ªÌïòÎ©¥ ÎßàÏßÄÎßâ Ïú†Ìö®Ìïú ÏúÑÏπòÎ°ú Î≥µÍ∑Ä
                            if (!escaped) {
                                const distToLast = e.position.distanceTo(e.userData.lastValidPos);
                                if (distToLast > 0.5) {
                                    e.position.lerp(e.userData.lastValidPos, 0.3);
                                } else {
                                    // YÏ∂ïÏúºÎ°úÎèÑ ÏãúÎèÑ
                                    e.position.y += 0.2;
                                }
                            } else {
                                e.userData.stuckTimer = 0; // ÌÉàÏ∂ú ÏÑ±Í≥µ
                            }
                        }
                    } else {
                        // Ï†ïÏÉÅ Ïù¥Îèô Ï§ëÏù¥Î©¥ ÎßàÏßÄÎßâ Ïú†Ìö® ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ Î∞è ÎÅºÏûÑ ÌÉÄÏù¥Î®∏ Î¶¨ÏÖã
                        e.userData.lastValidPos = e.position.clone();
                        e.userData.stuckTimer = 0;
                        // Ï†ïÏÉÅ Ïù¥Îèô
                        let testPos = e.position.clone();
                        testPos.x += moveStep.x;
                        const eBoxX = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colX = false;
                        for (const c of colliders) { if (eBoxX.intersectsBox(c)) { colX = true; break; } }
                        if (!colX) e.position.x += moveStep.x;

                        testPos = e.position.clone();
                        testPos.z += moveStep.z;
                        const eBoxZ = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colZ = false;
                        for (const c of colliders) { if (eBoxZ.intersectsBox(c)) { colZ = true; break; } }
                        if (!colZ) e.position.z += moveStep.z;
                    }

                    e.position.y = Math.abs(Math.sin(lastTime * 0.005)) * 0.1;
                }
                else if (dist <= ATTACK_RANGE) {
                    e.userData.attackTimer += dt;
                    if (e.userData.attackTimer > 1.0) {
                        e.userData.attackTimer = 0;
                        e.userData.animState = 0.5;
                        SoundGen.playZombieAttack();
                        damagePlayer(ZOMBIE_DMG);
                    }
                }

                if (e.userData.animState > 0) {
                    e.userData.animState -= dt;
                    const progress = 1 - (e.userData.animState / 0.5);
                    e.userData.rArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.userData.lArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.position.add(e.getWorldDirection(new THREE.Vector3()).multiplyScalar(Math.sin(progress * Math.PI) * 0.05));
                } else {
                    e.children.forEach(c => {
                        if (c.name === 'limb' && c.position.y > 1.0) c.rotation.x = -1.6;
                    });
                }
            });
        }

        function damagePlayer(amount) {
            if (isDead) return;
            playerHP -= amount;

            elHpBar.style.width = Math.max(0, playerHP) + '%';
            elHpText.innerText = "HP: " + Math.max(0, playerHP);

            if (playerHP > 50) elHpBar.style.background = "#4caf50";
            else if (playerHP > 20) elHpBar.style.background = "#ff9800";
            else elHpBar.style.background = "#f44336";

            elDamage.style.opacity = 0.8;
            setTimeout(() => elDamage.style.opacity = 0, 100);

            if (playerHP <= 0) {
                isDead = true;
                elGameOver.style.display = 'flex';
                if (!isMobile && document.pointerLockElement === document.body) {
                    document.exitPointerLock();
                }
            }
        }

        function updatePlayersList() {
            const playersListEl = document.getElementById('players-list');
            playersListEl.innerHTML = '';
            playersList.forEach(player => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.textContent = player.name;
                playersListEl.appendChild(playerItem);
            });
            playersListEl.innerHTML += `<div style="margin-top: 10px; color: rgba(255,255,255,0.7);">Ï∞∏Ïó¨ Ïù∏Ïõê: ${currentPlayers} / ${maxPlayers}</div>`;
        }

        function simulatePlayerJoin() {
            // Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
        }

        function startCountdown() {
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 5;
            countdownEl.textContent = count;

            countdownTimer = setInterval(() => {
                count--;
                countdownEl.textContent = count;
                if (count <= 0) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    countdownEl.style.display = 'none';
                    document.getElementById('room-waiting').style.display = 'none';
                    startGame();
                }
            }, 1000);
        }

        function startGame() {
            // Í≤åÏûÑ ÏãúÏûë ÏãúÍ∞Ñ ÏÑ§Ï†ï
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
            if (elKillCount) elKillCount.innerText = "Kills: 0";

            // ÌòºÏûêÌïòÍ∏∞ Î™®ÎìúÏùº ÎïåÎßå Ï†Å ÏÉùÏÑ±
            if (gameMode === 'single') {
                for (let i = 0; i < 6; i++) createEnemyAI();
            }

            setupControls();
            setupSensitivityControl();
            animate();
        }

        function restartGame() {
            playerHP = 100;
            isDead = false;
            isPaused = false;
            spawnTimer = 0;
            elPauseOverlay.style.display = 'none';
            elHpBar.style.width = '100%';
            elHpText.innerText = "HP: 100";
            elGameOver.style.display = 'none';
            position.set(0, 1.7, 5);

            // Í≤åÏûÑ ÌÜµÍ≥Ñ Î¶¨ÏÖã
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
            if (elKillCount) elKillCount.innerText = "Kills: 0";

            enemies.forEach(e => scene.remove(e));
            enemies = [];
            healthPills.forEach(pill => scene.remove(pill));
            healthPills = [];
            for (let i = 0; i < 6; i++) createEnemyAI();

            // Ïû¨ÏãúÏûë ÌõÑÏóêÎäî Ìè¨Ïù∏ÌÑ∞ Ïû†Í∏àÏùÑ ÏöîÏ≤≠ÌïòÏßÄ ÏïäÏùå (ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÅ¥Î¶≠Ìï¥Ïïº Ìï®)
            if (!isMobile && document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
        }

        // Î™®Î∞îÏùº ÌÑ∞Ïπò Ïª®Ìä∏Î°§ Î≥ÄÏàò
        // Îçî ÌôïÏã§Ìïú Î™®Î∞îÏùº Í∞êÏßÄ: User Agent + ÌÑ∞Ïπò ÏßÄÏõê + ÌôîÎ©¥ ÌÅ¨Í∏∞
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
            ('ontouchstart' in window) ||
            (navigator.maxTouchPoints > 0) ||
            (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        let touchMoveActive = false;
        let touchLookActive = false;
        let touchMoveId = null;
        let touchLookId = null;
        let lastTouchX = 0, lastTouchY = 0;
        let touchStartX = 0, touchStartY = 0;
        let isAimingHeld = false;

        function setupControls() {
            // Î™®Î∞îÏùº ÌÑ∞Ïπò Ïª®Ìä∏Î°§ ÏÑ§Ï†ï - Îã§Ïãú ÌïúÎ≤à ÌôïÏù∏
            const isMobileDevice = isMobile ||
                ('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

            if (isMobileDevice) {
                setupMobileControls();
                console.log('Mobile controls enabled');
                // Î™®Î∞îÏùºÏóêÏÑúÎäî Ìè¨Ïù∏ÌÑ∞ ÎùΩ ÏÇ¨Ïö© Ïïà Ìï®
            } else {
                console.log('Desktop controls enabled');
                // Îç∞Ïä§ÌÅ¨ÌÜ±ÏóêÏÑúÎßå Ìè¨Ïù∏ÌÑ∞ ÎùΩ ÏÇ¨Ïö©
                // Ìè¨Ïù∏ÌÑ∞ Ïû†Í∏à Î≥ÄÍ≤Ω Í∞êÏßÄ
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement !== document.body && isPaused) {
                        // Ìè¨Ïù∏ÌÑ∞ Ïû†Í∏àÏù¥ Ìï¥Ï†úÎêòÍ≥† ÏùºÏãúÏ†ïÏßÄ ÏÉÅÌÉúÎ©¥ Ïò§Î≤ÑÎ†àÏù¥ Ïú†ÏßÄ
                        elPauseOverlay.style.display = 'flex';
                    }
                });

                document.body.addEventListener('mousedown', (e) => {
                    if (document.pointerLockElement !== document.body && !isDead && !isPaused) {
                        const promise = document.body.requestPointerLock();
                        if (promise) promise.catch(err => { });
                        return;
                    }
                    if (isDead || isPaused) return;
                    if (e.button === 0) isFiring = true;
                    if (e.button === 2) isAiming = true;
                });

                document.body.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { isFiring = false; hasFiredSemi = false; hasClickedEmpty = false; }
                    if (e.button === 2) isAiming = false;
                });
                document.body.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body && !isDead && !isPaused) {
                        const sens = isAiming ? SENSITIVITY_ADS : SENSITIVITY_MOUSE;
                        rotation.y -= e.movementX * sens;
                        rotation.x -= e.movementY * sens;
                        rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                        const ray = new THREE.Raycaster();
                        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const targets = scene.children.filter(c => c !== weaponContainer);
                        const hits = ray.intersectObjects(targets, true);

                        let enemyFound = false;
                        for (let h of hits) {
                            let p = h.object;
                            while (p) {
                                if (p.userData && p.userData.hp !== undefined) {
                                    enemyFound = true;
                                    break;
                                }
                                if (p.parent === scene) break;
                                p = p.parent;
                            }
                            if (enemyFound) break;
                        }

                        if (enemyFound) elCrosshair.classList.add('enemy-detected');
                        else elCrosshair.classList.remove('enemy-detected');
                    }
                });
            }

            window.addEventListener('keydown', e => {
                // ESC ÌÇ§ Ï≤òÎ¶¨ - keyÏôÄ code Î™®Îëê Ï≤¥ÌÅ¨
                if (e.key === 'Escape' || e.key === 'Esc' || e.code === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (!isPaused && !isDead) {
                        isPaused = true;
                        elPauseOverlay.style.display = 'flex';
                        if (document.pointerLockElement === document.body) {
                            document.exitPointerLock();
                        }
                    } else if (isPaused) {
                        isPaused = false;
                        elPauseOverlay.style.display = 'none';
                        // Ïû¨Í∞ú Ïãú Ìè¨Ïù∏ÌÑ∞ Ïû†Í∏àÏùÄ ÏÇ¨Ïö©ÏûêÍ∞Ä ÌÅ¥Î¶≠Ìï¥Ïïº Ìï®
                    }
                    return false;
                }
                const k = e.key.toLowerCase();
                if (isDead || isPaused) return;
                if (k === 'w') keys.w = 1;
                if (k === 's') keys.s = 1;
                if (k === 'a') keys.a = 1;
                if (k === 'd') keys.d = 1;
                if (k === 'shift') keys.shift = true;
                if (k === 'control') keys.ctrl = true;
                if (k === ' ') {
                    if (!keys.space && isGrounded) {
                        velocityY = 8.0;
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }
                if (k === '1') switchWeaponTo(0);
                if (k === '2') switchWeaponTo(1);
                if (k === '3') switchWeaponTo(2);
                if (k === '4') switchWeaponTo(3);
                if (k === 'tab') { e.preventDefault(); switchWeaponTo((curWeaponIdx + 1) % 4); }
                if (k === 'r') doReload();
            });

            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if (k === 'w') keys.w = 0;
                if (k === 's') keys.s = 0;
                if (k === 'a') keys.a = 0;
                if (k === 'd') keys.d = 0;
                if (k === 'shift') keys.shift = false;
                if (k === 'control') keys.ctrl = false;
                if (k === ' ') keys.space = false;
            });
        }

        // Î™®Î∞îÏùº ÌÑ∞Ïπò Ïª®Ìä∏Î°§ ÏÑ§Ï†ï
        function setupMobileControls() {
            console.log('Setting up mobile controls');

            const screenWidth = window.innerWidth;
            const leftHalf = screenWidth / 2;

            // ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ - document.bodyÏóê ÏßÅÏ†ë Îì±Î°ù
            document.body.addEventListener('touchstart', (e) => {
                // Î≤ÑÌäº ÏòÅÏó≠ Ï≤¥ÌÅ¨ (Î≤ÑÌäº ÌÅ¥Î¶≠ÏùÄ Î¨¥Ïãú)
                const target = e.target;
                if (target.closest('.mobile-btn') || target.closest('#light-toggle-btn')) {
                    return; // Î≤ÑÌäº ÌÅ¥Î¶≠ÏùÄ Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
                }

                // Î™®Îì† ÌÑ∞Ïπò Ï≤òÎ¶¨
                Array.from(e.touches).forEach(touch => {
                    const isLeftSide = touch.clientX < leftHalf;
                    const btnAim = document.getElementById('btn-aim');
                    const btnRect = btnAim ? btnAim.getBoundingClientRect() : null;
                    const isOnAimButton = btnRect && touch.clientX >= btnRect.left && touch.clientX <= btnRect.right &&
                        touch.clientY >= btnRect.top && touch.clientY <= btnRect.bottom;

                    if (isLeftSide && touchMoveId === null && !isOnAimButton) {
                        // ÏôºÏ™Ω ÌôîÎ©¥ - Ïù¥Îèô Ï†úÏñ¥ (Ï°∞Ï§Ä Î≤ÑÌäº Ï†úÏô∏)
                        touchMoveId = touch.identifier;
                        touchMoveActive = true;
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                    } else if (!isLeftSide && touchLookId === null && !isOnAimButton) {
                        // Ïò§Î•∏Ï™Ω ÌôîÎ©¥ - ÏãúÏ†ê Ï†úÏñ¥ (Ï°∞Ï§Ä Î≤ÑÌäº Ï†úÏô∏)
                        touchLookId = touch.identifier;
                        touchLookActive = true;
                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                    }
                });
            }, { passive: false });

            document.body.addEventListener('touchmove', (e) => {
                // Î≤ÑÌäº ÏòÅÏó≠ Ï≤¥ÌÅ¨
                const target = e.target;
                if (target.closest('.mobile-btn') || target.closest('#light-toggle-btn')) {
                    return;
                }

                e.preventDefault();

                const currentScreenWidth = window.innerWidth;
                const currentLeftHalf = currentScreenWidth / 2;

                // ÏôºÏ™Ω ÌÑ∞Ïπò - Ïïû/Îí§/Ï¢å/Ïö∞ Ïù¥Îèô (ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô Í∞ÄÎä•) ÎòêÎäî Ï°∞Ï§Ä Î™®Îìú ÏãúÏ†ê Î≥ÄÍ≤Ω
                const w = WEAPONS[curWeaponIdx];
                const isSniperAiming = w.type === 'SNIPER' && isAimingHeld;

                if (touchMoveActive && touchMoveId !== null) {
                    const touch = Array.from(e.touches).find(t => t.identifier === touchMoveId);
                    if (touch && touch.clientX < currentLeftHalf) {
                        // Ï†ÄÍ≤© Ï°∞Ï§Ä Î™®ÎìúÏóêÏÑúÎäî ÏôºÏ™Ω ÌÑ∞ÏπòÍ∞Ä Î∞úÏÇ¨ Î≤ÑÌäº Ïó≠Ìï†
                        if (isSniperAiming) {
                            // Î∞úÏÇ¨ Ï≤òÎ¶¨ (ÌÑ∞Ïπò Ïãú Ìïú Î≤àÎßå)
                            if (!isFiring) {
                                isFiring = true;
                                hasFiredSemi = false;
                            }
                        } else if (isAimingHeld) {
                            // Ï°∞Ï§Ä Î™®ÎìúÏùº ÎïåÎäî ÏôºÏ™Ω ÌÑ∞ÏπòÎ°ú ÏãúÏ†ê Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå (Ïù¥ÎèôÎèÑ Ïïà Ìï®)
                            // Ï°∞Ï§Ä Î™®ÎìúÎäî Ïò§Î•∏Ï™Ω ÌÑ∞ÏπòÎ°úÎßå ÏãúÏ†ê Î≥ÄÍ≤Ω
                            keys.w = 0;
                            keys.s = 0;
                            keys.a = 0;
                            keys.d = 0;
                        } else {
                            // ÏùºÎ∞ò Ïù¥Îèô Î™®Îìú
                            const dx = touch.clientX - touchStartX;
                            const dy = touch.clientY - touchStartY;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            // ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô Í∞ÄÎä•
                            if (distance > 5) {
                                const moveX = Math.max(-1, Math.min(1, dx / 60));
                                const moveY = Math.max(-1, Math.min(1, -dy / 60)); // ÏúÑÎ°ú ÎìúÎûòÍ∑∏ = ÏñëÏàò

                                keys.w = Math.max(0, moveY);
                                keys.s = Math.max(0, -moveY);
                                keys.a = Math.max(0, -moveX);
                                keys.d = Math.max(0, moveX);
                            } else {
                                keys.w = 0;
                                keys.s = 0;
                                keys.a = 0;
                                keys.d = 0;
                            }
                        }
                    }
                }

                // Ïò§Î•∏Ï™Ω ÌÑ∞Ïπò - ÏãúÏ†ê Î≥ÄÍ≤Ω (Ï°∞Ï§Ä Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í≥† ÏûàÏñ¥ÎèÑ Í∞ÄÎä•)
                if (touchLookActive && touchLookId !== null) {
                    const touch = Array.from(e.touches).find(t => t.identifier === touchLookId);
                    if (touch && touch.clientX >= currentLeftHalf) {
                        const moveDx = touch.clientX - lastTouchX;
                        const moveDy = touch.clientY - lastTouchY;
                        // Ïù¥Îèô Ï§ëÏùº Îïå ÏãúÏ†ê Î≥ÄÍ≤Ω ÏÜçÎèÑ Ï¶ùÍ∞Ä
                        const moveSpeedMultiplier = (touchMoveActive && keys.w > 0 || keys.s > 0 || keys.a > 0 || keys.d > 0) ? 1.5 : 1.0;
                        const sens = (isAiming ? SENSITIVITY_ADS * 1.5 : SENSITIVITY_MOUSE * 1.2) * moveSpeedMultiplier;

                        rotation.y -= moveDx * sens;
                        rotation.x -= moveDy * sens;
                        rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                    }
                }

                // Ï°∞Ï§Ä Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í≥† ÏûàÎäî ÏÉÅÌÉúÏóêÏÑúÎèÑ Ïò§Î•∏Ï™Ω ÌôîÎ©¥ ÌÑ∞ÏπòÎ°ú ÏãúÏ†ê Î≥ÄÍ≤Ω Í∞ÄÎä•
                if (isAimingHeld) {
                    // Ï°∞Ï§Ä Î≤ÑÌäºÏù¥ ÏïÑÎãå Ïò§Î•∏Ï™Ω ÌôîÎ©¥Ïùò Îã§Î•∏ ÌÑ∞Ïπò Ï∞æÍ∏∞
                    const btnAim = document.getElementById('btn-aim');
                    const btnRect = btnAim ? btnAim.getBoundingClientRect() : null;
                    const rightSideTouch = Array.from(e.touches).find(t => {
                        if (!btnRect) return false;
                        const isOnButton = t.clientX >= btnRect.left && t.clientX <= btnRect.right &&
                            t.clientY >= btnRect.top && t.clientY <= btnRect.bottom;
                        return !isOnButton && t.clientX >= currentLeftHalf && t.identifier !== touchMoveId;
                    });

                    if (rightSideTouch) {
                        // Ï°∞Ï§Ä Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Í≥† ÏûàÎäî ÏÉÅÌÉúÏóêÏÑú Ïò§Î•∏Ï™Ω ÌôîÎ©¥ ÌÑ∞ÏπòÎ°ú ÏãúÏ†ê Î≥ÄÍ≤Ω
                        if (touchLookId === null || touchLookId !== rightSideTouch.identifier) {
                            touchLookId = rightSideTouch.identifier;
                            touchLookActive = true;
                            lastTouchX = rightSideTouch.clientX;
                            lastTouchY = rightSideTouch.clientY;
                        }
                    }

                    // touchLookIdÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏãúÏ†ê Î≥ÄÍ≤Ω Ï≤òÎ¶¨
                    if (touchLookActive && touchLookId !== null) {
                        const lookTouch = Array.from(e.touches).find(t => t.identifier === touchLookId);
                        if (lookTouch && lookTouch.clientX >= currentLeftHalf) {
                            const moveDx = lookTouch.clientX - lastTouchX;
                            const moveDy = lookTouch.clientY - lastTouchY;
                            const sens = SENSITIVITY_ADS * 1.5; // Ï°∞Ï§Ä Î™®Îìú Í∞êÎèÑ (Î™®Î∞îÏùº)

                            rotation.y -= moveDx * sens;
                            rotation.x -= moveDy * sens;
                            rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                            lastTouchX = lookTouch.clientX;
                            lastTouchY = lookTouch.clientY;
                        }
                    }
                }
            }, { passive: false });

            document.body.addEventListener('touchend', (e) => {
                const endedTouches = Array.from(e.changedTouches);

                // Ïù¥Îèô Ï†úÏñ¥ Ï¢ÖÎ£å
                const moveTouch = endedTouches.find(t => t.identifier === touchMoveId);
                if (moveTouch) {
                    touchMoveActive = false;
                    touchMoveId = null;
                    keys.w = 0;
                    keys.s = 0;
                    keys.a = 0;
                    keys.d = 0;
                    // Ï†ÄÍ≤© Ï°∞Ï§Ä Î™®ÎìúÏóêÏÑú ÏôºÏ™Ω ÌÑ∞Ïπò Ï¢ÖÎ£å Ïãú Î∞úÏÇ¨ Ï§ëÏßÄ
                    const w = WEAPONS[curWeaponIdx];
                    if (w.type === 'SNIPER' && isAimingHeld) {
                        isFiring = false;
                    }
                }

                // ÏãúÏ†ê Ï†úÏñ¥ Ï¢ÖÎ£å
                const lookTouch = endedTouches.find(t => t.identifier === touchLookId);
                if (lookTouch) {
                    touchLookActive = false;
                    touchLookId = null;
                }
            }, { passive: false });

            document.body.addEventListener('touchcancel', (e) => {
                // ÌÑ∞ÏπòÍ∞Ä Ï∑®ÏÜåÎêòÎ©¥ Î™®Îì† ÌÇ§ Î¶¨ÏÖã
                touchMoveActive = false;
                touchLookActive = false;
                touchMoveId = null;
                touchLookId = null;
                keys.w = 0;
                keys.s = 0;
                keys.a = 0;
                keys.d = 0;
            }, { passive: false });

            // Î™®Î∞îÏùº Î≤ÑÌäº Ïù¥Î≤§Ìä∏
            const btnJump = document.getElementById('btn-jump');
            const btnReload = document.getElementById('btn-reload');
            const btnWeapon1 = document.getElementById('btn-weapon1');
            const btnWeapon2 = document.getElementById('btn-weapon2');
            const btnWeapon3 = document.getElementById('btn-weapon3');
            const btnWeapon4 = document.getElementById('btn-weapon4');
            const btnAim = document.getElementById('btn-aim');

            if (btnJump) {
                btnJump.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!keys.space && isGrounded) {
                        velocityY = 8.0;
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }, { passive: false });
                btnJump.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    keys.space = false;
                }, { passive: false });
            }

            if (btnReload) {
                btnReload.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    doReload();
                }, { passive: false });
            }

            if (btnWeapon1) {
                btnWeapon1.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    switchWeaponTo(0);
                }, { passive: false });
            }
            if (btnWeapon2) {
                btnWeapon2.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    switchWeaponTo(1);
                }, { passive: false });
            }
            if (btnWeapon3) {
                btnWeapon3.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    switchWeaponTo(2);
                }, { passive: false });
            }
            if (btnWeapon4) {
                btnWeapon4.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    switchWeaponTo(3);
                }, { passive: false });
            }

            // Ï°∞Ï§Ä Î≤ÑÌäº - Ï†ÄÍ≤© Î™®ÎìúÎäî Ï°∞Ï§ÄÎßå, ÏÜåÏ¥ùÏùÄ Ï°∞Ï§Ä+Î∞úÏÇ¨, Í∂åÏ¥ùÏùÄ Î∞úÏÇ¨Îßå
            if (btnAim) {
                btnAim.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // Í∂åÏ¥ùÏùÄ Ï°∞Ï§Ä Î™®ÎìúÍ∞Ä Ïù¥ÎØ∏ ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏúºÎØÄÎ°ú Î∞úÏÇ¨Îßå
                        isFiring = true;
                    } else {
                        // ÏÜåÏ¥ù, Ï†ÄÍ≤©Ï¥ùÏùÄ Ï°∞Ï§Ä Î™®Îìú ÌôúÏÑ±Ìôî
                        isAimingHeld = true;
                        isAiming = true;
                        if (w.type !== 'SNIPER') {
                            isFiring = true; // ÏÜåÏ¥ùÏùÄ ÏûêÎèô Î∞úÏÇ¨ ÏãúÏûë
                        } else {
                            isFiring = false; // Ï†ÄÍ≤© Î™®ÎìúÎäî ÏôºÏ™Ω ÌÑ∞ÏπòÎ°ú Î∞úÏÇ¨
                        }
                    }
                }, { passive: false });

                btnAim.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // Í∂åÏ¥ùÏùÄ Î∞úÏÇ¨Îßå Ï§ëÏßÄ
                        isFiring = false;
                        hasFiredSemi = false;
                    } else {
                        // ÏÜåÏ¥ù, Ï†ÄÍ≤©Ï¥ùÏùÄ Ï°∞Ï§Ä Î™®ÎìúÎèÑ Ìï¥Ï†ú
                        isAimingHeld = false;
                        isAiming = false;
                        isFiring = false;
                        hasFiredSemi = false;
                    }
                }, { passive: false });
            }
        }

        // PC Í∞êÎèÑ Ï°∞Ï†ï ÏÑ§Ï†ï
        function setupSensitivityControl() {
            if (isMobile) return; // Î™®Î∞îÏùºÏóêÏÑúÎäî ÌëúÏãú Ïïà Ìï®

            const sensitivityControl = document.getElementById('sensitivity-control');
            const sensitivitySlider = document.getElementById('sensitivity-slider');
            const sensitivityValue = document.getElementById('sensitivity-value');

            if (!sensitivityControl || !sensitivitySlider || !sensitivityValue) return;

            // PCÏóêÏÑúÎßå ÌëúÏãú
            sensitivityControl.style.display = 'block';

            // ÌòÑÏû¨ Í∞êÎèÑÎ°ú Ïä¨ÎùºÏù¥Îçî ÏÑ§Ï†ï
            sensitivitySlider.value = SENSITIVITY_MOUSE;
            updateSensitivityDisplay();

            // Ïä¨ÎùºÏù¥Îçî Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏
            sensitivitySlider.addEventListener('input', (e) => {
                const newSensitivity = parseFloat(e.target.value);
                SENSITIVITY_MOUSE = newSensitivity;
                SENSITIVITY_ADS = newSensitivity * 0.25; // ADSÎäî ÏùºÎ∞ò Í∞êÎèÑÏùò 25%

                // localStorageÏóê Ï†ÄÏû•
                localStorage.setItem('mouseSensitivity', newSensitivity.toString());

                updateSensitivityDisplay();
            });

            function updateSensitivityDisplay() {
                // 0.002Î•º Í∏∞Ï§Ä(1.0)ÏúºÎ°ú ÌëúÏãú
                const displayValue = (SENSITIVITY_MOUSE / 0.002).toFixed(2);
                sensitivityValue.textContent = displayValue;
            }
        }

        function switchWeaponTo(idx) {
            if (curWeaponIdx === idx) return;
            isReloading = false;
            const w = WEAPONS[idx];
            // Î™®Î∞îÏùºÏóêÏÑú Í∂åÏ¥ùÏúºÎ°ú Î≥ÄÍ≤Ω Ïãú ÏûêÎèôÏúºÎ°ú Ï°∞Ï§Ä Î™®Îìú ÌôúÏÑ±Ìôî
            if (isMobile && w.type === 'PISTOL') {
                isAiming = true;
            } else {
                isAiming = false;
            }
            curWeaponIdx = idx;
            buildWeapon(curWeaponIdx);
            // Î¨¥Í∏∞ Ï†ÑÌôò Ïãú Ï¥àÍ∏∞ ÏúÑÏπò ÏÑ§Ï†ï (ÎÇòÏù¥ÌîÑÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞Îßå)
            if (w.type !== 'KNIFE') {
                weaponModel.position.y = -0.5;
                weaponModel.position.x = 0;
                weaponModel.position.z = 0;
                weaponModel.rotation.x = 0;
                weaponModel.rotation.y = 0;
                weaponModel.rotation.z = 0;
            } else {
                // ÎÇòÏù¥ÌîÑÎäî Í∏∞Î≥∏ ÏúÑÏπò ÏÑ§Ï†ï (Í∞úÏÑ†Îêú ÏúÑÏπò)
                weaponModel.position.x = 0.3;
                weaponModel.position.y = -0.2;
                weaponModel.position.z = -0.35;
                weaponModel.rotation.x = 0.25;
                weaponModel.rotation.y = 0;
                weaponModel.rotation.z = -0.15;
            }

            // Î¨¥Í∏∞Î≥Ñ ÍµêÏ≤¥ ÏÜåÎ¶¨ Ï†ÅÏö©
            if (w.type === 'KNIFE' && SoundGen.audioBuffers['c-sword']) {
                // ÎÇòÏù¥ÌîÑÎ°ú Ï†ÑÌôò
                SoundGen.playAudioFile('c-sword', 0.8);
            } else if (w.type === 'RIFLE' && SoundGen.audioBuffers['c-sochong']) {
                // ÏÜåÏ¥ùÏúºÎ°ú Ï†ÑÌôò (1Î≤à)
                SoundGen.playAudioFile('c-sochong', 0.8);
            } else if (w.type === 'PISTOL' && SoundGen.audioBuffers['c-gun']) {
                // Í∂åÏ¥ùÏúºÎ°ú Ï†ÑÌôò (2Î≤à)
                SoundGen.playAudioFile('c-gun', 0.8);
            } else if (w.type === 'SNIPER' && SoundGen.audioBuffers['c-rifle']) {
                // Ï†ÄÍ≤©Ï¥ùÏúºÎ°ú Ï†ÑÌôò (3Î≤à)
                SoundGen.playAudioFile('c-rifle', 0.8);
            } else {
                // Í∏∞Ï°¥ ÏÜåÎ¶¨ (Ìè¥Î∞±)
                SoundGen.playSwitch();
            }
            updateUI();
        }

        function updateUI() {
            const w = WEAPONS[curWeaponIdx];
            elWeaponLabel.innerText = w.name;
            elAmmoVal.classList.remove('no-ammo');
            if (w.type === 'KNIFE') elAmmoVal.innerText = "-";
            else elAmmoVal.innerText = w.ammo + " / " + w.maxAmmo * 4;
        }

        function doReload() {
            const w = WEAPONS[curWeaponIdx];
            if (w.type === 'KNIFE') return;
            isReloading = true;

            // Ï†ÄÍ≤©Ï¥ùÏùÄ c-rifle.mp3 ÏÇ¨Ïö©, Îã§Î•∏ Î¨¥Í∏∞Îäî Í∏∞Ï°¥ Ïû¨Ïû•Ï†Ñ ÏÜåÎ¶¨
            if (w.type === 'SNIPER' && SoundGen.audioBuffers['c-rifle']) {
                SoundGen.playAudioFile('c-rifle', 0.8);
            } else {
                SoundGen.playReload();
            }

            elWeaponLabel.innerText = "RELOADING...";
            weaponModel.rotation.z = 0.5;
            weaponModel.position.y = -0.1;
            setTimeout(() => {
                w.ammo = w.maxAmmo;
                isReloading = false;
                weaponModel.rotation.z = 0;
                weaponModel.position.y = 0;
                updateUI();
            }, 1000);
        }

        function createDecal(pos, normal) {
            if (!normal) return;
            const size = 0.1 + Math.random() * 0.05;
            const geo = new THREE.PlaneGeometry(size, size);
            const decal = new THREE.Mesh(geo, matDecal);
            decal.position.copy(pos);
            decal.lookAt(pos.clone().add(normal));
            decal.position.add(normal.multiplyScalar(0.01));
            scene.add(decal);
            decals.push(decal);
            if (decals.length > 50) {
                const old = decals.shift();
                scene.remove(old);
            }
        }

        function spawnShell() {
            const shell = new THREE.Mesh(shellGeo, shellMat);
            const weaponPos = new THREE.Vector3();
            weaponModel.getWorldPosition(weaponPos);
            const weaponQuat = new THREE.Quaternion();
            weaponModel.getWorldQuaternion(weaponQuat);

            shell.position.copy(weaponPos);
            shell.quaternion.copy(weaponQuat);

            shell.translateX(0.05);
            shell.translateY(0.08);
            shell.translateZ(-0.02);

            const force = 3.0 + Math.random();
            const vel = new THREE.Vector3(1.0, 0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
            vel.normalize().multiplyScalar(force);
            vel.applyQuaternion(shell.quaternion);

            scene.add(shell);

            shells.push({
                mesh: shell,
                velocity: vel,
                rotVel: new THREE.Vector3(Math.random(), Math.random(), Math.random()).multiplyScalar(10),
                life: 2.0
            });
        }

        function updateShells(dt) {
            for (let i = shells.length - 1; i >= 0; i--) {
                const s = shells[i];
                s.life -= dt;

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    shells.splice(i, 1);
                    continue;
                }

                s.velocity.y -= 9.8 * dt;
                s.mesh.position.addScaledVector(s.velocity, dt);

                s.mesh.rotation.x += s.rotVel.x * dt;
                s.mesh.rotation.y += s.rotVel.y * dt;
                s.mesh.rotation.z += s.rotVel.z * dt;

                if (s.mesh.position.y < 0.01) {
                    s.mesh.position.y = 0.01;
                    s.velocity.y *= -0.5;
                    s.velocity.x *= 0.7;
                    s.velocity.z *= 0.7;
                }
            }
        }

        // --- Blood Particle System ---
        function createBlood(pos) {
            const particleCount = 8;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 2);
                velocities.push(vel);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xaa0000, size: 0.05 }));
            scene.add(particles);

            bloodParticles.push({ mesh: particles, velocities: velocities, life: 0.5 });
        }

        function updateParticles(dt) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const bp = bloodParticles[i];
                bp.life -= dt;
                if (bp.life <= 0) {
                    scene.remove(bp.mesh);
                    bloodParticles.splice(i, 1);
                    continue;
                }

                const positions = bp.mesh.geometry.attributes.position.array;
                for (let j = 0; j < bp.velocities.length; j++) {
                    positions[j * 3] += bp.velocities[j].x * dt;
                    positions[j * 3 + 1] += bp.velocities[j].y * dt;
                    positions[j * 3 + 2] += bp.velocities[j].z * dt;
                }
                bp.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createHealthPill(pos) {
            const pillGroup = new THREE.Group();
            // ÏïåÏïΩ ÌÅ¨Í∏∞ ÌôïÎåÄ
            const pillBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.15, 8), matHealthPill);
            pillBody.rotation.x = Math.PI / 2;
            pillGroup.add(pillBody);

            // ÎπõÎÇòÎäî Ìö®Í≥ºÎ•º ÏúÑÌïú PointLight Ï∂îÍ∞Ä
            const pillLight = new THREE.PointLight(0xff00ff, 1.5, 2);
            pillLight.position.set(0, 0, 0);
            pillGroup.add(pillLight);

            pillGroup.position.copy(pos);
            pillGroup.position.y = 0.8;
            pillGroup.userData.isHealthPill = true;
            pillGroup.userData.pillLight = pillLight;
            pillGroup.userData.baseY = 0.8; // ÏõêÎûò Y ÏúÑÏπò Ï†ÄÏû•
            pillGroup.userData.floatTime = 0; // Î∂ÄÎèô Ïï†ÎãàÎ©îÏù¥ÏÖòÏö© ÏãúÍ∞Ñ
            pillGroup.userData.lifeTime = 0; // ÏïåÏïΩ ÏàòÎ™Ö (30Ï¥à ÌõÑ ÏÇ≠Ï†ú)
            scene.add(pillGroup);
            healthPills.push(pillGroup);
        }

        function updateHealthPills(dt) {
            for (let i = healthPills.length - 1; i >= 0; i--) {
                const pill = healthPills[i];

                // ÏàòÎ™Ö Ï¶ùÍ∞Ä
                pill.userData.lifeTime += dt;

                // 30Ï¥à ÏßÄÎÇòÎ©¥ ÏÇ≠Ï†ú
                if (pill.userData.lifeTime >= 30.0) {
                    scene.remove(pill);
                    healthPills.splice(i, 1);
                    continue;
                }

                // ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò
                pill.rotation.y += dt * 2;

                // Î∂ÄÎèô Ïï†ÎãàÎ©îÏù¥ÏÖò (ÏõêÎûò ÏúÑÏπò Í∏∞Ï§ÄÏúºÎ°ú Î∂ÄÏú†)
                pill.userData.floatTime += dt;
                pill.position.y = pill.userData.baseY + Math.sin(pill.userData.floatTime * 3) * 0.1;

                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄÏùò Í±∞Î¶¨ Ï≤¥ÌÅ¨ (3D Í±∞Î¶¨)
                const dist = pill.position.distanceTo(position);
                if (dist < 1.2) {
                    // HP ÌöåÎ≥µ
                    const oldHP = playerHP;
                    playerHP = Math.min(100, playerHP + 20);

                    if (playerHP !== oldHP) { // Ïã§Ï†úÎ°ú ÌöåÎ≥µÎêú Í≤ΩÏö∞ÏóêÎßå
                        elHpBar.style.width = playerHP + '%';
                        elHpText.innerText = "HP: " + playerHP;
                        if (playerHP > 50) elHpBar.style.background = "#4caf50";
                        else if (playerHP > 20) elHpBar.style.background = "#ff9800";
                        else elHpBar.style.background = "#f44336";

                        // Ìö®Í≥ºÏùå Ïû¨ÏÉù
                        SoundGen.playHealthPill();
                    }

                    scene.remove(pill);
                    healthPills.splice(i, 1);
                }
            }
        }

        let fireTimer = 0;
        function handleShooting(dt) {
            if (isDead) return;
            const w = WEAPONS[curWeaponIdx];

            if (fireCooldown > 0) fireCooldown -= dt;

            if (knifeSwing > 0) {
                knifeSwing -= dt * 4.5; // ÏïΩÍ∞Ñ ÎäêÎ¶¨Í≤å (Îçî ÏûêÏó∞Ïä§ÎüΩÍ≤å)
                const swingProgress = knifeSwing; // 1.0 -> 0.0
                const swingPhase = 1.0 - swingProgress; // 0.0 -> 1.0

                // Î∂ÄÎìúÎü¨Ïö¥ Í∞ÄÏÜç/Í∞êÏÜç Í≥°ÏÑ† (ease-in-out)
                const swingEase = 0.5 - 0.5 * Math.cos(swingPhase * Math.PI); // 0.0 -> 1.0 (Î∂ÄÎìúÎü¨Ïö¥ SÏûê Í≥°ÏÑ†)
                const swingEaseOut = Math.sin(swingPhase * Math.PI); // 0.0 -> 1.0 -> 0.0

                // ÏôºÏ™ΩÏóêÏÑú Ïò§Î•∏Ï™ΩÏúºÎ°ú ÌÅ¨Í≤å ÌúòÎëêÎ•¥Í∏∞ - Î≤îÏúÑ ÌôïÎåÄ
                const startX = -0.7;
                const endX = 0.7;
                weaponModel.position.x = startX + (endX - startX) * swingEase;

                // ÏÜêÎ™© ÌöåÏ†Ñ (YÏ∂ï) - Îçî ÎÑìÏùÄ Î≤îÏúÑÎ°ú ÌúòÎëêÎ•¥Í∏∞
                const rotationY = -2.5 + (2.5 - (-2.5)) * swingEase;
                weaponModel.rotation.y = rotationY;

                // ÏÜêÎ™© ÌöåÏ†Ñ (ZÏ∂ï) - ÏûêÏó∞Ïä§Îü¨Ïö¥ ÌúòÎëêÎ¶Ñ
                weaponModel.rotation.z = -0.15 + swingEaseOut * 0.7;

                // ÏÜêÎ™© ÌöåÏ†Ñ (XÏ∂ï) - ÏúÑÏïÑÎûò ÏõÄÏßÅÏûÑ
                weaponModel.rotation.x = 0.25 + swingEaseOut * 0.3;

                // ÏïûÎí§ Ïù¥Îèô - Îçî ÌÅ∞ Î≤îÏúÑ
                weaponModel.position.z = -0.3 + swingEaseOut * 0.3;

                // ÏúÑÏïÑÎûò ÏõÄÏßÅÏûÑ - Îçî ÏûêÏó∞Ïä§ÎüΩÍ≤å
                weaponModel.position.y = -0.2 + swingEaseOut * 0.15;

                if (knifeSwing < 0) {
                    knifeSwing = 0;
                    // Í∏∞Î≥∏ ÏúÑÏπòÎ°ú Î≥µÍ∑Ä
                    weaponModel.rotation.y = 0;
                    weaponModel.rotation.z = -0.15;
                    weaponModel.rotation.x = 0.25;
                    weaponModel.position.x = 0.3;
                    weaponModel.position.z = -0.35;
                    weaponModel.position.y = -0.2;
                }
            }

            if (isFiring && !isReloading) {
                if (w.type === 'KNIFE' || w.ammo > 0) {
                    if (fireCooldown <= 0) {
                        if (w.automatic) {
                            fireCooldown = w.fireRate;
                            shoot(w);
                        } else {
                            if (!hasFiredSemi) {
                                fireCooldown = w.fireRate;
                                shoot(w);
                                hasFiredSemi = true;
                            }
                        }
                    }
                } else if (w.ammo <= 0 && w.type !== 'KNIFE') {
                    // Îß§Î≤à Îπà Í≤©Î∞ú ÏÜåÎ¶¨ Ïû¨ÏÉù (hasClickedEmpty Ï≤¥ÌÅ¨ Ï†úÍ±∞)
                    if (fireCooldown <= 0) {
                        SoundGen.playDryFire();
                        elAmmoVal.classList.add('no-ammo');
                        setTimeout(() => elAmmoVal.classList.remove('no-ammo'), 200);
                        fireCooldown = 0.2; // Îπà Í≤©Î∞úÎèÑ Ïø®Îã§Ïö¥ Ï†ÅÏö©
                    }
                }
            }
        }

        function shoot(w) {
            if (w.type !== 'KNIFE') {
                w.ammo--;
                updateUI();
                const kick = isAiming ? w.recoil * 0.3 : w.recoil;
                recoil.x += kick; recoil.z += kick;

                if (muzzleFlash) {
                    muzzleFlash.visible = true;
                    muzzleFlash.rotation.z = Math.random() * 6;
                    setTimeout(() => muzzleFlash.visible = false, 30);
                }

                if (w.type === 'SNIPER') {
                    // PC Î™®ÎìúÏóêÏÑúÎßå Ïû¨Ïû•Ï†Ñ Ï†úÏä§Ï≤ò Ï∂îÍ∞Ä
                    if (!isMobile) {
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            sniperReloadGesture = true;
                            // Ïû¨Ïû•Ï†Ñ Ï†úÏä§Ï≤ò: boltÎ•º ÎãπÍ∏∞Í≥† Îã§Ïãú Î∞ÄÏñ¥ÎÑ£Í∏∞
                            const originalRotZ = weaponModel.rotation.z;
                            const originalPosZ = weaponModel.position.z;
                            const originalPosY = weaponModel.position.y;

                            // boltÎ•º Îí§Î°ú ÎãπÍ∏∞Í∏∞
                            weaponModel.rotation.z = originalRotZ + 0.4;
                            weaponModel.position.z = originalPosZ - 0.08;
                            weaponModel.position.y = originalPosY - 0.04;
                            setTimeout(() => {
                                // boltÎ•º ÏïûÏúºÎ°ú Î∞ÄÏñ¥ÎÑ£Í∏∞
                                weaponModel.rotation.z = originalRotZ + 0.15;
                                setTimeout(() => {
                                    // ÏõêÎûò ÏúÑÏπòÎ°ú Î≥µÍ∑Ä
                                    weaponModel.rotation.z = originalRotZ;
                                    weaponModel.position.z = originalPosZ;
                                    weaponModel.position.y = originalPosY;
                                    sniperReloadGesture = false;
                                }, 150);
                            }, 250);
                        }, 600);
                    } else {
                        // Î™®Î∞îÏùºÏóêÏÑúÎäî Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            weaponModel.rotation.z = 0.2;
                            setTimeout(() => weaponModel.rotation.z = 0, 200);
                        }, 600);
                    }
                }

                // FIXED: REMOVED THE BUGGY EMISSIVE FLASH CODE HERE

                spawnShell();
                SoundGen.playShoot(w.type);
            } else {
                knifeSwing = 1.0;
                SoundGen.playKnife();
            }

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (!isAiming && w.type !== 'KNIFE') {
                ray.ray.direction.x += (Math.random() - 0.5) * 0.05;
                ray.ray.direction.y += (Math.random() - 0.5) * 0.05;
            }
            const range = (w.type === 'KNIFE') ? 3.0 : 100;

            const targets = scene.children.filter(obj => obj !== weaponContainer);
            const hits = ray.intersectObjects(targets, true);

            for (let h of hits) {
                if (h.distance > range) continue;

                let isEnemy = false;
                let isOtherPlayer = false;
                let p = h.object;

                // Fix: Find parent with userData.hp
                while (p) {
                    if (p.userData && p.userData.hp !== undefined) {
                        // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Ïù∏ÏßÄ ÌôïÏù∏ (playerIdÍ∞Ä ÏûàÏúºÎ©¥ Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥)
                        if (gameMode === 'multi' && p.userData.playerId !== undefined) {
                            isOtherPlayer = true;
                        } else {
                            isEnemy = true;
                        }
                        break;
                    }
                    if (p.parent === scene || !p.parent) break;
                    p = p.parent;
                }

                if (!isEnemy && !isOtherPlayer) {
                    // Check if it's a map collider before placing decal
                    if (w.type !== 'KNIFE' && h.object.geometry && h.face) createDecal(h.point, h.face.normal);
                }

                // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ÏóêÍ≤å Îç∞ÎØ∏ÏßÄ
                if (isOtherPlayer && p.userData.hp > 0) {
                    let dmg = w.damage;
                    if (h.object.name === 'head') {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (h.object.name === 'limb') {
                        dmg *= 0.7;
                    }

                    // ÏÑúÎ≤ÑÏóê Îç∞ÎØ∏ÏßÄ Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°
                    if (socket && socket.connected) {
                        socket.emit('playerHit', {
                            targetId: p.userData.playerId,
                            damage: dmg
                        });
                    }

                    // ÌûàÌä∏ÎßàÏª§ Îì±ÏùÄ Î°úÏª¨ÏóêÏÑú Ï¶âÏãú ÌëúÏãú
                    elHitMarker.style.opacity = 1;
                    setTimeout(() => elHitMarker.style.opacity = 0, 100);
                    SoundGen.playHit();
                    createBlood(h.point);
                    break;
                }

                if (isEnemy && p.userData.hp > 0) {
                    // Í∞ïÌïú ÌûàÌä∏ÎßàÏª§ Ìö®Í≥º
                    elHitMarker.style.opacity = 1;
                    elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1.5)";
                    elHitMarker.style.filter = "brightness(1.5) drop-shadow(0 0 8px red)";
                    setTimeout(() => {
                        elHitMarker.style.opacity = 0;
                        elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1)";
                        elHitMarker.style.filter = "brightness(1) drop-shadow(0 0 4px red)";
                    }, 150);

                    // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìö®Í≥º (ÌîºÍ≤© Í∞êÍ∞Å)
                    const shakeIntensity = h.object.name === 'head' ? 0.15 : 0.08;
                    hitShake.intensity = shakeIntensity;
                    hitShake.x = (Math.random() - 0.5) * shakeIntensity;
                    hitShake.y = (Math.random() - 0.5) * shakeIntensity;

                    // ÌôîÎ©¥ Îπ®Í∞ÑÏÉâ ÌîåÎûòÏãú (ÌîºÍ≤© Í∞êÍ∞Å)
                    elDamage.style.opacity = h.object.name === 'head' ? 0.6 : 0.4;
                    elDamage.style.background = h.object.name === 'head'
                        ? 'radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.7) 100%)'
                        : 'radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%)';
                    setTimeout(() => {
                        elDamage.style.opacity = 0;
                    }, 80);

                    // ÌîºÍ≤© ÏÇ¨Ïö¥Îìú Ìö®Í≥º
                    SoundGen.playHit();

                    createBlood(h.point);

                    let dmg = w.damage;
                    if (h.object.name === 'head') {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (h.object.name === 'limb') {
                        dmg *= 0.7;
                    }

                    // Flash Red - Îçî Í∞ïÌïòÍ≤å
                    p.children.forEach(c => {
                        if (c.isMesh && c.material && c.material.emissive) {
                            c.material.emissive.setHex(0xff0000);
                            c.material.emissiveIntensity = 1.5; // Îçî Î∞ùÍ≤å
                        }
                    });
                    p.userData.flashTimer = 0.15; // Îçî Ïò§Îûò ÏßÄÏÜç 

                    p.userData.hp -= dmg;
                    const hpPercent = Math.max(0, p.userData.hp / p.userData.maxHp);
                    p.userData.hpBar.scale.x = hpPercent;

                    if (p.userData.hp <= 0) {
                        p.userData.isDead = true;
                        const enemyPos = p.position.clone();
                        scene.remove(p);
                        const index = enemies.indexOf(p);
                        if (index > -1) enemies.splice(index, 1);

                        // Kill Ïπ¥Ïö¥Ìä∏ Ï¶ùÍ∞Ä
                        killCount++;
                        if (elKillCount) {
                            elKillCount.innerText = `Kills: ${killCount}`;
                        }

                        // 30% ÌôïÎ•†Î°ú HP ÌöåÎ≥µ ÏïåÏïΩ ÎìúÎûç
                        if (Math.random() < 0.3) {
                            createHealthPill(enemyPos);
                        }

                        // setTimeout Ï†úÍ±∞ - spawnTimer ÏãúÏä§ÌÖúÏù¥ Ï≤òÎ¶¨Ìï®
                    }
                    break;
                }

                if (!isEnemy) break;
            }
        }

        function checkCollision(newPos) {
            const playerMin = new THREE.Vector3(newPos.x - PLAYER_RADIUS, newPos.y - 0.5, newPos.z - PLAYER_RADIUS);
            const playerMax = new THREE.Vector3(newPos.x + PLAYER_RADIUS, newPos.y + 0.5, newPos.z + PLAYER_RADIUS);
            const playerBox = new THREE.Box3(playerMin, playerMax);
            for (const collider of colliders) {
                if (playerBox.intersectsBox(collider)) return true;
            }
            return false;
        }

        function onResize() {
            // Î™®Î∞îÏùº Í∞ÄÎ°ú Î™®ÎìúÏóêÏÑú Ïã§Ï†ú ÌôîÎ©¥ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            let width, height;

            if (window.visualViewport) {
                // visualViewport API ÏÇ¨Ïö© (Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞Ω Ï†úÏô∏)
                width = window.visualViewport.width;
                height = window.visualViewport.height;
            } else {
                // Ìè¥Î∞±: window ÌÅ¨Í∏∞ ÏÇ¨Ïö©
                width = window.innerWidth;
                height = window.innerHeight;
            }

            // Î™®Î∞îÏùº Í∞ÄÎ°ú Î™®ÎìúÏóêÏÑú ÏµúÏÜå ÎÜíÏù¥ Î≥¥Ïû•
            if (isMobile && window.innerHeight < window.innerWidth) {
                // Í∞ÄÎ°ú Î™®Îìú
                height = Math.max(height, window.screen.height || window.innerHeight);
            }

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            // ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Î¶¨ÏÇ¨Ïù¥Ï¶à
            if (postProcessingCanvas) {
                postProcessingCanvas.width = width;
                postProcessingCanvas.height = height;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
            if (!isDead && !isPaused && gameStartTime > 0) {
                playTime = Math.floor((time - gameStartTime) / 1000);
                const minutes = Math.floor(playTime / 60);
                const seconds = playTime % 60;
                if (elPlayTime) {
                    elPlayTime.innerText = `Time: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }

            if (!isDead && !isPaused) {
                handleShooting(dt);

                const targetHeight = keys.ctrl ? 1.0 : 1.7;
                let nextY = position.y + (targetHeight - position.y) * 10 * dt;
                velocityY -= 20.0 * dt;
                if (nextY < targetHeight && velocityY < 0) {
                    if (!isGrounded) SoundGen.playJump(true);
                    nextY = targetHeight; velocityY = 0; isGrounded = true;
                } else if (!isGrounded) {
                    nextY += velocityY * dt;
                }
                position.y = nextY;

                const w = WEAPONS[curWeaponIdx];
                let speed = 5.0;
                if (keys.shift && !isAiming && !keys.ctrl && w.type !== 'KNIFE') speed = 9.0;
                if (keys.ctrl) speed = 2.5; if (isAiming) speed = 2.0;

                const q = new THREE.Quaternion();
                q.setFromEuler(new THREE.Euler(rotation.x, rotation.y, 0, 'YXZ'));
                camera.quaternion.copy(q);

                const dx = keys.d - keys.a; const dy = keys.s - keys.w;
                if (dx !== 0 || dy !== 0) {
                    const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const moveDir = fwd.multiplyScalar(-dy).add(rgt.multiplyScalar(dx)).normalize();
                    const moveStep = moveDir.multiplyScalar(speed * dt);
                    let nextPos = position.clone(); nextPos.x += moveStep.x;
                    if (!checkCollision(nextPos)) position.x = nextPos.x;
                    nextPos = position.clone(); nextPos.z += moveStep.z;
                    if (!checkCollision(nextPos)) position.z = nextPos.z;

                    if (!isAiming) {
                        if (isGrounded) {
                            moveDistance += speed * dt;
                            if (moveDistance > STEP_INTERVAL) {
                                SoundGen.playStep();
                                moveDistance = 0;
                            }
                        }

                        const bobFreq = keys.shift ? 15 : 8; const bobAmp = keys.shift ? 0.05 : 0.02;
                        weaponContainer.position.y += Math.sin(time * 0.001 * bobFreq) * bobAmp;
                        weaponContainer.position.x += Math.cos(time * 0.001 * (bobFreq / 2)) * bobAmp;
                    }
                }

                const isSniperAiming = isAiming && w.type === 'SNIPER';
                if (isSniperAiming) {
                    weaponContainer.visible = false; elScope.style.display = 'block'; elCrosshair.style.display = 'none';
                } else {
                    weaponContainer.visible = true; elScope.style.display = 'none';
                    // Î™®Î∞îÏùºÏóêÏÑúÎäî Í∂åÏ¥ùÏùº Îïå Ï°∞Ï§ÄÏûê ÌëúÏãú
                    if (isMobile && w.type === 'PISTOL') {
                        elCrosshair.style.display = 'block';
                        elCrosshair.style.opacity = 1;
                    } else if (!isMobile) {
                        elCrosshair.style.display = 'block';
                        elCrosshair.style.opacity = (isAiming && w.type !== 'KNIFE') ? 0 : 1;
                    } else {
                        elCrosshair.style.display = 'none';
                    }
                }

                // Hide/Show front sight based on aiming
                weaponModel.traverse((child) => {
                    if (child.userData && child.userData.isSight) {
                        // Î™®Î∞îÏùºÏóêÏÑú Í∂åÏ¥ùÏùÄ Ìï≠ÏÉÅ Ï°∞Ï§Ä Î™®Îìú
                        const shouldAim = isAiming || (isMobile && w.type === 'PISTOL');
                        child.visible = shouldAim;
                    }
                });

                let targetPos = w.posHip; let targetFov = 70;
                if (isAiming) {
                    if (w.type === 'SNIPER') targetFov = w.fovAds;
                    else if (w.type !== 'KNIFE') { targetPos = w.posAds; targetFov = w.fovAds; }
                    else targetPos = w.posAds;
                }

                currentPos.lerp(targetPos, 15 * dt);
                camera.fov += (targetFov - camera.fov) * 15 * dt;
                camera.updateProjectionMatrix();

                // ÌôîÎ©¥ ÌùîÎì§Î¶º Ìö®Í≥º Ï†ÅÏö© (ÌîºÍ≤© Í∞êÍ∞Å)
                if (hitShake.intensity > 0) {
                    hitShake.x = (Math.random() - 0.5) * hitShake.intensity;
                    hitShake.y = (Math.random() - 0.5) * hitShake.intensity;
                    hitShake.intensity *= 0.85; // Ï†êÏßÑÏ†ÅÏúºÎ°ú Í∞êÏÜå
                    if (hitShake.intensity < 0.01) {
                        hitShake.intensity = 0;
                        hitShake.x = 0;
                        hitShake.y = 0;
                    }
                }

                camera.position.copy(position);
                camera.position.x += hitShake.x;
                camera.position.y += hitShake.y;
                weaponContainer.position.copy(position);
                weaponContainer.position.x += hitShake.x;
                weaponContainer.position.y += hitShake.y;
                weaponContainer.quaternion.copy(camera.quaternion);
                weaponContainer.translateX(currentPos.x);
                weaponContainer.translateY(currentPos.y);
                weaponContainer.translateZ(currentPos.z);

                recoil.x *= (1 - 10 * dt); recoil.z *= (1 - 10 * dt);

                // ÎÇòÏù¥ÌîÑÏùº ÎïåÎßå ÌäπÎ≥ÑÌïú ÏúÑÏπò/ÌöåÏ†Ñ Ï≤òÎ¶¨
                if (w.type === 'KNIFE') {
                    if (knifeSwing === 0) {
                        // ÎÇòÏù¥ÌîÑ Í∏∞Î≥∏ Í∞ÅÎèÑ Ïú†ÏßÄ (ÏÜêÏóê Ï•î Í∞ÅÎèÑ - Í∞úÏÑ†Îêú ÏúÑÏπò)
                        weaponModel.rotation.z = -0.15; // ÏÜêÎ™© Í∞ÅÎèÑ Ïú†ÏßÄ
                        weaponModel.rotation.x = 0.25; // ÏúÑÎ°ú Í∏∞Ïö∏ÏûÑ
                        weaponModel.rotation.y = 0; // Í∏∞Î≥∏ Y ÌöåÏ†Ñ
                        weaponModel.position.x = 0.3; // Í∏∞Î≥∏ X ÏúÑÏπò
                        weaponModel.position.z = -0.35; // Í∏∞Î≥∏ Z ÏúÑÏπò
                        weaponModel.position.y = -0.2; // Í∏∞Î≥∏ Y ÏúÑÏπò
                    }
                } else {
                    // Îã§Î•∏ Î¨¥Í∏∞Îì§ÏùÄ ÏõêÎûòÎåÄÎ°ú (recoilÎßå Ï†ÅÏö©)
                    weaponModel.position.y = THREE.MathUtils.lerp(weaponModel.position.y, 0, 10 * dt);
                    weaponModel.rotation.x = recoil.x + (isReloading ? 0.5 : 0);
                    weaponModel.position.z = recoil.z;
                    // Ïû¨Ïû•Ï†Ñ Ï†úÏä§Ï≤ò Ï§ëÏù¥ ÏïÑÎãê ÎïåÎßå rotation.z Ï¥àÍ∏∞Ìôî
                    if (!sniperReloadGesture) {
                        weaponModel.rotation.z = 0;
                    }
                }
                elVignette.style.opacity = (isAiming && w.type !== 'KNIFE') ? 0.5 : 0;
            }

            updateShells(dt);
            updateParticles(dt);
            if (!isPaused) {
                updateHealthPills(dt);
            }
            // Î™®ÎìúÎ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            if (gameMode === 'single') {
                updateEnemies(dt);
            } else if (gameMode === 'multi') {
                // ÏõêÍ≤© ÌîåÎ†àÏù¥Ïñ¥ HP Î∞îÍ∞Ä Ìï≠ÏÉÅ Ïπ¥Î©îÎùºÎ•º Ìñ•ÌïòÍ≤å
                otherPlayers.forEach(p => {
                    p.lookAt(camera.position.x, p.position.y, camera.position.z);
                });

                // ÏûêÏã†Ïùò ÏÉÅÌÉú ÏÑúÎ≤Ñ Ï†ÑÏÜ° (Ï¥àÎãπ ÏïΩ 30~60Ìöå Î†åÎçîÎßÅÎßàÎã§ Ï†ÑÏÜ°ÌïòÎ©¥ Î∂ÄÌïòÍ∞Ä ÏÉùÍ∏∏ Ïàò ÏûàÏúºÎØÄÎ°ú ÏµúÏ†ÅÌôî Í∞ÄÎä•)
                if (socket && socket.connected && !isDead) {
                    socket.emit('playerMove', {
                        position: { x: position.x, y: position.y, z: position.z },
                        rotation: { x: rotation.x, y: rotation.y }
                    });
                }
            }

            // Î¨ºÎ¶¨ ÏóîÏßÑ ÏóÖÎç∞Ïù¥Ìä∏
            if (usePhysics && physicsWorld) {
                updatePhysics(dt);
            }

            // Î†åÎçîÎßÅ
            renderer.render(scene, camera);

            // ÌõÑÏ≤òÎ¶¨ Ìö®Í≥º Ï†ÅÏö© (Î†åÎçîÎßÅ ÌõÑ)
            if (usePostProcessing && postProcessingEnabled) {
                applyPostProcessing();
            }
        }
    </script>
</body>

</html>