<!DOCTYPE html>
<!-- DEPLOY TRIGGER: 2026-01-24 -->
<!-- VERSION: 2026-01-19-FORCE-UPDATE -->
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Cache Control to prevent old version persistence on Vercel -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>FPS Game</title>

    <!-- PWA / Standalone 모드 설정 - 주소창 숨기기 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">

    <title>FPS Multiplayer - Room System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Favicon fix to prevent 404 -->
    <link rel="icon" href="data:,">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* 모바일 가로 모드 대응 */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* 모바일 가로 모드 최적화 */
        @media (orientation: landscape) and (max-height: 500px) {

            html,
            body {
                height: 100vh;
                height: 100dvh;
            }


            @supports (height: -webkit-fill-available) {

                html,
                body {
                    height: -webkit-fill-available;
                }
            }
        }


        /* --- NEON TACTICAL HUD CSS --- */

        :root {
            --neon-cyan: #00f3ff;
            --neon-red: #ff003c;
            --dark-bg: rgba(9, 9, 11, 0.65);
            --font-stack: 'Rajdhani', sans-serif;
        }

        /* Utility & Layout */
        .hud-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            font-family: var(--font-stack);
            color: white;
        }

        /* Glassmorphism Panels */
        .vitals-panel,
        .weapon-panel,
        .scoreboard-mini {
            background: var(--dark-bg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transform: skewX(-10deg);
            padding: 1rem;
            position: absolute;
        }

        /* Top Center: Scoreboard */
        .scoreboard-mini {
            top: 1rem;
            left: 50%;
            transform: translateX(-50%) skewX(-10deg);
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .scoreboard-mini>div {
            transform: skewX(10deg);
        }

        .score.ally {
            color: var(--neon-cyan);
        }

        .score.enemy {
            color: var(--neon-red);
        }

        /* Single Player HUD Overrides */
        body.single-player #hud-score-ally,
        body.single-player #hud-score-enemy {
            display: none;
        }

        body.single-player #hud-kill-count {
            display: block;
        }

        #hud-score-ally,
        #hud-score-enemy,
        #hud-kill-count {
            display: none !important;
        }

        /* Top Right: Kill Feed */
        .kill-feed {
            position: absolute;
            top: 280px;
            /* Far below scoreboard to avoid overlap */
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: right;
            align-items: flex-end;
            pointer-events: none;
        }

        .feed-item {
            background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.8));
            padding: 5px 10px;
            border-right: 2px solid var(--neon-red);
            font-size: 0.9rem;
            text-transform: uppercase;
            opacity: 0.9;
            color: white;
            animation: slideIn 0.3s ease-out;
        }

        .feed-item .killer {
            color: var(--neon-cyan);
            font-weight: bold;
        }

        .feed-item .victim {
            color: var(--neon-red);
        }


        /* Vertical Weapon List (Left Side) */
        #weapon-list-left {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            /* Just for display */
        }

        .weapon-item {
            display: flex;
            align-items: center;
            opacity: 0.4;
            transition: all 0.2s ease-out;
            transform: translateX(-10px);
        }

        .weapon-item.active {
            opacity: 1;
            transform: translateX(0) scale(1.1);
        }

        .weapon-item .key-hint {
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            margin-right: 10px;
        }

        .weapon-item.active .key-hint {
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            color: #000;
        }

        .weapon-item .icon-box {
            width: 110px;
            height: 110px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .weapon-item.active .icon-box {
            border-color: var(--neon-cyan);
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .weapon-item i {
            font-size: 54px;
            color: #fff;
        }

        .weapon-item.active i {
            color: var(--neon-cyan);
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            z-index: 100;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Transition for container if needed, but mainly for children */
        }

        .crosshair .dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
            z-index: 102;
        }

        .crosshair .hair {
            position: absolute;
            background-color: white;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            transition: transform 0.1s ease-out;
            /* Smooth spread */
            z-index: 101;
        }

        /* Vertical Lines (Top/Bottom) - Width 2px, Height 10px */
        .crosshair .hair.top,
        .crosshair .hair.bottom {
            width: 2px;
            height: 10px;
            left: 50%;
            transform: translateX(-50%);
            /* Center horizontally */
        }

        /* Horizontal Lines (Left/Right) - Width 10px, Height 2px */
        .crosshair .hair.left,
        .crosshair .hair.right {
            width: 10px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
            /* Center vertically */
        }

        /* Initial Positions (will be overridden by JS, but good defaults) */
        .crosshair .hair.top {
            top: 15px;
            /* Offset from container top (center is 30) -> Gap */
        }

        .crosshair .hair.bottom {
            bottom: 15px;
        }

        .crosshair .hair.left {
            left: 15px;
        }

        .crosshair .hair.right {
            right: 15px;
        }

        .crosshair.firing .horizontal {
            width: 35px;
            opacity: 0.5;
        }

        .crosshair.firing .vertical {
            height: 35px;
            opacity: 0.5;
        }

        .crosshair.enemy-detected .line {
            background: var(--neon-red);
            box-shadow: 0 0 5px red;
        }

        /* Bottom Left: Vitals */
        .vitals-panel {
            bottom: 2rem;
            left: 2rem;
            width: 300px;
            border-left: 4px solid var(--neon-cyan);
        }

        .value-group {
            display: flex;
            align-items: baseline;
            gap: 10px;
            transform: skewX(10deg);
        }

        .health-text {
            font-size: 3rem;
            font-weight: 700;
            line-height: 0.8;
            text-shadow: 0 0 10px var(--neon-cyan);
        }

        .bar-container {
            margin-top: 10px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            transform: skewX(10deg);
            overflow: hidden;
        }

        .health-bar {
            height: 100%;
            background: var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan);
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 2;
            position: relative;
        }

        .health-bar-ghost {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: white;
            transition: width 1s ease-out 0.2s;
            z-index: 1;
        }

        /* Bottom Right: Weapon */
        .weapon-panel {
            bottom: 2rem;
            right: 2rem;
            text-align: right;
            border-right: 4px solid white;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .ammo-group {
            transform: skewX(10deg);
        }

        .ammo-current {
            font-size: 4rem;
            font-weight: 700;
            line-height: 0.8;
        }

        .ammo-reserve {
            font-size: 1.5rem;
            color: #aaa;
        }

        .weapon-selector {
            display: none;
            /* Hide old selector */
        }

        #rifle-debug-panel {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            color: #9eff9e;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: none;
        }

        #rifle-debug-panel .panel-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #c9ffd1;
        }

        #rifle-debug-panel .panel-row {
            display: grid;
            grid-template-columns: 25px 1fr 45px;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 4px;
            width: 100%;
        }

        #rifle-debug-panel input[type="range"] {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        #rifle-debug-panel button {
            background: #1f8f4a;
            color: #fff;
            border: none;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .nudge-btn {
            width: 22px;
            height: 22px;
            padding: 0 !important;
            background: #444 !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            line-height: 1;
        }

        .nudge-btn:hover {
            background: #666 !important;
        }

        #rifle-debug-panel #rifle-x-minus,
        #rifle-debug-panel #rifle-x-plus {
            width: 34px;
            height: 24px;
            padding: 0;
            background: #2b2b2b;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
        }

        #pistol-debug-panel {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            color: #ffcc9e;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: none;
        }

        #pistol-debug-panel .panel-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #ffd1c9;
        }

        #pistol-debug-panel .panel-row {
            display: grid;
            grid-template-columns: 25px 1fr 45px;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
        }

        #pistol-debug-panel input[type="range"] {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        #pistol-debug-panel button {
            background: #8f4a1f;
            color: #fff;
            border: none;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        #sniper-debug-panel {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            color: #9eccff;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: none;
        }

        #sniper-debug-panel .panel-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #c9e1ff;
        }

        #sniper-debug-panel .panel-row {
            display: grid;
            grid-template-columns: 25px 1fr 45px;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
        }

        #sniper-debug-panel input[type="range"] {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        #sniper-debug-panel button {
            background: #1f4a8f;
            color: #fff;
            border: none;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        #sniper-debug-panel .arms-flex-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #sniper-debug-panel .arm-column {
            flex: 1;
            min-width: 260px;
        }

        #sniper-debug-panel .section-title,
        #knife-debug-panel .section-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 13px;
        }

        #knife-debug-panel {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.75);
            color: #ff9ecc;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            display: none;
        }

        #knife-debug-panel .panel-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #ffc9e1;
        }

        #knife-debug-panel .panel-row {
            display: grid;
            grid-template-columns: 25px 1fr 45px;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
        }

        #knife-debug-panel input[type="range"] {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        #knife-debug-panel button {
            background: #8f1f4a;
            color: #fff;
            border: none;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        #knife-debug-panel .arms-flex-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #knife-debug-panel .arm-column {
            flex: 1;
            min-width: 260px;
        }

        #knife-swing-panel {
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.85);
            color: #ffcc66;
            font-family: ui-monospace, Menlo, Consolas, monospace;
            font-size: 11px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 200, 100, 0.4);
            border-radius: 6px;
            display: none;
            width: 320px;
            pointer-events: auto;
        }

        #knife-swing-panel .panel-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #ffdd88;
            font-size: 13px;
        }

        #knife-swing-panel .section-title {
            font-weight: bold;
            margin: 8px 0 4px 0;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            color: #ffa;
        }

        #knife-swing-panel .panel-row {
            display: grid;
            grid-template-columns: 40px 1fr 40px;
            align-items: center;
            gap: 4px;
            margin-bottom: 4px;
        }

        #knife-swing-panel input[type="range"] {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        #knife-swing-panel button {
            background: #8f6f1f;
            color: #fff;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        #knife-swing-panel button:hover {
            background: #af8f3f;
        }


        .weapon-slot {
            width: 30px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
            color: transparent;
            /* Hide number */
            font-size: 0;
        }

        .weapon-slot.active {
            background: white;
            box-shadow: 0 0 10px white;
            transform: scaleY(1.5);
        }

        /* Damage Vignette */
        .damage-vignette {
            position: absolute;
            inset: 0;
            box-shadow: inset 0 0 100px var(--neon-red);
            opacity: 0;
            transition: opacity 0.2s;
            mix-blend-mode: overlay;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes slideIn {
            from {
                transform: translateX(20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 0.9;
            }
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .vitals-panel {
                width: 200px;
                bottom: 1rem;
                left: 1rem;
                padding: 0.5rem;
            }

            .health-text {
                font-size: 2rem;
            }

            .weapon-panel {
                bottom: 1rem;
                right: 1rem;
                padding: 0.5rem;
            }

            .ammo-current {
                font-size: 2.5rem;
            }

            .scoreboard-mini {
                top: 0.5rem;
                font-size: 1rem;
            }

            /* Mobile Landscape Specific */
            @media (orientation: landscape) {
                #weapon-inventory {
                    gap: 12px;
                    left: 10px;
                }

                .weapon-slot {
                    padding: 12px 20px;
                }

                .weapon-number {
                    font-size: 24px;
                    min-width: 30px;
                }

                .weapon-name {
                    font-size: 20px;
                }

                #hp-container {
                    left: 10px;
                    bottom: 10px;
                    width: 400px;
                    height: 30px;
                }

                #hp-text {
                    left: 10px;
                    bottom: 45px;
                    font-size: 28px;
                }

                #chat-container {
                    bottom: 100px;
                    left: 10px;
                    width: 350px;
                }

                #chat-messages {
                    height: 150px;
                }
            }
        }


        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transition: opacity 0.1s;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px black;
        }

        #crosshair::before {
            width: 16px;
            height: 1.5px;
        }

        #crosshair::after {
            width: 1.5px;
            height: 16px;
        }

        #crosshair.enemy-detected::before,
        #crosshair.enemy-detected::after {
            background: #ff0000;
            box-shadow: 0 0 4px red;
        }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s, filter 0.1s;
            z-index: 10;
        }

        #hit-marker::before,
        #hit-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: #ff3333;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px red, 0 0 12px rgba(255, 0, 0, 0.6);
        }

        #hit-marker::before {
            width: 28px;
            height: 4px;
        }

        #hit-marker::after {
            width: 4px;
            height: 28px;
        }

        #scope-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 20;
            /* PUBG 스타일 - 주변도 보이도록 반투명 처리 */
            background: radial-gradient(circle, transparent 20%, rgba(0, 0, 0, 0.7) 21%, rgba(0, 0, 0, 0.85) 100%);
            /* Pointer events none to allow clicks if needed, though usually aiming blocks interactions */
            pointer-events: none;
        }

        #scope-line-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(-50%);
        }

        #scope-line-v {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateX(-50%);
        }

        #scope-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, black 150%);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 5;
            pointer-events: none;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 6;
            pointer-events: none;
        }

        #low-health-overlay {
            position: fixed;
            /* [FIX] Force Fixed position to cover screen */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
            /* [FIX] Max Z-Index */
            /* Aggressive Red Gradient */
            background: radial-gradient(circle, transparent 20%, rgba(255, 0, 0, 0.4) 60%, rgba(255, 0, 0, 0.9) 100%);
            opacity: 0;
            transition: opacity 0.3s;
            display: block;
            /* Ensure it is block */
        }

        #low-health-overlay.active {
            animation: lowHealthPulse 1s infinite alternate ease-in-out;
        }

        @keyframes lowHealthPulse {
            from {
                opacity: 0.5;
            }

            to {
                opacity: 1;
            }
        }

        #headshot-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            color: #ff0000;
            font-size: 40px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 2px 2px 0 #000;
            opacity: 0;
            transition: transform 0.1s, opacity 0.1s;
            z-index: 15;
            pointer-events: none;
        }

        #headshot-msg.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }

        #ammo-info {
            position: absolute;
            bottom: 25px;
            right: 25px;
            color: white;
            font-size: 24px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 1px 1px 2px #000;
            letter-spacing: 1px;
            text-align: right;
            pointer-events: none;
        }

        #weapon-label {
            font-size: 18px;
            color: #fbbc05;
            display: block;
            margin-bottom: 5px;
        }

        #ammo-val {
            display: block;
        }

        .no-ammo {
            color: #ff3333;
            animation: shake 0.2s;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        #hp-container {
            position: absolute;
            bottom: 25px;
            left: 0;
            /* Align to the LEFT edge */
            width: 400px;
            /* Doubled size (from 200px) */
            height: 30px;
            /* Doubled size (from 15px) */
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: visible;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: #4caf50;
            transition: width 0.2s, background-color 0.2s;
            border-radius: 2px;
        }

        #hp-text {
            position: absolute;
            left: 10px;
            /* Inside the bar or very close to the left */
            bottom: 40px;
            /* Above the bar or inside if adjusted */
            line-height: 30px;
            color: white;
            font-weight: bold;
            font-size: 28px;
            /* Larger font for larger bar */
            text-shadow: 2px 2px 4px black;
            z-index: 5;
            pointer-events: none;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: red;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 60px;
            font-weight: 900;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99;
            font-size: 40px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        /* --- FRONTLINE TACTICAL UI DESIGN --- */
        :root {
            --tactical-cyan: #00f3ff;
            --tactical-amber: #facc15;
            --tactical-red: #ff003c;
            --glass-bg: rgba(9, 9, 11, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        #mode-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 30% 50%, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.8) 100%),
                url('background.png') center/55% no-repeat black;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            padding: 5vh 10% 2vh 10%;
            z-index: 200;
            overflow: hidden;
            pointer-events: auto;
        }

        #mode-selection::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.3;
        }


        .menu-buttons-container {
            display: flex;
            flex-direction: column;
            z-index: 2;

            /* [새로 추가] 위치 강제 지정 */
            position: absolute;
            /* 절대 위치 사용 */
            bottom: 20vh;
            /* 화면 바닥에서 5% 정도 띄움 (숫자를 줄이면 더 내려갑니다) */
            width: 100%;
            /* 너비 꽉 채우기 */
            align-items: center;
            /* 버튼 가운데 정렬 (필요시) */
            padding-left: 0;
            /* 기존 왼쪽 여백 무시 */
        }

        .menu-title-container {
            /* [새로 추가] 위치 강제 지정 */
            position: absolute;
            /* 절대 위치 */
            top: 35vh;
            /* 화면 천장에서 15% 아래 (숫자를 줄이면 더 위로 갑니다 예: 10vh) */
            width: 100%;
            /* 너비 꽉 채우기 */
            display: flex;
            /* 중앙 정렬을 위해 필요 */
            justify-content: center;
            /* 가로 중앙 정렬 */
            z-index: 2;
            margin: 0;
            /* 기존 여백 제거 */
        }

        .menu-buttons-container {
            display: flex;
            flex-direction: column;
            z-index: 2;
        }

        .tactical-logo {
            max-width: 400px;
            filter: drop-shadow(0 0 20px var(--tactical-cyan));
            margin-bottom: 20px;
        }

        .tactical-subtitle {
            font-size: 18px;
            color: var(--tactical-cyan);
            letter-spacing: 5px;
            text-transform: uppercase;
            font-family: var(--font-stack);
            opacity: 0.8;
            border-left: 4px solid var(--tactical-cyan);
            padding-left: 15px;
        }

        .mode-btn {
            position: relative;
            margin: 15px 0;
            padding: 15px 40px;
            font-size: 28px;
            font-family: var(--font-stack);
            font-weight: 700;
            text-transform: uppercase;
            color: white;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: skewX(-15deg);
            min-width: 320px;
            text-align: left;
            overflow: hidden;
            z-index: 2;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .mode-btn:hover {
            background: rgba(0, 243, 255, 0.1);
            border-color: var(--tactical-cyan);
            padding-left: 60px;
            box-shadow: -10px 0 20px rgba(0, 243, 255, 0.2);
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn .btn-text {
            transform: skewX(15deg);
            display: inline-block;
        }

        .mode-btn .btn-icon {
            margin-right: 15px;
            color: var(--tactical-cyan);
        }

        .mode-btn.cancel {
            border-color: rgba(255, 0, 60, 0.3);
        }

        .mode-btn.cancel:hover {
            border-color: var(--tactical-red);
            background: rgba(255, 0, 60, 0.1);
            box-shadow: -10px 0 20px rgba(255, 0, 60, 0.2);
        }

        .mode-btn.cancel .btn-icon {
            color: var(--tactical-red);
        }

        /* --- Room System / Overlays Redesign --- */
        #name-setup,
        #room-menu,
        #create-room-modal,
        #room-waiting,
        #single-map-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #09090b;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
            font-family: var(--font-stack);
            backdrop-filter: blur(10px);
        }

        .tactical-panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 40px;
            border-radius: 4px;
            transform: skewX(-5deg);
            max-width: 90%;
            width: 600px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .tactical-panel::after {
            content: 'SECURE_LINK_ESTABLISHED';
            position: absolute;
            bottom: -25px;
            right: 0;
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--tactical-cyan);
            opacity: 0.5;
            transform: skewX(5deg);
        }

        .tactical-panel>* {
            transform: skewX(5deg);
        }

        .tactical-title {
            font-size: 32px;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 30px;
            color: var(--tactical-cyan);
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 15px;
        }

        .tactical-input-group {
            margin-bottom: 25px;
        }

        .tactical-input-group label {
            display: block;
            font-size: 14px;
            text-transform: uppercase;
            color: #aaa;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        input[type="text"].tactical-input,
        select.tactical-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            padding: 12px 20px;
            color: white;
            font-family: var(--font-stack);
            font-size: 18px;
            transition: all 0.3s;
        }

        input[type="text"].tactical-input:focus,
        select.tactical-input:focus {
            outline: none;
            border-color: var(--tactical-cyan);
            background: rgba(0, 243, 255, 0.05);
        }

        /* Room List Custom Styling */
        #room-list-container {
            width: 100%;
            height: 350px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            margin: 20px 0;
            overflow-y: auto;
            padding: 10px;
        }

        .room-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            margin-bottom: 10px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .room-item:hover {
            background: rgba(0, 243, 255, 0.05);
            border-color: var(--tactical-cyan);
        }

        .status-badge {
            padding: 4px 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            border-radius: 2px;
        }

        .status-badge.waiting {
            background: var(--tactical-cyan);
            color: #000;
        }

        .status-badge.playing {
            background: var(--tactical-amber);
            color: #000;
        }

        .status-badge.full {
            background: var(--tactical-red);
            color: white;
        }

        /* Map Grid Styles */
        .map-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            width: 100%;
            margin-bottom: 30px;
        }

        .map-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .map-card:hover {
            border-color: var(--tactical-cyan);
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 243, 255, 0.1);
        }

        .map-card i {
            font-size: 40px;
            margin-bottom: 15px;
            color: var(--tactical-cyan);
        }

        .map-card.selected {
            border-color: var(--tactical-cyan);
            background: rgba(0, 243, 255, 0.1);
        }

        /* Message Toggle Button */
        #chat-toggle-btn {
            position: absolute;
            left: 20px;
            bottom: 300px;
            z-index: 101;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-stack);
            font-weight: bold;
            display: none;
            /* Only show in mobile landscape */
        }

        @media (max-width: 768px) and (orientation: landscape) {
            #chat-toggle-btn {
                display: block;
            }

            #chat-container {
                display: none;
                /* Initially hidden in mobile landscape */
            }
        }

        #chat-container {
            position: absolute;
            left: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
            /* HP 바 위, 무기 인벤토리 아래에 배치 */
            bottom: 150px;
        }

        #chat-messages {
            height: 100px;
            overflow-y: auto;
            padding-right: 5px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #chat-messages::-webkit-scrollbar {
            width: 5px;
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .chat-msg {
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-msg .sender {
            font-weight: bold;
            color: #4CAF50;
            margin-right: 5px;
        }

        .chat-msg.system {
            color: #ffeb3b;
            font-style: italic;
        }

        .chat-input-area {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            width: auto;
        }

        #btn-send-chat {
            padding: 8px 15px;
            border-radius: 20px;
            margin: 0;
            background: #2196F3;
        }

        #room-waiting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 202;
            font-size: 24px;
            pointer-events: auto;
        }

        #room-waiting h2 {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #players-list {
            margin: 30px;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        #countdown {
            font-size: 72px;
            color: #ff3333;
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.8);
            margin: 30px;
        }

        #restart-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid #444;
            cursor: pointer;
            z-index: 2000;
            /* Ensure visibility */
            pointer-events: auto;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #exit-to-menu-btn {
            margin-top: 15px;
            padding: 10px 30px;
            font-size: 20px;
            font-weight: bold;
            background: rgba(50, 0, 0, 0.8);
            border: 2px solid #ff3333;
            color: #ff3333;
            cursor: pointer;
            z-index: 2000;
            pointer-events: auto;
            border-radius: 8px;
            transition: all 0.2s;
        }

        #exit-to-menu-btn:hover {
            background: rgba(255, 51, 51, 0.2);
            color: white;
            transform: scale(1.05);
        }

        #game-over-stats {
            font-size: 32px;
            color: white;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #stats-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: flex;
            gap: 30px;
            z-index: 10;
        }

        #play-time,
        #kill-count {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #controls-guide {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            line-height: 1.6;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }

        .key {
            color: #fbbc05;
            font-weight: bold;
        }

        /* PC 감도 조정 UI */
        /* PC 감도 조정 UI - Modified for Pause Menu */
        #sensitivity-control,
        #volume-control {
            /* Originally absolute, now static in flex container */
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin-top: 20px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #sensitivity-control label,
        #volume-control label {
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }

        #sensitivity-slider,
        #volume-slider {
            width: 150px;
            margin-right: 10px;
        }

        #sensitivity-value,
        #volume-value {
            color: #fbbc05;
            font-weight: bold;
            font-size: 14px;
            min-width: 40px;
            display: inline-block;
        }

        #light-toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.4);
            /* Reduced from 2px for better alignment */
            border-radius: 50%;
            display: none;
            /* Hide by default, show only during gameplay */
            align-items: center;
            justify-content: center;
            color: #ffaa00;
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            user-select: none;
            transition: all 0.2s;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        #light-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
        }

        #light-toggle-btn.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
            color: #ffcc44;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* Death Overlay & Killcam UI */
        #death-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
            pointer-events: none;
        }

        #respawn-timer {
            font-size: 96px;
            font-weight: bold;
            color: #ff3333;
            text-shadow: 0 0 30px rgba(255, 51, 51, 0.9), 0 0 60px rgba(255, 51, 51, 0.5);
            margin-bottom: 30px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        #killed-by-label {
            font-size: 28px;
            color: #ffffff;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        #killer-name {
            font-size: 48px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
        }

        /* Sniper Scope Overlay */
        #sniper-scope {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center,
                    transparent 0%,
                    transparent 24%,
                    rgba(0, 0, 0, 0.5) 26%,
                    rgba(0, 0, 0, 0.75) 100%);
            display: none;
            z-index: 100;
            pointer-events: none;
        }

        #scope-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(600px, 80vh);
            height: min(600px, 80vh);
            border: 15px solid #111;
            border-radius: 50%;
            box-shadow:
                inset 0 0 60px rgba(0, 0, 0, 0.9),
                inset 0 0 20px rgba(0, 0, 0, 0.6),
                0 0 30px rgba(0, 0, 0, 0.8);
        }

        .scope-crosshair-h,
        .scope-crosshair-v {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        .scope-crosshair-h {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .scope-crosshair-v {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        .scope-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 50, 50, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 50, 50, 0.8);
        }

        /* Scope tick marks */
        .scope-tick {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }

        .scope-tick-h {
            height: 1px;
            width: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        .scope-tick-v {
            width: 1px;
            height: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* 모바일 컨트롤 */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            pointer-events: none;
        }

        #touch-left,
        #touch-right {
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        /* 모바일 버튼 */
        .mobile-btn {
            position: absolute;
            width: 35px;
            /* 40px -> 35px (추가 축소) */
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            /* 16px -> 14px */
            font-weight: bold;
            pointer-events: auto;
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        /* --- 1. Joystick --- */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 100px;
            /* 120px -> 100px */
            height: 100px;
            z-index: 50;
            touch-action: none;
            /* Prevent browser scrolling */
            background: rgba(255, 255, 255, 0.1);
            /* Visible Hint */
        }

        #joystick-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            /* 50px -> 40px */
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* --- 2. Vertical Weapon Selector (Left) --- */
        #weapon-selector-vertical {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            /* Mobile only */
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
            /* Increased to ensure visibility above other layers */
            pointer-events: auto;
        }

        .weapon-select-btn {
            width: 35px;
            /* 40px -> 35px */
            height: 35px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            /* 18px -> 16px */
        }

        .weapon-select-btn.active {
            background: rgba(255, 170, 0, 0.6);
            border-color: #ffaa00;
        }

        /* 무기 교체 버튼 (기본적으로 숨김, 미디어 쿼리에서 처리) */
        #btn-weapon1,
        #btn-weapon2,
        #btn-weapon3,
        #btn-weapon4 {
            display: none;
        }

        /* 크런커 스타일 클러스터 배치 */
        #btn-shoot {
            bottom: 80px;
            right: 80px;
            width: 55px;
            /* 80px -> 55px */
            height: 55px;
            background: rgba(255, 255, 255, 0.2);
            font-size: 24px;
            /* 32px -> 24px */
            border-width: 3px;
        }

        #btn-aim {
            bottom: 180px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-jump {
            bottom: 110px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-reload {
            bottom: 20px;
            right: 140px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-weapon-cycle {
            bottom: 20px;
            right: 220px;
            width: 60px;
            height: 60px;
            font-size: 24px;
            background: rgba(251, 188, 5, 0.3);
            border-color: #fbbc05;
        }

        /* 모바일 UI 조정 */
        @media (max-width: 768px) {

            /* 1. HUD 하단 이동 및 축소 - 모바일 전용 오버라이드 */
            #ammo-info {
                bottom: 20px;
                left: auto;
                /* 기존 중앙 정렬 해제 */
                right: 90px;
                /* 오른쪽 버튼 피해서 배치 */
                font-size: 14px;
                /* 더 작게 */
                text-align: right;
                transform: none;
            }

            #ammo-val {
                font-size: 18px;
            }

            #weapon-label {
                display: none;
            }

            /* 공간 절약 */

            #hp-container {
                width: 120px;
                /* 150px -> 120px */
                height: 8px;
                /* 10px -> 8px */
                bottom: 22px;
                left: 45px;
                /* 60px -> 45px, closer to left */
                /* HP 텍스트 공간 확보 */
                transform: none;
                /* 중앙 정렬 해제 */
                background: rgba(0, 0, 0, 0.6);
            }

            #hp-text {
                display: block;
                /* 텍스트 표시 */
                font-size: 12px;
                /* 14px -> 12px */
                left: -28px;
                /* -30px -> -28px */
                bottom: -3px;
                /* -4px -> -3px */
            }

            /* 버튼 위치 상향 조정 (화면 하단 겹침 방지 - 탄약 표시와 겹치지 않도록 추가 상향) */
            .mobile-btn {
                bottom: 150px;
                /* 110px -> 150px (추가 상향) */
                /* 기본값 상향 */
            }

            #btn-shoot {
                bottom: 170px;
                /* 130px -> 170px */
                right: 40px;
                width: 45px;
                /* 50px -> 45px */
                /* 70px -> 50px */
                height: 45px;
            }

            #btn-jump {
                bottom: 230px;
                /* 190px -> 230px */
                right: 20px;
            }

            #btn-reload {
                bottom: 290px;
                /* 250px -> 290px */
                right: 20px;
            }

            #btn-aim {
                bottom: 110px;
                /* 70px -> 110px */
                right: 100px;
            }

            #joystick-zone {
                bottom: 150px;
                /* 110px -> 150px */
                /* 조이스틱도 상향 */
                left: 40px;
                display: block !important;
                /* Force Visible */
            }

            #weapon-selector-vertical {
                top: 30%;
                /* Move higher up from 45% */
                left: 20px;
            }

            #controls-guide {
                display: none;
                /* 모바일에서 조작 설명 숨김 */
            }

            .mobile-btn {
                display: flex;
            }

            /* 상단 스탯 정보 최적화 */
            #stats-info {
                top: 5px;
                gap: 10px;
                font-size: 12px;
            }

            #play-time,
            #kill-count {
                padding: 2px 8px;
                background: rgba(0, 0, 0, 0.3);
                border: none;
            }

            .mobile-btn {
                display: flex;
            }

            /* 기존 무기 버튼 및 사이클 버튼 숨김 (새로운 수직 선택기로 대체) */
            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4,
            #btn-weapon-cycle {
                display: none;
            }

            /* 무기 선택기 표시 */
            #weapon-selector-vertical {
                display: flex;
            }

            /* 조이스틱 표시 */
            #joystick-zone {
                display: block;
            }
        }

        /* 가로 모드 - 모바일 스타일 적용 (User Request: Like Portrait Mode) */
        @media (orientation: landscape) and (max-width: 1280px) {
            #controls-guide {
                display: none;
            }

            #weapon-label {
                display: none;
            }

            /* [User Request] Force Joystick Visible in Landscape */
            #joystick-zone {
                display: block !important;
                bottom: 40px;
                left: 40px;
                z-index: 1000;
            }

            /* [User Request] Fixed: Hide PC Weapon List in Mobile Landscape */
            #weapon-list-left,
            #weapon-inventory,
            #controls-guide,
            #weapon-label {
                display: none !important;
            }

            /* [User Request] Force Mobile Controls Visible in Landscape */
            #joystick-zone,
            #fire-btn-zone,
            #jump-btn,
            #reload-btn,
            #crouch-btn,
            .mobile-controls {
                display: block !important;
                z-index: 9999 !important;
                opacity: 0.8 !important;
                pointer-events: auto !important;
            }

            /* [User Request] Show Mobile Weapon Selector */
            #weapon-selector-vertical {
                display: flex !important;
                flex-direction: column;
                top: 40% !important;
                /* Adjust if needed */
                left: 20px;
            }

            /* 버튼 숨김 -> 수직 선택기 사용 */
            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                display: none;
            }

            /* ===== HP & AMMO 상단에 표시 (수정됨) ===== */
            .vitals-panel {
                display: flex !important;
                flex-direction: row;
                align-items: center;
                bottom: 20px !important;
                top: auto;
                left: 170px;
                /* 조이스틱 피해서 우측으로 이동 */
                width: auto;
                padding: 5px 15px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-left: 4px solid var(--neon-cyan);
                transform: none;
                border-radius: 4px;
                z-index: 90;
            }

            .vitals-panel .value-group {
                transform: none;
                margin-right: 15px;
                gap: 5px;
            }

            .vitals-panel .label {
                font-size: 12px;
                color: #aaa;
            }

            .vitals-panel .health-text {
                font-size: 24px;
                line-height: 1;
            }

            .vitals-panel .bar-container {
                width: 120px;
                height: 10px;
                margin-top: 0;
                transform: none;
                background: rgba(0, 0, 0, 0.5);
            }

            .weapon-panel {
                display: flex !important;
                flex-direction: column;
                bottom: 20px !important;
                top: auto;
                right: 170px;
                /* 버튼 피해서 좌측으로 이동 */
                /* exit button(80px) 왼쪽 */
                padding: 5px 15px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-right: 4px solid white;
                transform: none;
                border-radius: 4px;
                align-items: flex-end;
                z-index: 90;
            }

            .weapon-panel .ammo-group {
                transform: none;
            }

            .weapon-panel .ammo-current {
                font-size: 24px;
                line-height: 1;
            }

            .weapon-panel .ammo-reserve {
                font-size: 14px;
            }

            /* Hide unnecessary elements in landscape */
            #hud-weapon-selector,
            #hud-weapon-name,
            #hp-container,
            #hp-text,
            #ammo-info {
                display: none !important;
            }

            /* ===== 버튼들 - 크기 통일 및 왼쪽 이동 ===== */
            .mobile-btn {
                display: flex;
                width: 50px;
                /* 60px -> 50px (축소) */
                height: 50px;
                /* 60px -> 50px (축소) */
                font-size: 18px;
                /* 20px -> 18px */
            }

            /* 발사 버튼 */
            #btn-shoot {
                bottom: 80px;
                /* 90px -> 80px */
                right: 120px;
            }

            /* 점프 버튼 */
            #btn-jump {
                bottom: 40px;
                /* 50px -> 40px */
                right: 50px;
            }

            /* 재장전 버튼 */
            #btn-reload {
                bottom: 110px;
                /* 130px -> 110px */
                right: 50px;
            }

            /* 조준 버튼 */
            #btn-aim {
                bottom: 40px;
                /* 50px -> 40px */
                right: 190px;
                /* 200px -> 190px */
            }


            /* 채팅 가시성 및 위치 조정 (User Request) */
            #chat-container {
                display: flex !important;
                bottom: 110px !important;
                left: 10px !important;
                width: 240px !important;
                z-index: 10000 !important;
            }

            /* 조명 버튼 위치 조정 */
            #light-toggle-btn {
                top: 3px;
                right: 3px;
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            /* ===== [FIX] HP/탄창 UI 크기 축소 (모바일 가로 모드) ===== */
            .vitals-panel {
                padding: 3px 8px !important;
                left: 130px !important;
                bottom: 10px !important;
                transform: scale(0.7) !important;
                transform-origin: left bottom;
            }

            .vitals-panel .health-text {
                font-size: 16px !important;
            }

            .vitals-panel .bar-container {
                width: 80px !important;
                height: 6px !important;
            }

            .weapon-panel {
                padding: 3px 8px !important;
                right: 130px !important;
                bottom: 10px !important;
                transform: scale(0.7) !important;
                transform-origin: right bottom;
            }

            .weapon-panel .ammo-current {
                font-size: 16px !important;
            }

            .weapon-panel .ammo-reserve {
                font-size: 10px !important;
            }

            /* ===== [FIX] 무기 선택기 강제 표시 (모바일 가로 모드) ===== */
            #weapon-selector-vertical {
                display: flex !important;
                left: 20px !important;
                top: 50% !important;
                transform: translateY(-50%) !important;
                gap: 10px !important;
            }

            /* ===== [FIX] 조이스틱 및 버튼 강제 표시 (모바일 가로 모드) ===== */
            #joystick-zone {
                display: block !important;
                bottom: 20px !important;
                left: 20px !important;
                width: 100px !important;
                height: 100px !important;
            }

            #joystick-base {
                width: 100% !important;
                height: 100% !important;
            }

            #joystick-handle {
                width: 35px !important;
                height: 35px !important;
            }

            #btn-shoot {
                display: flex !important;
                bottom: 50px !important;
                right: 80px !important;
                width: 45px !important;
                height: 45px !important;
            }

            #btn-jump {
                display: flex !important;
                bottom: 20px !important;
                right: 30px !important;
                width: 40px !important;
                height: 40px !important;
            }

            #btn-reload {
                display: flex !important;
                bottom: 80px !important;
                right: 30px !important;
                width: 40px !important;
                height: 40px !important;
            }

            #btn-aim {
                display: flex !important;
                bottom: 20px !important;
                right: 140px !important;
                width: 40px !important;
                height: 40px !important;
            }
        }

        /* 세로 모드 */
        @media (orientation: portrait) and (max-width: 768px) {
            #btn-jump {
                bottom: 15px;
                right: 15px;
            }

            #btn-reload {
                bottom: 15px;
                right: 75px;
            }

            #btn-aim {
                bottom: 15px;
                right: 135px;
            }

            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                top: 8px;
            }

            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
        }

        @media (max-width: 1024px) {
            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }

            .exit-game-btn {
                top: 15px;
                right: 70px;
                width: 45px;
                height: 45px;
            }
        }

        @media (hover: hover) and (pointer: fine) {

            #controls,
            .mobile-btn {
                display: none;
            }
        }

        /* Mobile specific names and chat toggle */
        #mobile-player-name {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            z-index: 20;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
        }

        #chat-toggle-btn {
            display: none;
            position: fixed;
            bottom: 300px;
            /* Adjust based on valid area */
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 101;
            /* Higher than chat container z-index if needed */
            font-size: 20px;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Exit Game Button (Zombie Mode) - Styled like Light Toggle */
        .exit-game-btn {
            position: fixed;
            top: 20px;
            /* Match light toggle fixed position */
            right: 80px;
            /* Consistently spaced */
            width: 50px;
            /* Match light toggle size */
            height: 50px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            /* Controlled by JS */
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
        }

        body.paused #exit-game-btn {
            display: flex !important;
            opacity: 1;
            pointer-events: auto;
        }

        .exit-game-btn:hover {
            background: rgba(244, 67, 54, 0.7);
            transform: scale(1.1);
        }

        /* Desktop/PC - Hide mobile controls */
        @media (min-width: 1025px) {

            .mobile-btn,
            #joystick-zone,
            #weapon-selector-vertical,
            #chat-toggle-btn {
                display: none;
            }
        }

        @media (max-width: 768px) {
            #mobile-player-name {
                display: block;
            }

            body.game-active.multi-player #chat-toggle-btn {
                display: flex;
                /* Force show on mobile during multiplayer gameplay */
            }

            #chat-container {
                /* Initially hidden on mobile or small helper mode */
                display: none;
                /* Managed by JS toggle */
                width: 60%;
                height: 150px;
                /* 모바일에서도 대폭 위로 올려서 조이스틱/HP 바 피함 */
                bottom: 220px;
                left: 10px;
            }

            #chat-container.visible {
                display: flex;
            }

            /* Show icon-based weapon selector on mobile during gameplay */
            body.game-active #weapon-selector-vertical {
                display: flex;
            }

            /* Hide text-based weapon inventory on mobile - FORCE */
            body #weapon-inventory,
            body #weapon-list-left {
                display: none !important;
                visibility: hidden;
                opacity: 0;
            }
        }

        /* Landscape Orientation Fixes for Mobile - Scaled Down Initial Screen */
        @media (orientation: landscape) and (hover: none) and (pointer: coarse) {

            /* Lobby & Create Room compact layout */
            #room-menu h2,
            #create-room-modal h2 {
                font-size: 22px;
                margin-bottom: 16px;
            }

            #room-menu .menu-actions {
                gap: 10px;
                margin-bottom: 10px;
            }

            #room-menu .menu-actions button,
            #create-room-modal button {
                padding: 8px 18px;
                font-size: 14px;
                margin: 6px;
            }

            #room-list-container {
                width: 80%;
                height: 220px;
                padding: 10px;
            }

            .room-item {
                padding: 10px 12px;
                gap: 10px;
            }

            .room-info h3 {
                font-size: 14px;
            }

            .room-info p {
                font-size: 12px;
            }

            .status-badge {
                font-size: 10px;
                padding: 4px 8px;
            }

            #create-room-modal .modal-content {
                min-width: 260px;
                padding: 14px;
                gap: 8px;
                max-height: 85vh;
                overflow-y: auto;
                transform: scale(0.9);
                transform-origin: center;
            }

            #create-room-modal .input-group {
                gap: 4px;
                margin: 6px 0;
            }

            #create-room-modal label {
                font-size: 11px;
            }

            #create-room-modal input[type="text"],
            #create-room-modal select {
                width: 210px;
                padding: 6px 10px;
                font-size: 12px;
            }
        }


        /* Ensure mode selection is visible but compact when game is NOT active */
        body:not(.game-active) #mode-selection {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        /* Scale down logo and buttons when mode selection is shown */
        #mode-selection img {
            max-height: 100px !important;
            max-width: 80% !important;
            margin-bottom: 15px !important;
        }

        .mode-btn {
            padding: 12px 35px !important;
            font-size: 18px !important;
            margin: 8px !important;
            min-width: 200px !important;
        }


        /* Hide text-based weapon inventory in landscape too - FORCE */
        @media (pointer: coarse),
        (hover: none) {

            body #weapon-inventory,
            body #weapon-list-left {
                display: none !important;
                visibility: hidden;
                opacity: 0;
            }
        }

        /* HP/Ammo - 하단으로 배치 */
        #ammo-info {
            top: auto !important;
            bottom: 30px !important;
            right: 20px !important;
        }

        #hp-container {
            top: auto !important;
            bottom: 30px !important;
            left: 20px !important;
        }

        /* Make other UI elements more compact */
        .weapon-slot {
            padding: 6px 10px;
        }

        .weapon-number {
            font-size: 16px;
        }

        .weapon-name {
            font-size: 12px;
        }

        /* Explicitly show weapon selector in landscape during gameplay */
        body.game-active #weapon-selector-vertical {
            display: flex;
            top: 40%;
            /* 중앙보다 약간 위로 (40%) */
            z-index: 1000;
            pointer-events: auto;
        }

        #exit-game-btn {
            top: 15px;
            right: 70px;
            width: 45px;
            height: 45px;
            font-size: 22px;
        }

        /* Force hide mode-selection when game is active */
        body.game-active #create-room-modal,
        body.game-active #room-waiting,
        body.game-active #single-map-selection {
            display: none;
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }

        /* Single Player Map Selection UI */
        #single-map-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #09090b;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-size: 28px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 30px;
        }

        .map-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            width: 200px;
        }

        .map-card:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--neon-cyan);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
        }

        .map-card i {
            font-size: 48px;
            margin-bottom: 15px;
            color: var(--neon-cyan);
        }

        .map-card h3 {
            margin: 0;
            font-size: 20px;
            text-transform: uppercase;
        }

        /* Multiplayer HUD Adjustments */
        @media (min-width: 769px) {
            body.multi-player #chat-container {
                bottom: 20px;
                top: auto;
                left: auto;
                right: 20px;
                /* Move chat to right side */
                width: 320px;
            }

            body.multi-player #weapon-selector-vertical {
                top: 25%;
            }

            /* Move weapon list to top for multiplayer PC */
            body.multi-player.game-active #weapon-list-left {
                top: 20px;
                left: 20px;
                transform: scale(0.7) !important;
                transform-origin: top left !important;
            }

            /* Move ingame players list to TOP RIGHT for PC (Stacked below Exit Button) */
            /* Move ingame players list to TOP RIGHT for PC (Stacked below Exit Button) */
            body.multi-player #ingame-players-list {
                top: 80px !important;
                /* Force below Exit Button */
                left: auto !important;
                right: 20px !important;
                z-index: 1000;
                max-width: 220px;
                /* More compact */
                background: rgba(0, 0, 0, 0.7);
                border: 1px solid rgba(0, 255, 128, 0.3);
                /* Neon green border */
                overflow: hidden;
                display: flex;
                flex-direction: column;
                align-items: flex-end;
            }

            body.multi-player #ingame-players-list>div {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                width: 100%;
                text-align: right;
            }

            /* Move chat to BOTTOM LEFT (Above HP) */
            body.multi-player #chat-container {
                bottom: 140px;
                left: 20px;
                right: auto;
                top: auto;
                width: 320px;
            }

            /* Adjust Exit Game Button position */
            #exit-game-btn {
                top: 20px;
                right: 20px;
                /* Pinned to right corner */
                width: 50px;
                height: 50px;
                z-index: 1001;
                display: flex;
                /* Ensure it's visible when game-active if toggled */
            }
        }

        #ingame-players-list {
            position: fixed;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Rajdhani', sans-serif;
            pointer-events: none;
            z-index: 1000;
        }

        /* --- TASK: Hide Game UI by Default --- */
        /* Initially hide all game HUD/UI elements */
        .hud-container,
        .crosshair,
        #mobile-player-name,
        #chat-toggle-btn,
        #weapon-list-left,
        #controls,
        #light-toggle-btn {
            display: none !important;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        /* Show HUD elements when game is active */
        body.game-active .hud-container {
            display: block !important;
            opacity: 1;
        }

        body.game-active .crosshair {
            display: flex !important;
            opacity: 1;
        }

        /* Hide light toggle in all game modes (user request) */
        body.game-active #light-toggle-btn {
            display: none !important;
        }

        /* Weapon list - visible on all platforms if active */
        body.game-active #weapon-list-left {
            display: flex !important;
            opacity: 1;
            pointer-events: auto;
        }

        /* Mobile specific controls */
        @media (max-width: 1024px) and (pointer: coarse) {
            body.game-active #controls {
                display: flex !important;
                opacity: 1;
            }

            body.game-active #mobile-player-name {
                display: block !important;
                opacity: 1;
            }
        }

        /* Chat toggle - mobile only and respecting multi-player */
        @media (max-width: 768px) {
            body.game-active.multi-player #chat-toggle-btn {
                display: flex !important;
                opacity: 1;
            }
        }

        #shoot-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 0.05s ease-out;
            mix-blend-mode: overlay;
        }

        #reload-overlay {
            position: fixed;
            left: 50%;
            bottom: 28px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.5px;
            display: none;
            z-index: 1001;
            pointer-events: none;
        }

        /* --- USER REQUEST: PC Mode Weapon Icon Scale x3 & Active State --- */
        /* Modified media query to cover smaller PC screens/windowed mode */
        @media (min-width: 800px) {
            body.game-active #weapon-list-left {
                display: flex !important;
                /* Force display */
                transform: translateY(-50%) scale(0.7) !important;
                transform-origin: left center !important;
                left: 20px !important;
                gap: 5px !important;
                z-index: 9999 !important;
                /* Ensure visibility on top */
            }

            .weapon-item .key-hint {
                font-size: 14px;
                width: 20px;
                height: 20px;
                line-height: 20px;
            }

            .weapon-item.active {
                opacity: 1 !important;
                transform: translateX(10px) !important;
            }

            .weapon-item.active .icon-box {
                border: 2px solid var(--neon-cyan) !important;
                background: rgba(0, 243, 255, 0.3) !important;
                box-shadow: 0 0 30px var(--neon-cyan), inset 0 0 10px var(--neon-cyan) !important;
            }

            .weapon-item:not(.active) {
                opacity: 0.3 !important;
                transform: translateX(0) !important;
            }
        }

        /* Tab Scoreboard Overlay Styles */
        #tab-scoreboard {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        #tab-scoreboard-content {
            background: rgba(20, 20, 30, 0.9);
            border: 2px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 30px 40px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
        }

        #tab-scoreboard-content h2 {
            margin: 0 0 20px 0;
            color: var(--neon-cyan);
            font-family: var(--font-stack);
            font-size: 28px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #tab-scoreboard-players {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .scoreboard-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid rgba(255, 255, 255, 0.3);
            font-family: var(--font-stack);
            font-size: 18px;
            transition: all 0.2s;
        }

        .scoreboard-player.you {
            background: rgba(0, 243, 255, 0.15);
            border-left-color: var(--neon-cyan);
        }

        .scoreboard-player-name {
            color: #fff;
            font-weight: 600;
        }

        .scoreboard-player.you .scoreboard-player-name {
            color: var(--neon-cyan);
        }

        .scoreboard-player-kills {
            color: #ffa500;
            font-weight: 700;
            font-size: 20px;
        }
    </style>
</head>

<body>
    <div id="shoot-flash"></div>
    <div id="reload-overlay">RELOADING</div>
    <div id="loading-screen">
        <div class="glitch-wrapper"></div>
    </div>
    <div id="game-container"></div>
    <div id="vignette"></div>
    <div id="damage-overlay"></div>
    <div id="mobile-player-name"></div>
    <button id="chat-toggle-btn"><i class="fas fa-comment"></i></button>
    <div id="scope-overlay">
        <div id="scope-line-h"></div>
        <div id="scope-line-v"></div>
        <div id="scope-dot"></div>
    </div>
    <div id="headshot-msg">HEADSHOT!</div>
    <div id="grenade-kill-msg"
        style="display: none; position: fixed; top: 35%; left: 50%; transform: translate(-50%, -50%); color: #ff6600; font-size: 60px; font-weight: 900; text-shadow: 0 0 20px #ff0000; z-index: 100; pointer-events: none; font-style: italic;">
        GRENADE KILL!</div>
    <div id="hit-marker"></div>

    <!-- Tab Scoreboard Overlay -->
    <div id="tab-scoreboard" style="display: none;">
        <div id="tab-scoreboard-content">
            <h2>플레이어 목록</h2>
            <div id="tab-scoreboard-players"></div>
        </div>
    </div>

    <div id="game-over">
        <div id="game-over-title">YOU DIED</div>
        <div id="game-over-stats">Kills: <span id="final-kill-count">0</span></div>
        <button id="restart-btn" onclick="restartGame()">TRY AGAIN</button>
        <button id="exit-to-menu-btn" onclick="location.reload()">EXIT</button>
    </div>

    <!-- 모드 선택 화면 (Tactical Side Menu) -->
    <!-- 모드 선택 화면 (Tactical Side Menu) -->
    <div id="mode-selection" style="position: relative; z-index: 9999;">
        <div class="menu-title-container">
            <div class="tactical-subtitle">POST-APOCALYPSE SURVIVAL PROTOCOL</div>
        </div>
        <div class="menu-buttons-container">
            <button class="mode-btn" id="btn-single-player">
                <span class="btn-text"><i class="fas fa-user-shield btn-icon"></i>혼자하기 (SINGLE)</span>
            </button>
            <button class="mode-btn" id="btn-multi-player">
                <span class="btn-text"><i class="fas fa-users-rays btn-icon"></i>함께하기 (MULTI)</span>
            </button>
        </div>
    </div>

    <!-- 싱글 플레이어 맵 선택 화면 -->
    <div id="single-map-selection" style="display: none;">
        <div class="tactical-panel">
            <div class="tactical-title"><i class="fas fa-map-location-dot"></i> 맵 선택 (AO SELECTION)</div>
            <div class="map-grid">
                <div class="map-card" data-map="factory">
                    <i class="fas fa-industry"></i>
                    <h3>창고 (FACTORY)</h3>
                </div>
                <div class="map-card" data-map="hotel">
                    <i class="fas fa-hotel"></i>
                    <h3>호텔 (HOTEL)</h3>
                </div>
                <div class="map-card" data-map="test">
                    <i class="fas fa-vial"></i>
                    <h3>C-Map (TEST)</h3>
                </div>
                <div class="map-card" data-map="bridge">
                    <i class="fas fa-road"></i>
                    <h3>다리 (BRIDGE)</h3>
                </div>
            </div>
            <div style="display: flex; justify-content: center;">
                <button class="mode-btn cancel" id="btn-back-to-mode-from-map">
                    <span class="btn-text"><i class="fas fa-arrow-left btn-icon"></i>뒤로가기</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 1. 이름 설정 화면 -->
    <div id="name-setup" style="display: none;">
        <div class="tactical-panel">
            <div class="tactical-title"><i class="fas fa-user-tag"></i> 신원 확인 (IDENTITY)</div>
            <div class="tactical-input-group">
                <label>플레이어 닉네임</label>
                <input type="text" id="player-name-input" class="tactical-input" placeholder="닉네임을 입력하세요"
                    maxlength="10">
            </div>
            <div style="display: flex; gap: 20px;">
                <button id="btn-single-player" class="mode-btn" onclick="selectSinglePlayer()">
                    <span class="btn-text">
                        <i class="fas fa-user mb-2" style="font-size: 24px; display: block;"></i>
                        혼자하기 (SINGLE OPS)
                    </span>
                </button>
                <button id="btn-multi-player" class="mode-btn" onclick="selectMultiPlayer()">
                    <span class="btn-text">
                        <i class="fas fa-users mb-2" style="font-size: 24px; display: block;"></i>
                        함께하기 (JOINT OPS)
                    </span>
                </button>
            </div>
        </div>
    </div>

    <!-- 2. 방 목록/메뉴 화면 -->
    <div id="room-menu" style="display: none;">
        <div class="tactical-panel" style="width: 800px;">
            <div class="tactical-title"><i class="fas fa-list"></i> 작전 로비 (OPERATION LOBBY)</div>
            <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                <button id="btn-show-create-room" class="mode-btn" style="min-width: 200px; font-size: 18px;"
                    onclick="openCreateRoomModal()">
                    <span class="btn-text"><i class="fas fa-plus-circle btn-icon"></i>작전 생성</span>
                </button>
                <button id="btn-refresh-rooms" class="mode-btn" style="min-width: 200px; font-size: 18px;">
                    <span class="btn-text"><i class="fas fa-sync-alt btn-icon"></i>목록 갱신</span>
                </button>
                <button class="mode-btn cancel" id="btn-back-to-mode-from-room"
                    style="min-width: 200px; font-size: 18px;">
                    <span class="btn-text"><i class="fas fa-arrow-left btn-icon"></i>복귀</span>
                </button>
            </div>
            <div id="room-list-container">
                <div class="no-rooms-message" style="text-align: center; padding: 50px; opacity: 0.5;">진행 중인 작전이 없습니다.
                </div>
            </div>
        </div>
    </div>

    <!-- 3. 방 생성 모달 -->
    <div id="create-room-modal" style="display: none;">
        <div class="tactical-panel" style="width: 500px;">
            <div class="tactical-title"><i class="fas fa-door-open"></i> 작전 수립 (MISSION PLAN)</div>
            <div class="tactical-input-group">
                <label>작전명 (OP NAME)</label>
                <input type="text" id="new-room-name" class="tactical-input" placeholder="작전명을 입력하세요">
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div class="tactical-input-group">
                    <label>최대 인원 (CAPACITY)</label>
                    <select id="new-room-max" class="tactical-input">
                        <option value="2">02 UNIT</option>
                        <option value="4" selected>04 UNIT</option>
                        <option value="8">08 UNIT</option>
                    </select>
                </div>
                <div class="tactical-input-group">
                    <label>전투 모드 (MODE)</label>
                    <select id="new-room-mode" class="tactical-input">
                        <option value="ffa" selected>FREE FOR ALL</option>
                        <option value="tdm">TEAM DEATHMATCH</option>
                    </select>
                </div>
            </div>
            <div class="tactical-input-group">
                <label>작전 지역 (AO)</label>
                <select id="new-room-map" class="tactical-input">
                    <option value="factory" selected>팩토리 (FACTORY)</option>
                    <option value="hotel">호텔 (HOTEL)</option>
                    <option value="test">테스트 구역 (TEST)</option>
                </select>
            </div>
            <div style="display: flex; gap: 20px; margin-top: 20px;">
                <button id="btn-create-confirm" class="mode-btn" onclick="confirmCreateRoom()">
                    <span class="btn-text"><i class="fas fa-check btn-icon"></i>생성</span>
                </button>
                <button class="mode-btn cancel" id="btn-create-cancel" onclick="closeCreateRoomModal()">
                    <span class="btn-text"><i class="fas fa-times btn-icon"></i>취소</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Start Countdown Overlay -->
    <div id="countdown"
        style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.8), 0 0 40px rgba(255,255,255,0.5); font-weight: bold; z-index: 9999; pointer-events: none;">
    </div>

    <!-- 4. 대기실 화면 -->
    <div id="room-waiting" style="display: none;">
        <div class="tactical-panel" style="width: 600px;">
            <div class="tactical-title"><i class="fas fa-satellite-dish"></i> 브리핑 룸 (BRIEFING)</div>
            <div style="display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 20px;">
                <div>
                    <h2 id="room-title" style="margin: 0; color: white;">작전명</h2>
                    <div id="room-info" style="color: var(--tactical-cyan); font-size: 14px; margin-top: 5px;">
                        <i class="fas fa-users"></i> 적합성 확인 중: <span id="player-count">0/0</span>
                    </div>
                </div>
            </div>

            <div id="players-list"
                style="background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); padding: 15px; min-height: 150px; margin-bottom: 30px;">
            </div>

            <div class="host-controls" style="display: none; margin-bottom: 15px;">
                <button id="btn-start-game" class="mode-btn" style="width: 100%;">
                    <span class="btn-text"><i class="fas fa-play btn-icon"></i>작전 개시 (START)</span>
                </button>
            </div>

            <button class="mode-btn cancel" id="btn-leave-room" style="width: 100%;">
                <span class="btn-text"><i class="fas fa-sign-out-alt btn-icon"></i>로그아웃 (LEAVE)</span>
            </button>
        </div>
    </div>

    <!-- 인게임 채팅 -->
    <div id="chat-container" style="display: none;">
        <div id="chat-messages"></div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="메시지 입력 (Enter)" autocomplete="off">
            <button id="btn-send-chat"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <div class="hud-container">
        <!-- Top Center: Match Status -->
        <div class="scoreboard-mini">
            <div class="score ally" id="hud-score-ally">0</div>
            <div class="timer" id="hud-timer">10:00</div>
            <div class="score enemy" id="hud-score-enemy">0</div>
            <div id="hud-kill-count">Kills: 0</div>
        </div>

        <!-- Top Right: Kill Feed -->
        <div class="kill-feed" id="hud-kill-feed"></div>

        <!-- Center: Dynamic Crosshair -->
        <div class="crosshair" id="hud-crosshair">
            <div class="hair top"></div>
            <div class="hair bottom"></div>
            <div class="hair left"></div>
            <div class="hair right"></div>
            <div class="dot"></div>
        </div>

        <!-- Bottom Left: Vitals -->
        <div class="vitals-panel" id="hud-vitals">
            <div class="value-group">
                <span class="label">HP</span>
                <span class="value health-text" id="hud-hp-text">100</span>
            </div>
            <div class="bar-container">
                <div class="health-bar" id="hud-hp-bar" style="width: 100%;"></div>
                <div class="health-bar-ghost" id="hud-hp-bar-ghost" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Bottom Right: Weapon & Ammo -->
        <div class="weapon-panel" id="hud-weapon">
            <div class="weapon-selector" id="hud-weapon-selector">
                <div class="weapon-slot" data-slot="0">1</div>
                <div class="weapon-slot" data-slot="1">2</div>
                <div class="weapon-slot" data-slot="2">3</div>
                <div class="weapon-slot" data-slot="3">4</div>
                <div class="weapon-slot" data-slot="4">5</div>
            </div>
            <div class="ammo-group">
                <span class="ammo-current" id="hud-ammo-current">30</span>
                <span class="ammo-reserve" id="hud-ammo-reserve">/ 120</span>
            </div>
            <div class="weapon-name" id="hud-weapon-name"
                style="font-size: 1rem; color: #facc15; margin-top:5px; transform: skewX(10deg);">RIFLE</div>
        </div>

        <!-- Damage Overlay (Vignette) -->
        <div class="damage-vignette" id="hud-damage-vignette"></div>
    </div>


    <!-- 나가기 버튼 (좀비모드) -->
    <button id="exit-game-btn" class="exit-game-btn" title="게임 나가기" style="display: none;">🚪</button>

    <!-- 인게임 플레이어 리스트 (스코어보드) -->
    <div id="ingame-players-list" style="display: none;">
        <div
            style="font-weight: bold; border-bottom: 1px solid rgba(255,255,255,0.3); margin-bottom: 5px; padding-bottom: 2px;">
            PLAYERS</div>
        <div id="ingame-players-content"></div>
    </div>

    <!-- 조명 토글 버튼 -->
    <button id="light-toggle-btn" class="light-toggle-btn" title="조명 켜기/끄기">💡</button>

    <div id="controls">
        <div id="touch-left"></div>
        <div id="touch-right"></div>
    </div>

    <!-- 모바일 컨트롤 -->
    <button class="mobile-btn" id="btn-weapon1">1</button>

    <!-- 모바일 세로모드 전용 무기 교체 UI (숫자 없이 아이콘만) -->
    <div id="weapon-selector-vertical">
        <div class="weapon-select-btn" data-idx="0"><i class="fas fa-person-rifle"></i></div>
        <div class="weapon-select-btn" data-idx="1"><i class="fas fa-gun"></i></div>
        <div class="weapon-select-btn" data-idx="2"><i class="fas fa-crosshairs"></i></div>
        <div class="weapon-select-btn" data-idx="3"><i class="fas fa-gavel"></i></div>
        <div class="weapon-select-btn" data-idx="4"><i class="fas fa-bomb"></i></div>
    </div>

    <!-- 모바일 컨트롤 (Krunker 스타일 클러스터) -->
    <div id="joystick-zone">
        <div id="joystick-bg"></div>
        <div id="joystick-handle"></div>
    </div>


    <!-- Left Side: Vertical Weapon List -->
    <div id="weapon-list-left">
        <div class="weapon-item active" id="weapon-item-0">
            <div class="key-hint">1</div>
            <div class="icon-box"><i class="fas fa-person-rifle"></i></div>
        </div>
        <div class="weapon-item" id="weapon-item-1">
            <div class="key-hint">2</div>
            <div class="icon-box"><i class="fas fa-gun"></i></div>
        </div>
        <div class="weapon-item" id="weapon-item-2">
            <div class="key-hint">3</div>
            <div class="icon-box"><i class="fas fa-crosshairs"></i></div>
        </div>
        <div class="weapon-item" id="weapon-item-3">
            <div class="key-hint">4</div>
            <div class="icon-box"><i class="fas fa-gavel"></i></div>
        </div>
        <div class="weapon-item" id="weapon-item-4">
            <div class="key-hint">5</div>
            <div class="icon-box"><i class="fas fa-bomb"></i></div>
        </div>
    </div>


    <button class="mobile-btn" id="btn-shoot"><i class="fas fa-crosshairs"></i></button>
    <button class="mobile-btn" id="btn-aim"><i class="fas fa-eye"></i></button>
    <button class="mobile-btn" id="btn-jump"><i class="fas fa-chevron-up"></i></button>
    <button class="mobile-btn" id="btn-reload"><i class="fas fa-redo"></i></button>

    <!-- Pause Overlay (Menu) -->
    <div id="pause-overlay" style="display:none;">
        <h1>PAUSE</h1>
        <p>Click to Continue</p>

        <!-- Sensitivity Control (Inside Pause Menu) -->
        <div id="sensitivity-control">
            <label for="sensitivity-slider">Mouse Sensitivity:</label>
            <input type="range" id="sensitivity-slider" min="0.0005" max="0.01" step="0.0001" value="0.002">
            <span id="sensitivity-value">1.00</span>
        </div>

        <!-- Volume Control -->
        <div id="volume-control">
            <label for="volume-slider">Master Volume:</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
            <span id="volume-value">50%</span>
        </div>
    </div>

    <!-- Death Overlay (Multiplayer) -->
    <div id="death-overlay">
        <div id="respawn-timer">10</div>
        <div id="killed-by-label">Killed by</div>
        <div id="killer-name">Unknown</div>
        <button id="manual-respawn-btn"
            style="display: none; margin-top: 20px; padding: 10px 20px; font-size: 24px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">RESPAWN
            NOW</button>
    </div>

    <!-- Sniper Scope Overlay -->
    <div id="sniper-scope">
        <div id="scope-circle">
            <div class="scope-crosshair-h"></div>
            <div class="scope-crosshair-v"></div>
            <div class="scope-center-dot"></div>
        </div>
    </div>

    <!-- Rifle GLB Debug Panel -->
    <div id="rifle-debug-panel">
        <div class="panel-title">Rifle GLB</div>
        <div class="panel-row">
            <label for="rifle-x">X</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-x" data-dir="-1">-</button>
                <input id="rifle-x" type="range" min="-1" max="1" step="0.01" value="0.2">
                <button class="nudge-btn" type="button" data-target="rifle-x" data-dir="1">+</button>
            </div>
            <span id="rifle-x-val">0.20</span>
        </div>
        <div class="panel-row">
            <label for="rifle-x-step">XS</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-x-step" data-dir="-1">-</button>
                <input id="rifle-x-step" type="range" min="0.001" max="0.05" step="0.001" value="0.01">
                <button class="nudge-btn" type="button" data-target="rifle-x-step" data-dir="1">+</button>
            </div>
            <span id="rifle-x-step-val">0.010</span>
        </div>
        <div class="panel-row">
            <label for="rifle-x-nudge">X±</label>
            <div style="display:flex;gap:6px;align-items:center;justify-content:center;width:100%">
                <button id="rifle-x-minus" type="button">-</button>
                <button id="rifle-x-plus" type="button">+</button>
            </div>
            <span id="rifle-x-nudge-val">0.01</span>
        </div>
        <div class="panel-row">
            <label for="rifle-y">Y</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-y" data-dir="-1">-</button>
                <input id="rifle-y" type="range" min="-1" max="1" step="0.01" value="-0.2">
                <button class="nudge-btn" type="button" data-target="rifle-y" data-dir="1">+</button>
            </div>
            <span id="rifle-y-val">-0.20</span>
        </div>
        <div class="panel-row">
            <label for="rifle-z">Z</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-z" data-dir="-1">-</button>
                <input id="rifle-z" type="range" min="-1" max="1" step="0.01" value="0.44">
                <button class="nudge-btn" type="button" data-target="rifle-z" data-dir="1">+</button>
            </div>
            <span id="rifle-z-val">0.44</span>
        </div>
        <div class="panel-row">
            <label for="rifle-scale">S</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-scale" data-dir="-1">-</button>
                <input id="rifle-scale" type="range" min="0.05" max="0.5" step="0.01" value="0.50">
                <button class="nudge-btn" type="button" data-target="rifle-scale" data-dir="1">+</button>
            </div>
            <span id="rifle-scale-val">0.50</span>
        </div>
        <div class="panel-row">
            <label for="rifle-rx">RX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-rx" data-dir="-1">-</button>
                <input id="rifle-rx" type="range" min="-3.14" max="3.14" step="0.01" value="0.43">
                <button class="nudge-btn" type="button" data-target="rifle-rx" data-dir="1">+</button>
            </div>
            <span id="rifle-rx-val">0.43</span>
        </div>
        <div class="panel-row">
            <label for="rifle-ry">RY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-ry" data-dir="-1">-</button>
                <input id="rifle-ry" type="range" min="-3.14" max="3.14" step="0.01" value="1.69">
                <button class="nudge-btn" type="button" data-target="rifle-ry" data-dir="1">+</button>
            </div>
            <span id="rifle-ry-val">1.69</span>
        </div>
        <div class="panel-row">
            <label for="rifle-rz">RZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-rz" data-dir="-1">-</button>
                <input id="rifle-rz" type="range" min="-3.14" max="3.14" step="0.01" value="-0.25">
                <button class="nudge-btn" type="button" data-target="rifle-rz" data-dir="1">+</button>
            </div>
            <span id="rifle-rz-val">-0.25</span>
        </div>
        <div class="panel-row">
            <label for="rifle-mx">MX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-mx" data-dir="-1">-</button>
                <input id="rifle-mx" type="range" min="-0.5" max="0.5" step="0.001" value="0">
                <button class="nudge-btn" type="button" data-target="rifle-mx" data-dir="1">+</button>
            </div>
            <span id="rifle-mx-val">0.000</span>
        </div>
        <div class="panel-row">
            <label for="rifle-my">MY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-my" data-dir="-1">-</button>
                <input id="rifle-my" type="range" min="-0.5" max="0.5" step="0.001" value="0.055">
                <button class="nudge-btn" type="button" data-target="rifle-my" data-dir="1">+</button>
            </div>
            <span id="rifle-my-val">0.055</span>
        </div>
        <div class="panel-row">
            <label for="rifle-mz">MZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-mz" data-dir="-1">-</button>
                <input id="rifle-mz" type="range" min="-1.5" max="0.3" step="0.005" value="-0.65">
                <button class="nudge-btn" type="button" data-target="rifle-mz" data-dir="1">+</button>
            </div>
            <span id="rifle-mz-val">-0.65</span>
        </div>
        <div style="border-top:1px solid #444; margin:8px 0; padding-top:8px; color:#ff9e9e">Left Arm (LA)</div>
        <div class="panel-row">
            <label for="rifle-lax">LAX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-lax" data-dir="-1">-</button>
                <input id="rifle-lax" type="range" min="-1" max="1" step="0.01" value="-0.05">
                <button class="nudge-btn" type="button" data-target="rifle-lax" data-dir="1">+</button>
            </div>
            <span id="rifle-lax-val">-0.05</span>
        </div>
        <div class="panel-row">
            <label for="rifle-lay">LAY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-lay" data-dir="-1">-</button>
                <input id="rifle-lay" type="range" min="-1" max="1" step="0.01" value="-0.25">
                <button class="nudge-btn" type="button" data-target="rifle-lay" data-dir="1">+</button>
            </div>
            <span id="rifle-lay-val">-0.25</span>
        </div>
        <div class="panel-row">
            <label for="rifle-laz">LAZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-laz" data-dir="-1">-</button>
                <input id="rifle-laz" type="range" min="-1.5" max="1" step="0.01" value="-0.44">
                <button class="nudge-btn" type="button" data-target="rifle-laz" data-dir="1">+</button>
            </div>
            <span id="rifle-laz-val">-0.44</span>
        </div>
        <div class="panel-row">
            <label for="rifle-larx">LARX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-larx" data-dir="-1">-</button>
                <input id="rifle-larx" type="range" min="-3.14" max="3.14" step="0.02" value="0.54">
                <button class="nudge-btn" type="button" data-target="rifle-larx" data-dir="1">+</button>
            </div>
            <span id="rifle-larx-val">0.54</span>
        </div>
        <div class="panel-row">
            <label for="rifle-lary">LARY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-lary" data-dir="-1">-</button>
                <input id="rifle-lary" type="range" min="-3.14" max="3.14" step="0.02" value="-0.82">
                <button class="nudge-btn" type="button" data-target="rifle-lary" data-dir="1">+</button>
            </div>
            <span id="rifle-lary-val">-0.82</span>
        </div>
        <div class="panel-row">
            <label for="rifle-larz">LARZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="rifle-larz" data-dir="-1">-</button>
                <input id="rifle-larz" type="range" min="-3.14" max="3.14" step="0.02" value="0.60">
                <button class="nudge-btn" type="button" data-target="rifle-larz" data-dir="1">+</button>
            </div>
            <span id="rifle-larz-val">0.60</span>
        </div>
        <button id="rifle-copy" style="width:100%;margin-top:6px;">Copy values</button>
    </div>

    <!-- Pistol GLB Debug Panel -->
    <div id="pistol-debug-panel">
        <div class="panel-title">Pistol GLB</div>
        <div class="panel-row">
            <label for="pistol-x">X</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-x" data-dir="-1">-</button>
                <input id="pistol-x" type="range" min="-1" max="1" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="pistol-x" data-dir="1">+</button>
            </div>
            <span id="pistol-x-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="pistol-x-step">XS</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-x-step" data-dir="-1">-</button>
                <input id="pistol-x-step" type="range" min="0.001" max="0.05" step="0.001" value="0.01">
                <button class="nudge-btn" type="button" data-target="pistol-x-step" data-dir="1">+</button>
            </div>
            <span id="pistol-x-step-val">0.010</span>
        </div>
        <div class="panel-row">
            <label for="pistol-x-nudge">X±</label>
            <div style="display:flex;gap:6px;align-items:center;justify-content:center;width:100%">
                <button id="pistol-x-minus" type="button">-</button>
                <button id="pistol-x-plus" type="button">+</button>
            </div>
            <span id="pistol-x-nudge-val">0.01</span>
        </div>
        <div class="panel-row">
            <label for="pistol-y">Y</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-y" data-dir="-1">-</button>
                <input id="pistol-y" type="range" min="-1" max="1" step="0.01" value="-0.05">
                <button class="nudge-btn" type="button" data-target="pistol-y" data-dir="1">+</button>
            </div>
            <span id="pistol-y-val">-0.05</span>
        </div>
        <div class="panel-row">
            <label for="pistol-z">Z</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-z" data-dir="-1">-</button>
                <input id="pistol-z" type="range" min="-1" max="1" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="pistol-z" data-dir="1">+</button>
            </div>
            <span id="pistol-z-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="pistol-scale">S</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-scale" data-dir="-1">-</button>
                <input id="pistol-scale" type="range" min="0.01" max="0.5" step="0.01" value="0.15">
                <button class="nudge-btn" type="button" data-target="pistol-scale" data-dir="1">+</button>
            </div>
            <span id="pistol-scale-val">0.15</span>
        </div>
        <div class="panel-row">
            <label for="pistol-rx">RX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-rx" data-dir="-1">-</button>
                <input id="pistol-rx" type="range" min="-3.14" max="3.14" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="pistol-rx" data-dir="1">+</button>
            </div>
            <span id="pistol-rx-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="pistol-ry">RY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-ry" data-dir="-1">-</button>
                <input id="pistol-ry" type="range" min="-3.14" max="6.28" step="0.01" value="3.14">
                <button class="nudge-btn" type="button" data-target="pistol-ry" data-dir="1">+</button>
            </div>
            <span id="pistol-ry-val">3.14</span>
        </div>
        <div class="panel-row">
            <label for="pistol-rz">RZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-rz" data-dir="-1">-</button>
                <input id="pistol-rz" type="range" min="-3.14" max="3.14" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="pistol-rz" data-dir="1">+</button>
            </div>
            <span id="pistol-rz-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="pistol-mx">MX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-mx" data-dir="-1">-</button>
                <input id="pistol-mx" type="range" min="-0.5" max="0.5" step="0.001" value="-0.066">
                <button class="nudge-btn" type="button" data-target="pistol-mx" data-dir="1">+</button>
            </div>
            <span id="pistol-mx-val">-0.066</span>
        </div>
        <div class="panel-row">
            <label for="pistol-my">MY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-my" data-dir="-1">-</button>
                <input id="pistol-my" type="range" min="-0.5" max="0.5" step="0.001" value="0.190">
                <button class="nudge-btn" type="button" data-target="pistol-my" data-dir="1">+</button>
            </div>
            <span id="pistol-my-val">0.190</span>
        </div>
        <div class="panel-row">
            <label for="pistol-mz">MZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="pistol-mz" data-dir="-1">-</button>
                <input id="pistol-mz" type="range" min="-1" max="0" step="0.001" value="-0.199">
                <button class="nudge-btn" type="button" data-target="pistol-mz" data-dir="1">+</button>
            </div>
            <span id="pistol-mz-val">-0.199</span>
        </div>
        <button id="pistol-copy" style="width:100%;margin-top:6px;">Copy values</button>
    </div>

    <!-- Sniper GLB Debug Panel -->
    <div id="sniper-debug-panel">
        <div class="panel-title">Sniper GLB</div>
        <div class="panel-row">
            <label for="sniper-x">X</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-x" data-dir="-1">-</button>
                <input id="sniper-x" type="range" min="-5" max="5" step="0.01" value="0.15">
                <button class="nudge-btn" type="button" data-target="sniper-x" data-dir="1">+</button>
            </div>
            <span id="sniper-x-val">0.15</span>
        </div>
        <div class="panel-row">
            <label for="sniper-x-step">XS</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-x-step" data-dir="-1">-</button>
                <input id="sniper-x-step" type="range" min="0.001" max="0.05" step="0.001" value="0.01">
                <button class="nudge-btn" type="button" data-target="sniper-x-step" data-dir="1">+</button>
            </div>
            <span id="sniper-x-step-val">0.010</span>
        </div>
        <div class="panel-row">
            <label for="sniper-x-nudge">X±</label>
            <div style="display:flex;gap:6px;align-items:center;justify-content:center;width:100%">
                <button id="sniper-x-minus" type="button">-</button>
                <button id="sniper-x-plus" type="button">+</button>
            </div>
            <span id="sniper-x-nudge-val">0.01</span>
        </div>
        <div class="panel-row">
            <label for="sniper-y">Y</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-y" data-dir="-1">-</button>
                <input id="sniper-y" type="range" min="-5" max="5" step="0.01" value="-0.3">
                <button class="nudge-btn" type="button" data-target="sniper-y" data-dir="1">+</button>
            </div>
            <span id="sniper-y-val">-0.30</span>
        </div>
        <div class="panel-row">
            <label for="sniper-z">Z</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-z" data-dir="-1">-</button>
                <input id="sniper-z" type="range" min="-5" max="5" step="0.01" value="1.0">
                <button class="nudge-btn" type="button" data-target="sniper-z" data-dir="1">+</button>
            </div>
            <span id="sniper-z-val">1.00</span>
        </div>
        <div class="panel-row">
            <label for="sniper-scale">S</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-scale" data-dir="-1">-</button>
                <input id="sniper-scale" type="range" min="0.01" max="10" step="0.01" value="0.2">
                <button class="nudge-btn" type="button" data-target="sniper-scale" data-dir="1">+</button>
            </div>
            <span id="sniper-scale-val">0.20</span>
        </div>
        <div class="panel-row">
            <label for="sniper-rx">RX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-rx" data-dir="-1">-</button>
                <input id="sniper-rx" type="range" min="-3.14" max="3.14" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="sniper-rx" data-dir="1">+</button>
            </div>
            <span id="sniper-rx-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="sniper-ry">RY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-ry" data-dir="-1">-</button>
                <input id="sniper-ry" type="range" min="-3.14" max="6.28" step="0.01" value="3.14">
                <button class="nudge-btn" type="button" data-target="sniper-ry" data-dir="1">+</button>
            </div>
            <span id="sniper-ry-val">3.14</span>
        </div>
        <div class="panel-row">
            <label for="sniper-rz">RZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-rz" data-dir="-1">-</button>
                <input id="sniper-rz" type="range" min="-3.14" max="3.14" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="sniper-rz" data-dir="1">+</button>
            </div>
            <span id="sniper-rz-val">0.00</span>
        </div>
        <div class="panel-row">
            <label for="sniper-mx">MX</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-mx" data-dir="-1">-</button>
                <input id="sniper-mx" type="range" min="-0.5" max="0.5" step="0.001" value="0">
                <button class="nudge-btn" type="button" data-target="sniper-mx" data-dir="1">+</button>
            </div>
            <span id="sniper-mx-val">0.000</span>
        </div>
        <div class="panel-row">
            <label for="sniper-my">MY</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-my" data-dir="-1">-</button>
                <input id="sniper-my" type="range" min="-0.5" max="0.5" step="0.001" value="0">
                <button class="nudge-btn" type="button" data-target="sniper-my" data-dir="1">+</button>
            </div>
            <span id="sniper-my-val">0.000</span>
        </div>
        <div class="panel-row">
            <label for="sniper-mz">MZ</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="sniper-mz" data-dir="-1">-</button>
                <input id="sniper-mz" type="range" min="-1.5" max="0" step="0.001" value="-0.85">
                <button class="nudge-btn" type="button" data-target="sniper-mz" data-dir="1">+</button>
            </div>
            <span id="sniper-mz-val">-0.850</span>
        </div>
        <div class="arms-flex-container">
            <div class="arm-column">
                <div class="section-title" style="color:#ff9e9e">Left Arm (LA)</div>
                <div class="panel-row">
                    <label for="sniper-lax">LAX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-lax" data-dir="-1">-</button>
                        <input id="sniper-lax" type="range" min="-1" max="1" step="0.01" value="0.01">
                        <button class="nudge-btn" type="button" data-target="sniper-lax" data-dir="1">+</button>
                    </div>
                    <span id="sniper-lax-val">0.01</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-lay">LAY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-lay" data-dir="-1">-</button>
                        <input id="sniper-lay" type="range" min="-1" max="1" step="0.01" value="-0.24">
                        <button class="nudge-btn" type="button" data-target="sniper-lay" data-dir="1">+</button>
                    </div>
                    <span id="sniper-lay-val">-0.24</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-laz">LAZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-laz" data-dir="-1">-</button>
                        <input id="sniper-laz" type="range" min="-2" max="1" step="0.01" value="-0.60">
                        <button class="nudge-btn" type="button" data-target="sniper-laz" data-dir="1">+</button>
                    </div>
                    <span id="sniper-laz-val">-0.60</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-larx">LARX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-larx" data-dir="-1">-</button>
                        <input id="sniper-larx" type="range" min="-3.14" max="3.14" step="0.02" value="0.72">
                        <button class="nudge-btn" type="button" data-target="sniper-larx" data-dir="1">+</button>
                    </div>
                    <span id="sniper-larx-val">0.72</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-lary">LARY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-lary" data-dir="-1">-</button>
                        <input id="sniper-lary" type="range" min="-3.14" max="3.14" step="0.02" value="-0.76">
                        <button class="nudge-btn" type="button" data-target="sniper-lary" data-dir="1">+</button>
                    </div>
                    <span id="sniper-lary-val">-0.76</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-larz">LARZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-larz" data-dir="-1">-</button>
                        <input id="sniper-larz" type="range" min="-3.14" max="3.14" step="0.02" value="-0.02">
                        <button class="nudge-btn" type="button" data-target="sniper-larz" data-dir="1">+</button>
                    </div>
                    <span id="sniper-larz-val">-0.02</span>
                </div>
            </div>
            <div class="arm-column">
                <div class="section-title" style="color:#9eff9e">Right Arm (RA)</div>
                <div class="panel-row">
                    <label for="sniper-rax">RAX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-rax" data-dir="-1">-</button>
                        <input id="sniper-rax" type="range" min="-1" max="1" step="0.01" value="0.15">
                        <button class="nudge-btn" type="button" data-target="sniper-rax" data-dir="1">+</button>
                    </div>
                    <span id="sniper-rax-val">0.15</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-ray">RAY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-ray" data-dir="-1">-</button>
                        <input id="sniper-ray" type="range" min="-1" max="1" step="0.01" value="-0.17">
                        <button class="nudge-btn" type="button" data-target="sniper-ray" data-dir="1">+</button>
                    </div>
                    <span id="sniper-ray-val">-0.17</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-raz">RAZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-raz" data-dir="-1">-</button>
                        <input id="sniper-raz" type="range" min="-1" max="1" step="0.01" value="0.08">
                        <button class="nudge-btn" type="button" data-target="sniper-raz" data-dir="1">+</button>
                    </div>
                    <span id="sniper-raz-val">0.08</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-rarx">RARX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-rarx" data-dir="-1">-</button>
                        <input id="sniper-rarx" type="range" min="-3.14" max="3.14" step="0.02" value="-0.02">
                        <button class="nudge-btn" type="button" data-target="sniper-rarx" data-dir="1">+</button>
                    </div>
                    <span id="sniper-rarx-val">-0.02</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-rary">RARY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-rary" data-dir="-1">-</button>
                        <input id="sniper-rary" type="range" min="-3.14" max="3.14" step="0.02" value="0.02">
                        <button class="nudge-btn" type="button" data-target="sniper-rary" data-dir="1">+</button>
                    </div>
                    <span id="sniper-rary-val">0.02</span>
                </div>
                <div class="panel-row">
                    <label for="sniper-rarz">RARZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="sniper-rarz" data-dir="-1">-</button>
                        <input id="sniper-rarz" type="range" min="-3.14" max="3.14" step="0.02" value="0.58">
                        <button class="nudge-btn" type="button" data-target="sniper-rarz" data-dir="1">+</button>
                    </div>
                    <span id="sniper-rarz-val">0.58</span>
                </div>
            </div>
        </div>
        <button id="sniper-copy" style="width:100%;margin-top:6px;">Copy values</button>
    </div>

    <div id="knife-debug-panel">
        <div class="panel-title">Knife GLB/Arm Adjustment</div>

        <div class="panel-row">
            <label for="knife-x">X</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-x" data-dir="-1">-</button>
                <input id="knife-x" type="range" min="-1" max="1" step="0.01" value="0">
                <button class="nudge-btn" type="button" data-target="knife-x" data-dir="1">+</button>
            </div>
            <span id="knife-x-val">0</span>
        </div>
        <div class="panel-row">
            <label for="knife-y">Y</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-y" data-dir="-1">-</button>
                <input id="knife-y" type="range" min="-1" max="1" step="0.01" value="-0.2">
                <button class="nudge-btn" type="button" data-target="knife-y" data-dir="1">+</button>
            </div>
            <span id="knife-y-val">-0.2</span>
        </div>
        <div class="panel-row">
            <label for="knife-z">Z</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-z" data-dir="-1">-</button>
                <input id="knife-z" type="range" min="-2" max="1" step="0.01" value="-0.5">
                <button class="nudge-btn" type="button" data-target="knife-z" data-dir="1">+</button>
            </div>
            <span id="knife-z-val">-0.5</span>
        </div>
        <div class="panel-row">
            <label for="knife-rx">Rot X</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-rx" data-dir="-1">-</button>
                <input id="knife-rx" type="range" min="-3.14" max="3.14" step="0.02" value="0.1">
                <button class="nudge-btn" type="button" data-target="knife-rx" data-dir="1">+</button>
            </div>
            <span id="knife-rx-val">0.1</span>
        </div>
        <div class="panel-row">
            <label for="knife-ry">Rot Y</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-ry" data-dir="-1">-</button>
                <input id="knife-ry" type="range" min="-3.14" max="3.14" step="0.02" value="1.8">
                <button class="nudge-btn" type="button" data-target="knife-ry" data-dir="1">+</button>
            </div>
            <span id="knife-ry-val">1.8</span>
        </div>
        <div class="panel-row">
            <label for="knife-rz">Rot Z</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-rz" data-dir="-1">-</button>
                <input id="knife-rz" type="range" min="-3.14" max="3.14" step="0.02" value="-0.2">
                <button class="nudge-btn" type="button" data-target="knife-rz" data-dir="1">+</button>
            </div>
            <span id="knife-rz-val">-0.2</span>
        </div>
        <div class="panel-row">
            <label for="knife-scale">S</label>
            <div class="slider-group">
                <button class="nudge-btn" type="button" data-target="knife-scale" data-dir="-1">-</button>
                <input id="knife-scale" type="range" min="0.1" max="5" step="0.05" value="2.5">
                <button class="nudge-btn" type="button" data-target="knife-scale" data-dir="1">+</button>
            </div>
            <span id="knife-scale-val">2.5</span>
        </div>

        <div class="arms-flex-container">
            <!-- Left Arm Column -->
            <div class="arm-column">
                <div class="section-title" style="color:#ff9e9e">Left Arm (LA)</div>
                <div class="panel-row">
                    <label for="knife-lax">LAX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-lax" data-dir="-1">-</button>
                        <input id="knife-lax" type="range" min="-3" max="1" step="0.01" value="-1.2">
                        <button class="nudge-btn" type="button" data-target="knife-lax" data-dir="1">+</button>
                    </div>
                    <span id="knife-lax-val">-1.2</span>
                </div>
                <div class="panel-row">
                    <label for="knife-lay">LAY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-lay" data-dir="-1">-</button>
                        <input id="knife-lay" type="range" min="-2" max="1" step="0.01" value="-0.35">
                        <button class="nudge-btn" type="button" data-target="knife-lay" data-dir="1">+</button>
                    </div>
                    <span id="knife-lay-val">-0.35</span>
                </div>
                <div class="panel-row">
                    <label for="knife-laz">LAZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-laz" data-dir="-1">-</button>
                        <input id="knife-laz" type="range" min="-2" max="1" step="0.01" value="-0.25">
                        <button class="nudge-btn" type="button" data-target="knife-laz" data-dir="1">+</button>
                    </div>
                    <span id="knife-laz-val">-0.25</span>
                </div>
                <div class="panel-row">
                    <label for="knife-larx">LARX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-larx" data-dir="-1">-</button>
                        <input id="knife-larx" type="range" min="-3.14" max="3.14" step="0.02" value="0.2">
                        <button class="nudge-btn" type="button" data-target="knife-larx" data-dir="1">+</button>
                    </div>
                    <span id="knife-larx-val">0.2</span>
                </div>
                <div class="panel-row">
                    <label for="knife-lary">LARY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-lary" data-dir="-1">-</button>
                        <input id="knife-lary" type="range" min="-3.14" max="3.14" step="0.02" value="0.3">
                        <button class="nudge-btn" type="button" data-target="knife-lary" data-dir="1">+</button>
                    </div>
                    <span id="knife-lary-val">0.3</span>
                </div>
                <div class="panel-row">
                    <label for="knife-larz">LARZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-larz" data-dir="-1">-</button>
                        <input id="knife-larz" type="range" min="-3.14" max="3.14" step="0.02" value="-0.15">
                        <button class="nudge-btn" type="button" data-target="knife-larz" data-dir="1">+</button>
                    </div>
                    <span id="knife-larz-val">-0.15</span>
                </div>
            </div>

            <!-- Right Arm Column -->
            <div class="arm-column">
                <div class="section-title" style="color:#9eff9e">Right Arm (RA)</div>
                <div class="panel-row">
                    <label for="knife-rax">RAX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-rax" data-dir="-1">-</button>
                        <input id="knife-rax" type="range" min="-1" max="1" step="0.01" value="0.12">
                        <button class="nudge-btn" type="button" data-target="knife-rax" data-dir="1">+</button>
                    </div>
                    <span id="knife-rax-val">0.12</span>
                </div>
                <div class="panel-row">
                    <label for="knife-ray">RAY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-ray" data-dir="-1">-</button>
                        <input id="knife-ray" type="range" min="-1" max="1" step="0.01" value="-0.2">
                        <button class="nudge-btn" type="button" data-target="knife-ray" data-dir="1">+</button>
                    </div>
                    <span id="knife-ray-val">-0.2</span>
                </div>
                <div class="panel-row">
                    <label for="knife-raz">RAZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-raz" data-dir="-1">-</button>
                        <input id="knife-raz" type="range" min="-1" max="1" step="0.01" value="-0.15">
                        <button class="nudge-btn" type="button" data-target="knife-raz" data-dir="1">+</button>
                    </div>
                    <span id="knife-raz-val">-0.15</span>
                </div>
                <div class="panel-row">
                    <label for="knife-rarx">RARX</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-rarx" data-dir="-1">-</button>
                        <input id="knife-rarx" type="range" min="-3.14" max="3.14" step="0.02" value="0">
                        <button class="nudge-btn" type="button" data-target="knife-rarx" data-dir="1">+</button>
                    </div>
                    <span id="knife-rarx-val">0</span>
                </div>
                <div class="panel-row">
                    <label for="knife-rary">RARY</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-rary" data-dir="-1">-</button>
                        <input id="knife-rary" type="range" min="-3.14" max="3.14" step="0.02" value="-0.15">
                        <button class="nudge-btn" type="button" data-target="knife-rary" data-dir="1">+</button>
                    </div>
                    <span id="knife-rary-val">-0.15</span>
                </div>
                <div class="panel-row">
                    <label for="knife-rarz">RARZ</label>
                    <div class="slider-group">
                        <button class="nudge-btn" type="button" data-target="knife-rarz" data-dir="-1">-</button>
                        <input id="knife-rarz" type="range" min="-3.14" max="3.14" step="0.02" value="0.05">
                        <button class="nudge-btn" type="button" data-target="knife-rarz" data-dir="1">+</button>
                    </div>
                    <span id="knife-rarz-val">0.05</span>
                </div>
            </div>
        </div>
        <button id="knife-copy" style="width:100%;margin-top:6px;">Copy values</button>
    </div>

    <!-- Knife Swing Debug Panel - Toggle with ] key -->
    <div id="knife-swing-panel">
        <div class="panel-title">🗡️ Knife Swing Adjust (] key)</div>

        <div class="panel-row">
            <label>Freeze</label>
            <input id="swing-freeze" type="range" min="-0.01" max="1" step="0.01" value="-0.01">
            <span id="swing-freeze-val">OFF</span>
        </div>

        <div class="section-title">Phase 1 (Wind-up End)</div>
        <div class="panel-row">
            <label>P1 X</label>
            <input id="swing-p1-kx" type="range" min="-1" max="1" step="0.02" value="-0.2">
            <span id="swing-p1-kx-val">-0.20</span>
        </div>
        <div class="panel-row">
            <label>P1 Y</label>
            <input id="swing-p1-ky" type="range" min="-1" max="1" step="0.02" value="0.0">
            <span id="swing-p1-ky-val">0.00</span>
        </div>
        <div class="panel-row">
            <label>P1 Z</label>
            <input id="swing-p1-kz" type="range" min="-1" max="0" step="0.02" value="-0.35">
            <span id="swing-p1-kz-val">-0.35</span>
        </div>
        <div class="panel-row">
            <label>P1 RX</label>
            <input id="swing-p1-krx" type="range" min="-3.14" max="3.14" step="0.05" value="1.57">
            <span id="swing-p1-krx-val">1.57</span>
        </div>
        <div class="panel-row">
            <label>P1 RY</label>
            <input id="swing-p1-kry" type="range" min="-3.14" max="3.14" step="0.05" value="1.57">
            <span id="swing-p1-kry-val">1.57</span>
        </div>
        <div class="panel-row">
            <label>P1 RZ</label>
            <input id="swing-p1-krz" type="range" min="-3.14" max="3.14" step="0.05" value="0.0">
            <span id="swing-p1-krz-val">0.00</span>
        </div>

        <div class="section-title">Phase 2 (Slash End)</div>
        <div class="panel-row">
            <label>P2 X</label>
            <input id="swing-p2-kx" type="range" min="-1" max="1" step="0.02" value="0.4">
            <span id="swing-p2-kx-val">0.40</span>
        </div>
        <div class="panel-row">
            <label>P2 Y</label>
            <input id="swing-p2-ky" type="range" min="-1" max="1" step="0.02" value="-0.1">
            <span id="swing-p2-ky-val">-0.10</span>
        </div>
        <div class="panel-row">
            <label>P2 Z</label>
            <input id="swing-p2-kz" type="range" min="-1" max="0" step="0.02" value="-0.5">
            <span id="swing-p2-kz-val">-0.50</span>
        </div>
        <div class="panel-row">
            <label>P2 RX</label>
            <input id="swing-p2-krx" type="range" min="-3.14" max="3.14" step="0.05" value="1.5">
            <span id="swing-p2-krx-val">1.50</span>
        </div>
        <div class="panel-row">
            <label>P2 RY</label>
            <input id="swing-p2-kry" type="range" min="-3.14" max="3.14" step="0.05" value="-0.5">
            <span id="swing-p2-kry-val">-0.50</span>
        </div>
        <div class="panel-row">
            <label>P2 RZ</label>
            <input id="swing-p2-krz" type="range" min="-3.14" max="3.14" step="0.05" value="0.3">
            <span id="swing-p2-krz-val">0.30</span>
        </div>

        <button id="swing-copy" style="width:100%;margin-top:8px;">Copy Values</button>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/SkeletonUtils.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Global Error Handler to debug Black Screen issues
        window.onerror = function (msg, url, line, col, error) {
            alert("JS Error: " + msg + "\nLine: " + line + "\nCol: " + col);
            console.error(msg, error);
            return false;
        };

        // --- GLB Model Caching System ---
        const modelCache = {};
        const globalLoader = new THREE.GLTFLoader();

        /**
         * Load a model and cache it
         * @param {string} url - URL of the GLB file
         * @returns {Promise<THREE.Group>}
         */
        async function loadModelCached(url) {
            if (modelCache[url]) return modelCache[url];

            return new Promise((resolve, reject) => {
                globalLoader.load(url, (gltf) => {
                    modelCache[url] = gltf.scene;
                    console.log(`[Cache] Model loaded and cached: ${url}`);
                    resolve(gltf.scene);
                }, undefined, (err) => {
                    console.error(`[Cache] Failed to load model: ${url}`, err);
                    reject(err);
                });
            });
        }

        /**
         * Clone a cached model using SkeletonUtils for rigged models
         * @param {string} url - Cache key (URL)
         * @returns {THREE.Group|null}
         */
        function getClonedModel(url) {
            const model = modelCache[url];
            if (!model) {
                console.warn(`[Cache] Model not found in cache: ${url}`);
                return null;
            }
            // Use SkeletonUtils.clone for rigged models (characters/weapons)
            // If it's not a rigged model, regular clone is fine, but SkeletonUtils is safer for both.
            const clone = THREE.SkeletonUtils ? THREE.SkeletonUtils.clone(model) : model.clone();

            // [FIX] Deep clone materials to prevent shared state issues (e.g. invisible respawn)
            if (clone) {
                clone.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(m => m.clone());
                        } else {
                            child.material = child.material.clone();
                        }
                    }
                });
            }
            return clone;
        }

        /**
         * Pre-load all required multiplayer models
         */
        async function preloadMultiplayerAssets() {
            const modelsToLoad = [
                './char/cr.glb',
                'gun/Assault Rifle.glb',
                'gun/pistol.glb',
                'gun/Sniper.glb',
                'gun/Knife.glb'
            ];

            console.log('[Cache] Pre-loading assets...');
            const promises = modelsToLoad.map(url => loadModelCached(url).catch(e => null));
            await Promise.all(promises);
            console.log('[Cache] Pre-loading complete.');
        }
        /*
        /*
        FPS.html VERSION: 2026-01-11-0200-STABLE
        Updates:
        - Critical Fix: Zombie Mode (Single Player) Initialization & Map Loading
        - Added Cache-Control Headers
        */
        console.log('=== FPS.html VERSION: 2026-01-13-FIX-HITMARKER ==='); // VERSION CHECK

        // [FIX] Ensure showHitMarker is globally available
        window.showHitMarker = function () {
            const el = document.getElementById('hit-marker');
            if (el) {
                el.style.opacity = '1';
                el.style.transform = 'translate(-50%, -50%) scale(1.2)';
                setTimeout(() => {
                    if (el) {
                        el.style.transform = 'translate(-50%, -50%) scale(1)';
                        el.style.opacity = '0';
                    }
                }, 150);
            }
        };

        // Single Player Map Selection Global State
        let selectedSinglePlayerMap = 'factory';

        // ===== KNIFE SWING DEBUG PANEL INITIALIZATION =====
        (function setupKnifeSwingPanel() {
            // Initialize config if not exists
            if (!window.KNIFE_SWING_CONFIG) {
                window.KNIFE_SWING_CONFIG = {
                    p1_kx: 0.26, p1_ky: 0.00, p1_kz: -0.48,
                    p1_krx: 1.57, p1_kry: 1.57, p1_krz: 2.41,
                    p2_kx: 0.40, p2_ky: -0.10, p2_kz: -0.50,
                    p2_krx: 1.50, p2_kry: 0.21, p2_krz: -2.24,
                    freezeAt: -1
                };
            }
            const cfg = window.KNIFE_SWING_CONFIG;

            document.addEventListener('DOMContentLoaded', function () {
                const panel = document.getElementById('knife-swing-panel');
                if (!panel) return;

                // Slider IDs to config key mapping
                const sliderMap = {
                    'swing-freeze': { key: 'freezeAt', valId: 'swing-freeze-val', isFreeze: true },
                    'swing-p1-kx': { key: 'p1_kx', valId: 'swing-p1-kx-val' },
                    'swing-p1-ky': { key: 'p1_ky', valId: 'swing-p1-ky-val' },
                    'swing-p1-kz': { key: 'p1_kz', valId: 'swing-p1-kz-val' },
                    'swing-p1-krx': { key: 'p1_krx', valId: 'swing-p1-krx-val' },
                    'swing-p1-kry': { key: 'p1_kry', valId: 'swing-p1-kry-val' },
                    'swing-p1-krz': { key: 'p1_krz', valId: 'swing-p1-krz-val' },
                    'swing-p2-kx': { key: 'p2_kx', valId: 'swing-p2-kx-val' },
                    'swing-p2-ky': { key: 'p2_ky', valId: 'swing-p2-ky-val' },
                    'swing-p2-kz': { key: 'p2_kz', valId: 'swing-p2-kz-val' },
                    'swing-p2-krx': { key: 'p2_krx', valId: 'swing-p2-krx-val' },
                    'swing-p2-kry': { key: 'p2_kry', valId: 'swing-p2-kry-val' },
                    'swing-p2-krz': { key: 'p2_krz', valId: 'swing-p2-krz-val' }
                };

                // Bind sliders to config
                Object.entries(sliderMap).forEach(([sliderId, info]) => {
                    const slider = document.getElementById(sliderId);
                    const valSpan = document.getElementById(info.valId);
                    if (!slider || !valSpan) return;

                    slider.addEventListener('input', function () {
                        const v = parseFloat(this.value);
                        cfg[info.key] = v;
                        if (info.isFreeze) {
                            valSpan.textContent = v < 0 ? 'OFF' : v.toFixed(2);
                        } else {
                            valSpan.textContent = v.toFixed(2);
                        }
                    });
                });

                // Copy button
                const copyBtn = document.getElementById('swing-copy');
                if (copyBtn) {
                    copyBtn.addEventListener('click', function () {
                        const txt = `p1_kx: ${cfg.p1_kx}, p1_ky: ${cfg.p1_ky}, p1_kz: ${cfg.p1_kz}, p1_krx: ${cfg.p1_krx}, p1_kry: ${cfg.p1_kry}, p1_krz: ${cfg.p1_krz}, p2_kx: ${cfg.p2_kx}, p2_ky: ${cfg.p2_ky}, p2_kz: ${cfg.p2_kz}, p2_krx: ${cfg.p2_krx}, p2_kry: ${cfg.p2_kry}, p2_krz: ${cfg.p2_krz}`;
                        navigator.clipboard.writeText(txt).then(() => {
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => copyBtn.textContent = 'Copy Values', 1500);
                        });
                    });
                }

                // Toggle panel with ] key
                document.addEventListener('keydown', function (e) {
                    if (e.code === 'BracketRight') {
                        const isVisible = panel.style.display === 'block';
                        panel.style.display = isVisible ? 'none' : 'block';
                    }
                });

                console.log('[Knife Swing] Debug panel ready. Press ] to toggle.');
            });
        })();

        let camera, scene, renderer;
        let postProcessingCanvas, postProcessingCtx; // Global declaration
        let postProcessingEnabled = false;
        let mapGroup; // Global group for map-specific objects

        // Improved mobile detection: Focus on actual mobile platforms rather than just touch support
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Secondary check: if it has touch but also a fine pointer (mouse), consider it desktop
        const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        const hasFinePointer = window.matchMedia && window.matchMedia('(pointer: fine)').matches;

        // If we have both, or just fine pointer, it's a PC with touch or standard PC
        if (hasFinePointer) isMobile = false;
        else if (hasCoarsePointer && !hasFinePointer) isMobile = true;

        let ceilingLight = null;
        let lastTime = performance.now();

        // 확장 기능 변수
        let gltfLoader, textureLoader;
        let composer; // 후처리 컴포저
        let physicsWorld; // 물리 엔진 세계
        let usePhysics = true; // 물리 엔진 사용 여부 (활성화)
        let usePostProcessing = true; // 후처리 효과 사용 여부 (활성화)

        // 감도 설정 (기본값)
        let SENSITIVITY_MOUSE = 0.002;
        let SENSITIVITY_ADS = 0.0005;

        // localStorage에서 감도 로드
        const savedSensitivity = localStorage.getItem('mouseSensitivity');
        if (savedSensitivity) {
            const sensitivity = parseFloat(savedSensitivity);
            if (!isNaN(sensitivity) && sensitivity > 0) {
                SENSITIVITY_MOUSE = sensitivity;
                SENSITIVITY_ADS = sensitivity * 0.25; // ADS는 일반 감도의 25%
            }
        }

        // Player State - 안전한 스폰 위치 (구조물 사이 빈 공간)
        // Factory 맵 분석: 중앙(0,0) 근처 및 ±22 근처는 비교적 빈 공간
        // 구조물: 컨테이너(±70,±70), 플랫폼(±60,±60), 크레이트(여러 위치), 커버월 등
        // 스폰 위치 수정: (0, 1.7, 5)는 안전하지만, (25, 1.7, 0) 등은 위험할 수 있음.
        // 중앙 안전 구역으로 고정: (0, 1.7, 10)
        let position = new THREE.Vector3(0, 1.7, 10);
        let lastPlayerPosition = position.clone();


        // Single Player Spawn Points (Global for restartGame)
        const SINGLE_PLAYER_SPAWN_POINTS = [
            { x: 0, y: 1.7, z: 10 },
            { x: 25, y: 1.7, z: 25 },
            { x: -25, y: 1.7, z: -25 },
            { x: 40, y: 1.7, z: 0 },
            { x: -40, y: 1.7, z: 0 },
            { x: 0, y: 1.7, z: -40 }
        ];

        let rotation = { x: 0, y: 0 };
        let velocityY = 0;
        let isGrounded = false;
        let playerVelocity = new THREE.Vector3();
        let playerHP = 100;
        let debugShellVelocity = false;
        // isAiming is defined below with weapon state
        let aimLocked = false;
        let lastGroundedState = false; // Separate from isGrounded for landing sound trigger tracking
        window.knifeSwing = window.knifeSwing ?? 0;
        window.KNIFE_SWING_DURATION = window.KNIFE_SWING_DURATION ?? 0.18; // Speed up: 0.25 -> 0.18



        let isDead = false;
        let isPaused = false;
        let usePointerLock = true;
        let isGameStarted = false; // New flag to block input/updates during countdown
        let gameMode = null; // 'single' or 'multi'

        // UI Globals (Legacy/Compatibility)
        let elPlayTime = null;
        let elKillCount = null;

        let currentGameMode = 'ffa'; // 'ffa' or 'tdm'
        let currentMap = 'factory'; // 선택된 맵 (기본값: factory)
        let isRoomHost = false;
        let maxPlayers = 4;
        let currentPlayers = 1;
        let playersList = [];
        let countdownTimer = null;
        let currentRoomTimeLeft = 600; // Track match time for UI sync
        let singlePlayerTimeLeft = 600;

        // Movement/Enemy tuning
        // ZOMBIE_SPEED is defined in enemy config block below



        // Multiplayer Socket
        let socket = null;
        let myId = null;
        let otherPlayersMap = {}; // id -> mesh
        let roomPlayersState = {}; // Global player data
        const PLAYER_RADIUS = 0.4;


        // Spectator/Killcam System
        let isSpectating = false;
        let spectatingPlayerId = null;

        // Footsteps
        let moveDistance = 0;
        const STEP_INTERVAL = 2.5;

        // === 전체화면 함수 (모바일 브라우저 대응) ===
        function enterFullscreen() {
            const elem = document.documentElement;

            // 이미 전체화면이면 무시
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
                return;
            }

            // 크로스 브라우저 전체화면 요청
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => {
                    console.log('Fullscreen request failed:', err);
                });
            } else if (elem.webkitRequestFullscreen) { // iOS Safari
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
            }
        }

        // === 전역 변수 ===
        const keys = { w: 0, a: 0, s: 0, d: 0, shift: false, ctrl: false, space: false };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyV') {
                debugShellVelocity = !debugShellVelocity;
                console.log('[ShellDebug] enabled:', debugShellVelocity);
            }
        });


        // MAP EDITOR GLOBALS
        let isEditorActive = false;
        let editorObjects = []; // Array of placed objects
        let editorCurrentObjectType = 'crate';
        let editorObjectTypes = ['crate', 'smallCrate', 'coverWall', 'platform', 'pillar', 'container'];
        let editorGhostMesh = null; // Preview mesh
        let editorSelectedIndex = 0;

        // --- Physics Optimization: Spatial Hash Grid ---
        class SpatialHash {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }
            getKey(x, z) {
                return Math.floor(x / this.cellSize) + "," + Math.floor(z / this.cellSize);
            }
            insert(box) {
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = x + "," + z;
                        if (!this.cells.has(key)) this.cells.set(key, []);
                        this.cells.get(key).push(box);
                    }
                }
            }
            query(box) {
                const results = new Set();
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = x + "," + z;
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (const item of cell) results.add(item);
                        }
                    }
                }
                return results;
            }
            clear() {
                this.cells.clear();
            }
        }
        const spatialGrid = new SpatialHash(10); // 10 unit cells


        // === Event Helper ===
        function addSafeListener(el, callback) {
            if (!el) return;
            el.addEventListener('click', callback);
            el.addEventListener('touchstart', (e) => {
                e.preventDefault();
                callback(e);
            }, { passive: false });
        }

        // --- Weapon System ---
        const WEAPONS = [
            {
                id: 0, name: "ASSAULT RIFLE",
                type: 'RIFLE', maxAmmo: 30, ammo: 30, automatic: true,
                // [ROLLBACK] Restore working idle position, disable custom rotation for now
                type: 'RIFLE', maxAmmo: 30, ammo: 30, automatic: true,
                posHip: new THREE.Vector3(0.08, -0.25, -0.45),
                // [User Request] Separate GLB transforms for Idle vs ADS
                glbHip: {
                    pos: new THREE.Vector3(0.23, -0.47, 0.44),
                    rot: new THREE.Vector3(0.43, 1.69, -0.25),
                    scale: new THREE.Vector3(0.50, 0.50, 0.50)
                },
                glbAds: {
                    // [User Request] Set to coordinates provide in image
                    pos: new THREE.Vector3(0.00, -0.47, -0.06),
                    rot: new THREE.Vector3(0.36, 1.57, -0.29),
                    scale: new THREE.Vector3(0.45, 0.45, 0.45)
                },
                // ADS: Z더 멀리 (-0.45), FOV 약간 증가 (25) for smaller appearance
                posAds: new THREE.Vector3(0, -0.062, -0.45),
                rotAds: new THREE.Vector3(0, 0, 0), // Aim Rotation (Default)
                fovAds: 25, fireRate: 0.08, recoil: 0.06, damage: 30,
                muzzleHip: new THREE.Vector3(0, 0.12, -0.65),
                muzzleAds: new THREE.Vector3(-0.049, 0.024, -0.655),
                lArmHip: { pos: new THREE.Vector3(-0.05, -0.25, -0.44), rot: new THREE.Vector3(0.54, -0.82, 0.60) },
                lArmAds: { pos: new THREE.Vector3(-0.10, -0.27, -1.46), rot: new THREE.Vector3(0.80, -0.80, 0.62) },
                switchSound: 'c-sochong'
            },
            {
                id: 1, name: "TACTICAL PISTOL",
                type: 'PISTOL', maxAmmo: 10, ammo: 10, automatic: false,
                posHip: new THREE.Vector3(0.08, -0.2, -0.45),
                // [User Request] Separate GLB transforms for Idle vs ADS
                glbHip: {
                    pos: new THREE.Vector3(-0.02, 0.02, 0.09),
                    rot: new THREE.Vector3(0.04, 1.61, 0.05),
                    scale: new THREE.Vector3(0.20, 0.20, 0.20)
                },
                glbAds: {
                    pos: new THREE.Vector3(0.00, -0.09, 0.07),
                    rot: new THREE.Vector3(-0.04, 1.57, 0.06),
                    scale: new THREE.Vector3(0.17, 0.17, 0.17)
                },
                // Pistol ADS: Centered and aligned to sights
                posAds: new THREE.Vector3(0, -0.048, -0.35),
                fovAds: 55, fireRate: 0.15, recoil: 0.1, damage: 20,
                muzzleHip: new THREE.Vector3(-0.066, 0.190, -0.199),
                muzzleAds: new THREE.Vector3(0.01, 0.01, -0.20),
                switchSound: 'c-gun'
            },
            {
                id: 2, name: "TAC-50 SNIPER",
                type: 'SNIPER', maxAmmo: 4, ammo: 4, automatic: false,
                posHip: new THREE.Vector3(0.08, -0.3, -0.5),
                // [User Request] Sniper GLB Config
                glbHip: {
                    pos: new THREE.Vector3(0.19, -0.11, 0.17),
                    rot: new THREE.Vector3(0.45, 1.59, -0.39),
                    scale: new THREE.Vector3(0.64, 0.64, 0.64)
                },
                glbAds: {
                    pos: new THREE.Vector3(0, -0.15, 0.2),
                    rot: new THREE.Vector3(0, 3.14, 0),
                    scale: new THREE.Vector3(0.2, 0.2, 0.2)
                },
                posAds: new THREE.Vector3(0, -0.06, -0.15),
                fovAds: 8, fireRate: 1.5, recoil: 0.4, damage: 100,
                muzzleHip: new THREE.Vector3(0.0, 0.28, -2.5),
                muzzleAds: new THREE.Vector3(0, 0.035, -0.85),
                lArmHip: { pos: new THREE.Vector3(0.01, -0.24, -0.60), rot: new THREE.Vector3(0.72, -0.76, -0.02) },
                lArmAds: { pos: new THREE.Vector3(-0.15, -0.25, -0.6), rot: new THREE.Vector3(0.7, 0.3, -0.35) },
                rArmHip: { pos: new THREE.Vector3(0.15, -0.17, 0.08), rot: new THREE.Vector3(-0.02, 0.02, 0.58) },
                rArmAds: { pos: new THREE.Vector3(0.12, -0.28, 0.1), rot: new THREE.Vector3(0.2, -0.2, 0.4) },
                switchSound: 'c-rifle'
            },
            {
                id: 3, name: "KNIFE",
                type: 'KNIFE', maxAmmo: 0, ammo: 0, automatic: true,
                posHip: new THREE.Vector3(0.25, -0.25, -0.5),
                posAds: new THREE.Vector3(0.25, -0.25, -0.45),
                glbHip: {
                    pos: new THREE.Vector3(0.01, 0.00, -0.29),
                    rot: new THREE.Vector3(2.16, -0.06, 2.08),
                    scale: new THREE.Vector3(1.90, 1.90, 1.90)
                },
                lArmHip: { pos: new THREE.Vector3(-1.63, -0.14, -0.11), rot: new THREE.Vector3(0.56, -0.56, -1.98) },
                rArmHip: { pos: new THREE.Vector3(0.02, 0.02, -0.15), rot: new THREE.Vector3(0.18, 0.36, 3.14) },
                fovAds: 65, fireRate: 0.4, recoil: 0, damage: 15,
                switchSound: 'c-sword'
            },
            {
                id: 4, name: "GRENADE",
                type: 'GRENADE', maxAmmo: 3, ammo: 3, automatic: false,
                posHip: new THREE.Vector3(0.05, -0.2, -0.3),
                posAds: new THREE.Vector3(0.1, -0.2, -0.3), // No ADS for grenade
                fovAds: 70, fireRate: 1.5, recoil: 0, damage: 100, // Area Damage
                switchSound: 'grenade_switch'
            }
        ];
        let curWeaponIdx = 0;

        let weaponContainer, weaponModel;
        let currentPos = WEAPONS[0].posHip.clone();
        let currentRot = new THREE.Vector3(0, 0, 0); // 무기 회전 보간용 변수

        let isAiming = false;
        let cameraRecoil = { x: 0, y: 0 };
        let cameraRecoilVel = { x: 0, y: 0 };
        let cameraRecoilApplied = { x: 0, y: 0 };
        let isFiring = false;
        let hasFiredSemi = false;
        let isReloading = false;
        let knifeSwing = 0;
        let hasClickedEmpty = false;
        let sniperReloadGesture = false; // PC 모드 저격총 재장전 제스처 플래그

        let fireCooldown = 0;

        let recoil = { x: 0, z: 0 };
        let recoilVel = { x: 0, z: 0 };
        const RECOIL_SPRING = 70;
        const RECOIL_DAMPING = 12;
        const RECOIL_MAX = 0.8;
        const RECOIL_POS_MAX = 2.6; // Increased from 0.35 to allow strong kick
        const CAM_RECOIL_SPRING = 70;
        const CAM_RECOIL_DAMPING = 12;
        const CAM_RECOIL_MAX = 0.55;
        const RIFLE_SHOT_BASE_VOLUME = 0.72; // Reduced by 20% (0.9 -> 0.72)
        const rifleShotAudio = new Audio('sounds/rifle2.MP3');
        rifleShotAudio.preload = 'auto';
        rifleShotAudio.volume = RIFLE_SHOT_BASE_VOLUME;
        const playRifleShot = () => {
            const shot = rifleShotAudio.cloneNode(true);
            const masterVolume = (typeof SoundGen !== 'undefined' && typeof SoundGen.masterVolume === 'number')
                ? SoundGen.masterVolume
                : 1.0;
            shot.volume = RIFLE_SHOT_BASE_VOLUME * masterVolume;
            shot.currentTime = 0;
            shot.play().catch(() => { });
        };
        let muzzleFlash;

        let hitShake = { x: 0, y: 0, intensity: 0 }; // 피격 시 화면 흔들림
        let swayOffset = { x: 0, y: 0 }; // 무기 울렁임 (Idle Sway)

        let shells = [];
        let shellGeo, shellMat;
        let bloodParticles = [];
        let decals = [];
        let sparkParticles = [];
        let smokeParticles = [];
        let healthPills = [];
        const matHealthPill = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.2, metalness: 0.8, emissive: 0xff00ff, emissiveIntensity: 0.5 });

        let grenades = []; // Active grenades in the world
        let weaponLoadToken = 0; // Global token to prevent async weapon double-load

        const matGrenade = new THREE.MeshStandardMaterial({ color: 0x4caf50, roughness: 0.7, metalness: 0.4 });
        const GRAVITY = -3.5; // Reduced from -5.0 for even more airtime


        let enemies = [];
        const ZOMBIE_SPEED = 2.7;
        const ZOMBIE_DMG = 10;
        const ATTACK_RANGE = 2.5;
        const ENEMY_RADIUS = 0.4;

        const MAX_ENEMIES = 20;
        const SPAWN_INTERVAL = 2.0;

        let spawnTimer = 0;

        // 멀티플레이어 플레이어 배열
        let otherPlayers = [];

        // 플레이어 모델용 재질 (다른 색상으로 구분)
        let matPlayerBody = new THREE.MeshStandardMaterial({ color: 0x4a90e2, roughness: 0.4, metalness: 0.6, emissive: 0x1a3052, emissiveIntensity: 0.6 });
        let matPlayerSkin = new THREE.MeshStandardMaterial({ color: 0xf4a460, roughness: 0.7, emissive: 0x543410, emissiveIntensity: 0.4 });

        // 게임 통계
        let gameStartTime = 0;
        let killCount = 0;
        let playTime = 0;

        let colliders = [];

        // UI - init() 함수 내부에서 초기화
        let elAmmoCurrent, elAmmoReserve, elWeaponName, elCrosshair, elVignette, elScope;
        let elHpBar, elHpGhost, elHpText, elDamage, elTimer, elScoreAlly, elScoreEnemy, elKillFeed;
        let elGameOver, elPauseOverlay, elHeadshot, elHitMarker, elGrenadeKill;


        // Materials
        const matBody = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.6 });
        const matParts = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.8 });
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.9 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xcbb093, roughness: 0.7 });
        // Slightly brighter than original (0x1c1f1c) for visibility, but still dark
        const matSleeve = new THREE.MeshStandardMaterial({ color: 0x2b2b2b, roughness: 1.0 });
        const matGlove = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.9 });
        const matSight = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const matBlade = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, metalness: 1.0 });
        const matHandle = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const matLens = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.1, metalness: 0.9 });
        const matDecal = new THREE.MeshBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1 });
        const matSpark = new THREE.MeshBasicMaterial({ color: 0xffdd55, transparent: true, opacity: 1 });
        const matSmoke = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.4, depthWrite: false });


        const matZombieSkin = new THREE.MeshStandardMaterial({ color: 0x5e7052, roughness: 0.8 });
        const matZombieClothes = new THREE.MeshStandardMaterial({ color: 0x4a3b2a, roughness: 0.9 });
        let matHpBg = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
        let matHpFg = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });

        const SoundGen = {
            ctx: null,
            audioBuffers: {}, // 로드된 오디오 파일 캐시
            masterVolume: 0.5, // Reduced from 1.0 to comfortable level per user request // 마스터 볼륨 (0.0 ~ 1.0)
            reloadVolume: 0.8, // 재장전 볼륨 (0.0 ~ 1.0)
            isStepPlaying: false, // 이동 소리 재생 중 여부
            init: function () {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } catch (e) {
                    console.warn('AudioContext initialization failed:', e);
                }
            },
            // 외부 오디오 파일 로드 함수
            loadAudioFile: function (url, name) {
                if (!this.ensureContext()) {
                    console.warn('AudioContext not available');
                    return Promise.reject('AudioContext not available');
                }

                // 이미 로드된 경우 캐시에서 반환
                if (this.audioBuffers[name]) {
                    return Promise.resolve(this.audioBuffers[name]);
                }

                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        return this.ctx.decodeAudioData(arrayBuffer);
                    })
                    .then(audioBuffer => {
                        this.audioBuffers[name] = audioBuffer;
                        console.log(`Audio file loaded: ${name}`);
                        return audioBuffer;
                    })
                    .catch(error => {
                        console.error(`Failed to load audio file ${url}:`, error);
                        throw error;
                    });
            },
            // 로드된 오디오 파일 재생 함수
            playAudioFile: function (name, volume = 1.0, loop = false) {
                if (!this.ensureContext()) return;
                console.log(`[SoundGen] Playing audio file: ${name}, Volume: ${volume}`);

                const audioBuffer = this.audioBuffers[name];
                if (!audioBuffer) {
                    console.warn(`Audio file not loaded: ${name}. Use loadAudioFile() first.`);
                    return;
                }

                try {
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();

                    source.buffer = audioBuffer;
                    source.loop = loop;
                    // 마스터 볼륨 적용
                    gainNode.gain.value = volume * this.masterVolume;

                    source.connect(gainNode);
                    gainNode.connect(this.ctx.destination);

                    source.start(0);

                    return source; // 재생 중지 등을 위해 반환
                } catch (e) {
                    console.error(`Failed to play audio file ${name}:`, e);
                }
            },
            ensureContext: function () {
                if (!this.ctx) {
                    this.init();
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.warn('AudioContext resume failed:', e));
                }
                return !!this.ctx;
            },
            playShoot: function (type) {
                if (!this.ensureContext()) return;
                console.log('[SoundGen] playShoot called for:', type);

                // 저격총은 오디오 파일 사용, 없으면 기존 소리 생성
                if (type === 'SNIPER' && this.audioBuffers['rifle']) {
                    this.playAudioFile('rifle', 0.25); // 볼륨 25%
                    return;
                }

                // [Multiplayer FIX] Ensure knife sounds are handled correctly (No fall-through to synth)
                if (type === 'KNIFE') {
                    this.playKnife();
                    return;
                }

                // [Remote Player FIX] Handle grenade throws for remote players
                if (type === 'GRENADE') {
                    if (typeof this.playGrenadeThrow === 'function') {
                        this.playGrenadeThrow();
                    }
                    return;
                }

                // 소총(어썰트라이플)은 오디오 파일 사용 (User Request: set default volume to 50%)
                if (type === 'RIFLE' && this.audioBuffers['gunshot']) {
                    this.playAudioFile('gunshot', 0.16); // Halved from 0.32 per user request
                    return;
                }

                // 권총은 오디오 파일 사용, 없으면 기존 소리 생성
                if (type === 'PISTOL' && this.audioBuffers['gunshot']) {
                    this.playAudioFile('gunshot', 0.4); // Reduced from 0.8 per user request
                    return;
                }

                // [DEFENSIVE] Do not play any sound for unknown types or KNIFE/GRENADE that reached here
                if (!type || type === 'KNIFE' || type === 'GRENADE') return;

                // 기존 소리 생성 (폴백) - Firearms only
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                filter.type = 'lowpass';
                if (type === 'SNIPER') {
                    filter.frequency.value = 600;
                    gain.gain.setValueAtTime(0.8, t); // Reduced from 1.5
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
                } else if (type === 'RIFLE') {
                    filter.frequency.value = 1000;
                    gain.gain.setValueAtTime(0.5, t); // Reduced from 1.0
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                } else {
                    filter.frequency.value = 1500;
                    gain.gain.setValueAtTime(0.4, t); // Reduced from 0.8
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                }

                noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            },
            playDryFire: function () {
                if (!this.ensureContext()) return;
                console.log('[SoundGen] playDryFire called');

                // 빈 격발 오디오 파일 사용, 없으면 기존 소리 생성
                if (this.audioBuffers['empty']) {
                    this.playAudioFile('empty', 0.8);
                } else {
                    // 기존 소리 생성 (폴백)
                    const t = this.ctx.currentTime;

                    // 기계음의 틱틱 같은 철제 소리
                    try {
                        // 첫 번째 틱 - 짧고 날카로운 소리
                        const osc1 = this.ctx.createOscillator();
                        const gain1 = this.ctx.createGain();
                        osc1.type = 'square'; // 기계음 느낌
                        osc1.frequency.setValueAtTime(1200, t);
                        osc1.frequency.exponentialRampToValueAtTime(800, t + 0.02);
                        gain1.gain.setValueAtTime(0.2, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
                        osc1.connect(gain1);
                        gain1.connect(this.ctx.destination);
                        osc1.start(t);
                        osc1.stop(t + 0.03);

                        // 두 번째 틱 - 약간 지연된 메탈릭 소리
                        const osc2 = this.ctx.createOscillator();
                        const gain2 = this.ctx.createGain();
                        osc2.type = 'sawtooth'; // 철제 느낌
                        osc2.frequency.setValueAtTime(1500, t + 0.01);
                        osc2.frequency.exponentialRampToValueAtTime(600, t + 0.04);
                        gain2.gain.setValueAtTime(0.15, t + 0.01);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc2.connect(gain2);
                        gain2.connect(this.ctx.destination);
                        osc2.start(t + 0.01);
                        osc2.stop(t + 0.05);

                        // 메탈릭 공명 효과
                        const osc3 = this.ctx.createOscillator();
                        const gain3 = this.ctx.createGain();
                        osc3.type = 'sine';
                        osc3.frequency.setValueAtTime(2000, t);
                        osc3.frequency.exponentialRampToValueAtTime(1000, t + 0.04);
                        gain3.gain.setValueAtTime(0.1, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.04);
                        osc3.connect(gain3);
                        gain3.connect(this.ctx.destination);
                        osc3.start(t);
                        osc3.stop(t + 0.04);
                    } catch (e) {
                        console.warn('Dry fire sound error:', e);
                    }
                }
            },
            playBoltAction: function () {
                if (!this.ensureContext()) return;

                // 저격총 볼트 액션 오디오 파일 사용 (c-rifle.mp3), 없으면 기존 소리 생성
                if (this.audioBuffers['c-rifle']) {
                    this.playAudioFile('c-rifle', 0.8);
                } else {
                    // 기존 소리 생성 (폴백)
                    const t = this.ctx.currentTime;
                    const osc1 = this.ctx.createOscillator();
                    const gain1 = this.ctx.createGain();
                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(150, t);
                    gain1.gain.setValueAtTime(0.2, t);
                    gain1.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc1.connect(gain1); gain1.connect(this.ctx.destination);
                    osc1.start(t); osc1.stop(t + 0.1);

                    const osc2 = this.ctx.createOscillator();
                    const gain2 = this.ctx.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(200, t + 0.15);
                    gain2.gain.setValueAtTime(0.2, t + 0.15);
                    gain2.gain.linearRampToValueAtTime(0, t + 0.25);
                    osc2.connect(gain2); gain2.connect(this.ctx.destination);
                    osc2.start(t + 0.15); osc2.stop(t + 0.25);
                }
            },
            playZombieAttack: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.1);
            },
            playKnife: function () {
                if (!this.ensureContext()) return;
                console.log('[SoundGen] playKnife called');

                // 나이프 휘두르기 오디오 파일 사용, 없으면 기존 소리 생성
                if (this.audioBuffers['sword']) {
                    this.playAudioFile('sword', 0.8);
                    return; // Prevent fallback sound from playing
                }

                // 기존 소리 생성 (폴백)
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, t);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.2);
            },
            playJump: function (land) {
                if (!this.ensureContext()) return;

                // Landing Sound (Now handled by playLand with chak.mp3 if available)
                if (land) {
                    this.playLand();
                    return;
                }

                // User Request: Play gtunt.mp3 on jump start
                if (this.audioBuffers['jump']) {
                    this.playAudioFile('jump', 0.8);
                    return;
                }

                // Fallback Oscillator Jump Sound
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playLand: function () {
                if (!this.ensureContext()) return;
                // User Request: Use chak.MP3 (land) for landing
                if (this.audioBuffers['land']) {
                    console.log('Playing landing sound...');
                    this.playAudioFile('land', 0.8);
                } else {
                    // Fallback to synthetic thud if file missing
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.3, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.1);
                }
            },
            playStep: function () {
                if (!this.ensureContext()) return;
                if (this.isStepPlaying) return; // 이미 재생 중이면 중복 재생 방지

                // User Request: Use walking.MP3 for walking
                if (this.audioBuffers['walking']) {
                    this.isStepPlaying = true;
                    const source = this.playAudioFile('walking', 0.6);
                    if (source) {
                        source.onended = () => {
                            this.isStepPlaying = false;
                        };
                    } else {
                        this.isStepPlaying = false;
                    }
                    return;
                }

                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                noise.start();
            },
            playReload: function () {
                if (!this.ensureContext()) return;

                // 오디오 파일이 로드되어 있으면 사용, 없으면 기존 소리 생성
                if (this.audioBuffers['reload']) {
                    this.playAudioFile('reload', this.reloadVolume);
                } else {
                    // 기존 소리 생성 (폴백)
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.1);
                }
            },
            playBeep: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine'; // Beep sound
                osc.frequency.setValueAtTime(800, t); // Start at 800Hz
                osc.frequency.linearRampToValueAtTime(600, t + 0.1); // Drop to 600Hz
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.1);
            },
            playHeadshot: function () {
                if (!this.ensureContext()) return;

                // User Request: Play headshot.mp3 on headshot
                if (this.audioBuffers['headshot']) {
                    // [FIX] Add tiny delay (50ms) to distinguish from initial shot sound
                    setTimeout(() => {
                        this.playAudioFile('headshot', 0.82); // Slightly reduced from 1.0 (Master volume is already 0.5)
                    }, 50);
                    return;
                }

                const t = this.ctx.currentTime;

                // 깨지는 소리 - 노이즈 기반
                const bufferSize = this.ctx.sampleRate * 0.15;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // 깨지는 느낌의 노이즈 생성
                for (let i = 0; i < bufferSize; i++) {
                    const progress = i / bufferSize;
                    // 깨지는 소리: 고주파 노이즈 + 급격한 감쇠
                    const noise = (Math.random() * 2 - 1) * (1 - progress * 0.8);
                    // 고주파 강조
                    const highFreq = Math.sin(progress * Math.PI * 20) * 0.3;
                    data[i] = noise * (1 - progress) + highFreq * (1 - progress);
                }

                const noiseSource = this.ctx.createBufferSource();
                noiseSource.buffer = buffer;

                // 고역 필터로 깨지는 느낌 강조
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(2000, t);
                filter.frequency.exponentialRampToValueAtTime(800, t + 0.15);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noiseSource.start(t);
                noiseSource.stop(t + 0.15);

                // 추가 깨지는 소리 레이어
                const osc = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(3000, t);
                osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            },
            lastHitTime: 0, // Debounce for hit sound
            playHit: function () {
                if (!this.ensureContext()) return;

                const now = this.ctx.currentTime;
                // Cooldown: Don't play hit sound more than once every 0.1s
                if (now - this.lastHitTime < 0.1) return;
                this.lastHitTime = now;

                // User Request: Play hit.mp3 when hitting a target
                if (this.audioBuffers['hit']) {
                    // Stop previous sound to prevent overlapping long clips
                    if (this.lastHitSource) {
                        try { this.lastHitSource.stop(); } catch (e) { }
                    }
                    this.lastHitSource = this.playAudioFile('hit', 1.0);
                    return;
                }

                const t = this.ctx.currentTime;
                // Fallback: 피격 사운드 - 짧고 날카로운 소리 (볼륨 약간 감소)
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'square';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(400, t + 0.05);
                gain1.gain.setValueAtTime(0.12, t); // 0.2 -> 0.12 (볼륨 감소)
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.08);

                // 추가 타격음 (볼륨 약간 감소)
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(200, t);
                osc2.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain2.gain.setValueAtTime(0.09, t); // 0.15 -> 0.09 (볼륨 감소)
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.1);
            },
            playGrenadeThrow: function () {
                if (!this.ensureContext()) return;
                // Fallback: Pin pull sound 'chink'
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(2000, t);
                osc.frequency.exponentialRampToValueAtTime(1000, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.1);
            },
            playSwitch: function () {
                if (!this.ensureContext()) return;
                console.log('[SoundGen] playSwitch called');
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                // Mechanical Clank
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.15);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playHealthPill: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
                gain1.gain.setValueAtTime(0.3, t);
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.3);

                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(600, t);
                osc2.frequency.exponentialRampToValueAtTime(400, t + 0.2);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.25);
            },
            playDamage: function () {
                if (!this.ensureContext()) return;
                // User Request: Play uak.mp3 upon damage
                if (this.audioBuffers['damage']) {
                    this.playAudioFile('damage', 1.0);
                } else {
                    // Fallback sound check: Do NOT fallback to playHit() as that is for attacking!
                    console.warn('Damage sound (uak.mp3) not loaded.');
                }
            },
            playExplosion: function () {
                if (!this.ensureContext()) return;

                // User Request: Play grenade.mp3 on explosion
                if (this.audioBuffers['grenade_explosion']) {
                    this.playAudioFile('grenade_explosion', 1.0);
                    return;
                }

                const t = this.ctx.currentTime;
                // Low rumble
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(100, t);
                osc1.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                gain1.gain.setValueAtTime(1.0, t);
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.5);

                // Noise burst
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gainN = this.ctx.createGain();
                gainN.gain.setValueAtTime(0.8, t);
                noise.connect(gainN); gainN.connect(this.ctx.destination);
                noise.start();
            }
        };


        // ============================================
        // 볼륨 조절 방법:
        // ============================================
        // 
        // 1. 재장전 볼륨 조절:
        SoundGen.reloadVolume = 0.3; // 0.0 (무음) ~ 1.0 (최대)
        //
        // 2. 마스터 볼륨 조절 (모든 오디오 파일에 적용):
        //    SoundGen.masterVolume = 0.7; // 0.0 (무음) ~ 1.0 (최대)
        //
        // 3. 브라우저 콘솔에서 실시간 조절:
        //    개발자 도구(F12) > Console 탭에서:
        //    SoundGen.reloadVolume = 0.3; // 재장전 소리만 작게
        //    SoundGen.masterVolume = 0.5; // 모든 소리 작게
        //
        // ============================================
        // 외부 오디오 파일 사용 예시:
        // ============================================
        // 
        // 1. 오디오 파일 로드 (게임 시작 시 또는 필요할 때):
        // SoundGen.loadAudioFile('sounds/shoot.mp3', 'shootSound')
        //     .then(() => console.log('Sound loaded!'))
        //     .catch(err => console.error('Failed to load sound:', err));
        //
        // 2. 로드된 오디오 파일 재생:
        // SoundGen.playAudioFile('shootSound', 0.8); // 볼륨 0.8로 재생
        //
        // 3. 여러 오디오 파일 동시 로드:
        // Promise.all([
        //     SoundGen.loadAudioFile('sounds/shoot.mp3', 'shoot'),
        //     SoundGen.loadAudioFile('sounds/reload.mp3', 'reload'),
        //     SoundGen.loadAudioFile('sounds/hit.mp3', 'hit')
        // ]).then(() => console.log('All sounds loaded!'));
        //
        // 4. 기존 함수를 오디오 파일로 대체하려면:
        // playShoot: function(type) {
        //     // 기존 코드 대신:
        //     SoundGen.playAudioFile('shootSound', 1.0);
        // }

        // 성능 최적화: 리소스 로딩 완료 후 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            // 이미 로드 완료되었으면 바로 호출
            init();
        }

        function addSafeListener(el, handler) {
            if (!el) return;
            el.addEventListener('click', handler);
            el.addEventListener('touchend', (e) => {
                e.preventDefault();
                handler(e);
            }, { passive: false });
        }

        // [DEBUG] Diagnostic Tool for User Reporting
        function logWeaponDebugInfo() {
            console.group("=== WEAPON DEBUG INFO ===");
            console.log("Camera Pos:", camera.position);
            console.log("Camera Rot:", camera.rotation);

            if (weaponModel) {
                console.log("WeaponModel:", weaponModel);
                console.log("  Pos:", weaponModel.position);
                console.log("  Rot:", weaponModel.rotation);
                console.log("  Scale:", weaponModel.scale);
                console.log("  Visible:", weaponModel.visible);
                console.log("  Children Count:", weaponModel.children.length);

                weaponModel.children.forEach((child, i) => {
                    console.group(`  Child[${i}] (${child.type})`);
                    console.log("    UUID:", child.uuid);
                    console.log("    Visible:", child.visible);
                    console.log("    Pos:", child.position);
                    console.log("    Rot:", child.rotation);
                    console.log("    Scale:", child.scale);
                    if (child.geometry) console.log("    Geometry:", child.geometry.type);
                    if (child.material) console.log("    Material:", child.material.type, child.material.color);
                    console.groupEnd();
                });
            } else {
                console.error("weaponModel is undefined!");
            }
            console.groupEnd();
            alert("디버그 정보가 콘솔에 출력되었습니다. (F12 -> Console 탭 확인)");
        }

        // Key Listener for Debugging
        document.addEventListener('keydown', (e) => {
            if (e.key === '9') {
                logWeaponDebugInfo();
            }
            // Toggle currently active weapon debug panel with 'P'
            if (e.key === 'p' || e.key === 'P') {
                const currentWeapon = WEAPONS[curWeaponIdx];
                let panelId = '';
                if (currentWeapon.type === 'RIFLE') panelId = 'rifle-debug-panel';
                else if (currentWeapon.type === 'PISTOL') panelId = 'pistol-debug-panel';
                else if (currentWeapon.type === 'SNIPER') panelId = 'sniper-debug-panel';

                if (panelId) {
                    const panel = document.getElementById(panelId);
                    if (panel) {
                        panel.style.display = (panel.style.display === 'none' || panel.style.display === '') ? 'block' : 'none';
                    }
                }
            }
        });

        function init() {

            // [TASK] Automatic Fullscreen on Interaction (disabled)
            // const autoEnterFullscreen = (e) => {
            //     const panel = document.getElementById('rifle-debug-panel');
            //     if (panel && panel.contains(e.target)) return;
            //     enterFullscreen();
            // };
            // document.body.addEventListener('click', autoEnterFullscreen);
            // document.body.addEventListener('touchstart', autoEnterFullscreen, { passive: true });



            // UI References
            const modeSelection = document.getElementById('mode-selection');

            // Mouse wheel click to toggle aim lock (no firing)
            const toggleAimLock = (e) => {
                if (e.button !== 1) return;
                e.preventDefault();
                aimLocked = !aimLocked;
                isAiming = aimLocked;
                const scope = document.getElementById('sniper-scope');
                if (scope) scope.style.display = isAiming ? 'block' : 'none';
            };
            document.addEventListener('auxclick', toggleAimLock);
            document.addEventListener('mousedown', toggleAimLock);

            const nameSetup = document.getElementById('name-setup');
            const roomMenu = document.getElementById('room-menu');
            const createRoomModal = document.getElementById('create-room-modal');
            const roomWaiting = document.getElementById('room-waiting');
            const chatContainer = document.getElementById('chat-container');

            // --- UI 요소 초기화 (안전하게 init 내부로 이동) ---
            elAmmoCurrent = document.getElementById('hud-ammo-current');
            elAmmoReserve = document.getElementById('hud-ammo-reserve');
            elWeaponName = document.getElementById('hud-weapon-name');
            elCrosshair = document.getElementById('hud-crosshair');

            elVignette = document.getElementById('vignette');
            if (!elVignette) {
                elVignette = document.createElement('div');
                elVignette.id = 'vignette';
                document.body.appendChild(elVignette);
            }
            // Force critical styles
            elVignette.style.position = 'absolute';
            elVignette.style.top = '0'; elVignette.style.left = '0';
            elVignette.style.width = '100%'; elVignette.style.height = '100%';
            elVignette.style.background = 'radial-gradient(circle, transparent 50%, black 150%)';
            elVignette.style.opacity = '0';
            elVignette.style.transition = 'opacity 0.2s';
            elVignette.style.pointerEvents = 'none';
            elVignette.style.zIndex = '5';

            elScope = document.getElementById('scope-overlay');
            elHpBar = document.getElementById('hud-hp-bar');
            elHpGhost = document.getElementById('hud-hp-bar-ghost');
            elHpText = document.getElementById('hud-hp-text');
            elDamage = document.getElementById('hud-damage-vignette');

            elTimer = document.getElementById('hud-timer');
            elScoreAlly = document.getElementById('hud-score-ally');
            elScoreEnemy = document.getElementById('hud-score-enemy');
            elKillFeed = document.getElementById('hud-kill-feed');

            // Map Legacy UI variables to new HUD elements for compatibility
            elPlayTime = elTimer;
            // elKillCount maps to new HUD element if it exists
            elKillCount = document.getElementById('hud-kill-count');
            if (!elKillCount) elKillCount = { innerText: '' };

            elGameOver = document.getElementById('game-over');
            elPauseOverlay = document.getElementById('pause-overlay');
            elHeadshot = document.getElementById('headshot-msg');
            elGrenadeKill = document.getElementById('grenade-kill-msg');
            elHitMarker = document.getElementById('hit-marker');

            // Restart button - Add mobile touch support handlers (init 내부로 이동)
            const restartBtn = document.getElementById('restart-btn');
            addSafeListener(restartBtn, () => {
                if (typeof window.restartGame === 'function') window.restartGame();
                else if (typeof restartGame === 'function') restartGame();
            });

            // Ensure Crosshair is visible by default
            if (elCrosshair) {
                elCrosshair.style.display = 'block';
                elCrosshair.style.zIndex = '100'; // Force on top
            }

            // --- Load User Sounds ---
            SoundGen.loadAudioFile('sounds/uak.mp3', 'damage').catch(e => console.log('Damage sound (uak.mp3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/hit.MP3', 'hit').catch(e => console.log('Hit sound (hit.MP3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/headshot.mp3', 'headshot').catch(e => console.log('Headshot sound (headshot.mp3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/chak.MP3', 'land').catch(e => console.log('Land sound (chak.MP3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/walking.MP3', 'walking').catch(e => console.log('Walking sound (walking.MP3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/grunt.mp3', 'jump').catch(e => console.log('Jump sound (grunt.mp3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/grenade.mp3', 'grenade_explosion').catch(e => console.log('Grenade sound (grenade.mp3) not found or failed to load:', e));
            SoundGen.loadAudioFile('sounds/remove.mp3', 'grenade_switch').catch(e => console.log('Grenade switch sound (remove.mp3) not found or failed to load:', e));

            // 1. Mode Selection
            // modeSelection.style.display = 'flex'; // Handled by CSS: body:not(.game-active)

            addSafeListener(document.getElementById('btn-single-player'), () => {
                modeSelection.style.display = 'none'; // Explicitly hide to prevent overlap
                document.getElementById('single-map-selection').style.display = 'flex';
            });

            // Single Player Map Selection Handlers
            document.querySelectorAll('#single-map-selection .map-card').forEach(card => {
                addSafeListener(card, () => {
                    selectedSinglePlayerMap = card.dataset.map;
                    gameMode = 'single';
                    document.getElementById('single-map-selection').style.display = 'none';
                    document.body.classList.remove('multi-player');
                    document.body.classList.add('single-player');
                    document.body.classList.add('game-active');

                    enterFullscreen();
                    resetAmmo();

                    const randomSpawn = SINGLE_PLAYER_SPAWN_POINTS[Math.floor(Math.random() * SINGLE_PLAYER_SPAWN_POINTS.length)];
                    position.set(randomSpawn.x, randomSpawn.y, randomSpawn.z);

                    startGame();

                    const exitBtn = document.getElementById('exit-game-btn');
                    if (exitBtn) exitBtn.style.display = 'none';

                    const chatToggle = document.getElementById('chat-toggle-btn');
                    if (chatToggle) chatToggle.style.display = 'none';

                    if (isMobile) {
                        const weaponInv = document.getElementById('weapon-inventory');
                        if (weaponInv) {
                            weaponInv.style.display = 'none';
                            weaponInv.style.visibility = 'hidden';
                            weaponInv.style.opacity = '0';
                        }
                    }
                });
            });

            addSafeListener(document.getElementById('btn-back-to-mode-from-map'), () => {
                document.getElementById('single-map-selection').style.display = 'none';
                modeSelection.style.display = 'flex';
            });

            addSafeListener(document.getElementById('btn-multi-player'), () => {
                modeSelection.style.display = 'none'; // Explicitly hide to prevent overlap
                const serverAddr = 'http://localhost:3000';
                gameMode = 'multi';
                modeSelection.style.display = 'none';
                document.body.classList.remove('single-player');
                document.body.classList.add('multi-player');
                // 전체화면 요청 (모든 기기)
                enterFullscreen();

                // Skip name setup, go directly to room menu
                roomMenu.style.display = 'flex';

                // Connect to Server Lobby (Server will assign "Player N" automatically)
                if (!socket || !socket.connected) {
                    initMultiplayer(serverAddr, 'AutoPlayer');
                } else {
                    socket.emit('setIdentity', { name: 'AutoPlayer' });
                }

                // Show chat toggle in multiplayer
                const chatToggle = document.getElementById('chat-toggle-btn');
                if (chatToggle) chatToggle.style.display = 'flex';

                // Pre-load assets for multiplayer
                if (typeof preloadMultiplayerAssets === 'function') {
                    preloadMultiplayerAssets();
                }
            });

            // Exit Game Button Handler
            const exitGameHandler = () => {
                document.getElementById('exit-game-btn').style.display = 'none';
                document.body.classList.remove('game-active');

                if (gameMode === 'multi') {
                    // 멀티플레이어: 소켓에 방 나가기 알리고 로비로 이동
                    if (socket && socket.connected) {
                        socket.emit('leaveRoom');
                    }

                    // 게임 상태 초기화
                    isGameStarted = false;
                    isDead = false;
                    playerHP = 100;

                    // [FIX] Reset Low Health Overlay
                    const overlay = document.getElementById('low-health-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                        overlay.style.opacity = ""; // Clear inline opacity to allow CSS animation
                    }

                    // UI 초기화
                    document.getElementById('room-waiting').style.display = 'none';
                    chatContainer.style.display = 'none';
                    roomMenu.style.display = 'flex';

                    // 인게임 플레이어 리스트 숨기기
                    const igList = document.getElementById('ingame-players-list');
                    if (igList) igList.style.display = 'none';

                    // 타이머 UI 숨기기
                    const timerEl = document.getElementById('game-timer');
                    if (timerEl) timerEl.style.display = 'none';

                    // 방 목록 새로고침 요청
                    if (socket && socket.connected) {
                        socket.emit('setIdentity', { name: socket.userData ? socket.userData.name : 'Player' });
                    }
                } else {
                    // 싱글플레이어(좀비 모드): 페이지 새로고침
                    modeSelection.style.display = 'flex';
                    location.reload();
                }
            };
            addSafeListener(document.getElementById('exit-game-btn'), exitGameHandler);

            // 2. Name Setup
            addSafeListener(document.getElementById('btn-back-to-mode'), () => {
                nameSetup.style.display = 'none';
                modeSelection.style.display = 'flex';
            });

            document.getElementById('btn-confirm-name').addEventListener('click', () => {
                const name = document.getElementById('player-name-input').value.trim() || 'Player';
                const serverAddr = 'http://localhost:3000';

                gameMode = 'multi';
                nameSetup.style.display = 'none';
                roomMenu.style.display = 'flex'; // Show Lobby

                // Connect to Server Lobby
                if (!socket || !socket.connected) {
                    resetAmmo();
                    initMultiplayer(serverAddr, name);
                } else {
                    socket.emit('setIdentity', { name: name });
                }
            });

            // 3. Room Menu (Lobby)
            const btnBackToName = document.getElementById('btn-back-to-name');
            if (btnBackToName) {
                btnBackToName.addEventListener('click', () => {
                    roomMenu.style.display = 'none';
                    nameSetup.style.display = 'flex';
                    // Optional: Disconnect socket?
                });
            }

            // Back button to return to mode selection from room menu
            addSafeListener(document.getElementById('btn-back-to-mode-from-room'), () => {
                roomMenu.style.display = 'none';
                modeSelection.style.display = 'flex';
                document.body.classList.remove('game-active');
                // Optional: Disconnect socket?
            });

            // Restart Game logic is now consolidated in the global restartGame function below.

            // Weapon Inventory Click Handler (for both PC and mobile)
            // Use 'hud-weapon-selector' for new UI, fallback to 'weapon-inventory' if old exists
            const weaponSelector = document.getElementById('hud-weapon-selector') || document.getElementById('weapon-inventory');

            if (weaponSelector) {
                weaponSelector.addEventListener('click', (e) => {
                    const weaponSlot = e.target.closest('.weapon-slot');
                    if (weaponSlot) {
                        // Check both data-slot (new UI) and data-weapon-id (legacy)
                        let weaponId = parseInt(weaponSlot.dataset.slot);
                        if (isNaN(weaponId)) {
                            weaponId = parseInt(weaponSlot.dataset.weaponId);
                        }

                        if (!isNaN(weaponId)) {
                            switchWeaponTo(weaponId);
                        }
                    }
                });
            }

            // NEW: Weapon Selector Vertical (Icons) Click Handler
            const weaponSelectorVertical = document.getElementById('weapon-selector-vertical');
            if (weaponSelectorVertical) {
                weaponSelectorVertical.addEventListener('click', (e) => {
                    const btn = e.target.closest('.weapon-select-btn');
                    if (btn) {
                        const idx = parseInt(btn.dataset.idx);
                        if (!isNaN(idx)) {
                            switchWeaponTo(idx);
                        }
                    }
                });
                weaponSelectorVertical.addEventListener('touchend', (e) => {
                    const btn = e.target.closest('.weapon-select-btn');
                    if (btn) {
                        e.preventDefault();
                        const idx = parseInt(btn.dataset.idx);
                        if (!isNaN(idx)) {
                            switchWeaponTo(idx);
                        }
                    }
                });
            }


            // NEW: Weapon List Left (Icons) Touch/Click Handler for Mobile
            const weaponListLeft = document.getElementById('weapon-list-left');
            if (weaponListLeft) {
                weaponListLeft.addEventListener('click', (e) => {
                    const item = e.target.closest('.weapon-item');
                    if (item) {
                        const idMatch = item.id.match(/weapon-item-(\d+)/);
                        if (idMatch) {
                            const idx = parseInt(idMatch[1]);
                            if (!isNaN(idx)) {
                                switchWeaponTo(idx);
                            }
                        }
                    }
                });
                weaponListLeft.addEventListener('touchend', (e) => {
                    const item = e.target.closest('.weapon-item');
                    if (item) {
                        e.preventDefault();
                        const idMatch = item.id.match(/weapon-item-(\d+)/);
                        if (idMatch) {
                            const idx = parseInt(idMatch[1]);
                            if (!isNaN(idx)) {
                                switchWeaponTo(idx);
                            }
                        }
                    }
                });
            }

            addSafeListener(document.getElementById('btn-show-create-room'), () => {
                createRoomModal.style.display = 'flex';
                document.getElementById('new-room-name').focus();
            });

            addSafeListener(document.getElementById('btn-refresh-rooms'), () => {
                // Server sends updates automatically, but could request manual refresh if needed
                if (socket) socket.emit('setIdentity', { name: socket.userData ? socket.userData.name : 'Player' });
            });

            // Room list join handler (mobile-friendly)
            const roomListContainer = document.getElementById('room-list-container');
            if (roomListContainer) {
                roomListContainer.addEventListener('click', (e) => {
                    const btn = e.target.closest('.btn-join-room');
                    if (!btn || btn.disabled) return;
                    const roomId = btn.dataset.roomId;
                    if (roomId) window.joinRoom(roomId);
                });
                roomListContainer.addEventListener('touchend', (e) => {
                    const btn = e.target.closest('.btn-join-room');
                    if (!btn || btn.disabled) return;
                    e.preventDefault();
                    const roomId = btn.dataset.roomId;
                    if (roomId) window.joinRoom(roomId);
                }, { passive: false });
            }


            // 우클릭 메뉴 방지 (조준 기능과 충돌 방지)
            document.addEventListener('contextmenu', e => e.preventDefault());

            // 4. Create Room Modal
            addSafeListener(document.getElementById('btn-create-cancel'), () => {
                createRoomModal.style.display = 'none';
            });

            addSafeListener(document.getElementById('btn-create-confirm'), () => {
                const roomName = document.getElementById('new-room-name').value || '새 방';
                const maxPlayers = document.getElementById('new-room-max').value;
                const mapName = document.getElementById('new-room-map').value; // 맵 정보 가져오기

                if (socket && socket.connected) {
                    socket.emit('createRoom', {
                        name: roomName,
                        maxPlayers: maxPlayers,
                        map: mapName,
                        gameMode: document.getElementById('new-room-mode').value
                    });
                    createRoomModal.style.display = 'none';
                    // Expected to receive 'roomJoined' event
                } else {
                    alert('서버에 연결되지 않았습니다. 잠시 후 다시 시도하거나 새로고침하세요.');
                }
            });

            // 5. Room Waiting
            addSafeListener(document.getElementById('btn-leave-room'), () => {
                if (socket && socket.connected) {
                    socket.emit('leaveRoom');
                }
                roomWaiting.style.display = 'none';
                chatContainer.style.display = 'none';
                roomMenu.style.display = 'flex';
            });

            addSafeListener(document.getElementById('btn-start-game'), () => {
                if (socket && socket.connected) {
                    socket.emit('requestStart');
                }
            });

            // Chat Input
            const chatInput = document.getElementById('chat-input');
            const sendChat = () => {
                const msg = chatInput.value.trim();
                if (msg && socket && socket.connected) {
                    socket.emit('chatMessage', { message: msg });
                    chatInput.value = '';
                }
            };
            addSafeListener(document.getElementById('btn-send-chat'), sendChat);
            chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChat(); });

            // Force ammo reset on load to ensure correct values
            resetAmmo();

            // Global Join Function
            // Global Join Function
            window.joinRoom = function (roomId) {
                if (socket && socket.connected) {
                    socket.emit('joinRoom', roomId);
                }
            };

            // [FIX] Global Mode Selection Handlers
            window.selectSinglePlayer = function () {
                console.log("Single Player Selected");
                const modeSel = document.getElementById('mode-selection');
                const mapSel = document.getElementById('single-map-selection');
                if (modeSel) modeSel.style.display = 'none';
                if (mapSel) mapSel.style.display = 'flex';
            };

            window.selectMultiPlayer = function () {
                const modeSel = document.getElementById('mode-selection');
                if (modeSel) modeSel.style.display = 'none';

                const serverAddr = 'http://localhost:3000';
                gameMode = 'multi';
                document.body.classList.remove('single-player');
                document.body.classList.add('multi-player');

                enterFullscreen();

                // Skip name setup, go directly to room menu
                const roomMenu = document.getElementById('room-menu');
                if (roomMenu) roomMenu.style.display = 'flex';

                // Connect to Server Lobby (Server will assign "Player N" automatically)
                if (!socket || !socket.connected) {
                    initMultiplayer(serverAddr, 'AutoPlayer');
                } else {
                    socket.emit('setIdentity', { name: 'AutoPlayer' });
                }

                // Show chat toggle in multiplayer
                const chatToggle = document.getElementById('chat-toggle-btn');
                if (chatToggle) chatToggle.style.display = 'flex';

                // Pre-load assets for multiplayer
                if (typeof preloadMultiplayerAssets === 'function') {
                    preloadMultiplayerAssets();
                }
            };

            // [FIX] Global Create Room Handlers for Robustness
            window.openCreateRoomModal = function () {
                console.log("Opening Create Room Modal");
                if (createRoomModal) {
                    createRoomModal.style.display = 'flex';
                    const nameInput = document.getElementById('new-room-name');
                    if (nameInput) nameInput.focus();
                } else {
                    console.error("Create Room Modal not found!");
                }
            };

            window.closeCreateRoomModal = function () {
                if (createRoomModal) createRoomModal.style.display = 'none';
            };

            window.confirmCreateRoom = function () {
                const roomName = document.getElementById('new-room-name').value || '새 방';
                const maxPlayers = document.getElementById('new-room-max').value;
                const mapName = document.getElementById('new-room-map').value;

                if (socket && socket.connected) {
                    socket.emit('createRoom', {
                        name: roomName,
                        maxPlayers: maxPlayers,
                        map: mapName,
                        gameMode: document.getElementById('new-room-mode').value
                    });
                    closeCreateRoomModal();
                } else {
                    alert('서버에 연결되지 않았습니다. 잠시 후 다시 시도하거나 새로고침하세요.');
                }
            };
        }

        function initMultiplayer(addr, name) {
            try {
                // http:// 프로토콜 강제
                const connectionUrl = addr.startsWith('http') ? addr : `http://${addr}`;
                socket = io(connectionUrl, {
                    reconnectionAttempts: 5,
                    timeout: 10000,
                    transports: ['websocket', 'polling'],
                    extraHeaders: {
                        'ngrok-skip-browser-warning': 'true'
                    }
                });

                socket.on('connect', () => {
                    console.log('Connected to server');
                    myId = socket.id; // Assign myId on connection
                    console.log('myId set to:', myId);
                    // Send Identity
                    socket.emit('setIdentity', { name: name });
                    document.getElementById('room-waiting').querySelector('h2').innerText = '연결됨';
                });

                socket.on('connect_error', (error) => {
                    console.error('Connection Error:', error);
                    alert('서버 연결 실패: ' + error.message);
                });

                // --- Room System Events ---

                socket.on('roomListUpdated', (rooms) => {
                    const roomListContainer = document.getElementById('room-list-container');
                    roomListContainer.innerHTML = '';

                    if (rooms.length === 0) {
                        roomListContainer.innerHTML = '<div class="no-rooms-message">생성된 방이 없습니다.</div>';
                        return;
                    }

                    rooms.forEach(room => {
                        const roomEl = document.createElement('div');
                        roomEl.className = 'room-item';
                        const isFull = room.currentPlayers >= room.maxPlayers;
                        const statusClass = room.status === 'playing' ? 'playing' : (isFull ? 'full' : 'waiting');
                        const statusText = room.status === 'playing' ? '게임 중' : (isFull ? '만원' : '대기 중');

                        const mapNameDisp = room.map === 'factory' ? '창고' : '호텔';
                        const modeNameDisp = room.gameMode === 'ffa' ? '개인전' : '팀전';

                        roomEl.innerHTML = `
                            <div class="room-info">
                                <h3 style="color:var(--tactical-cyan); margin:0;">${room.name}</h3>
                                <p style="font-size:12px; opacity:0.7;">${mapNameDisp} | ${modeNameDisp}</p>
                            </div>
                            <div class="room-status">
                                <span class="status-badge ${statusClass}">${statusText}</span>
                                <span style="font-size:14px; margin: 0 15px;">${room.currentPlayers}/${room.maxPlayers} UNIT</span>
                                <button class="mode-btn btn-join-room" data-room-id="${room.id}" ${isFull ? 'disabled' : ''} style="min-width: 100px; font-size: 14px; padding: 10px 20px; margin: 0;">
                                    <span class="btn-text">JOIN</span>
                                </button>
                            </div>
                        `;
                        roomListContainer.appendChild(roomEl);
                    });
                });



                socket.on('roomJoined', (data) => {
                    // Update UI to Waiting Room
                    document.getElementById('room-menu').style.display = 'none';
                    document.getElementById('room-waiting').style.display = 'flex';
                    // Show chat only on PC; on mobile landscape it stays hidden (toggle via button)
                    const isMobileLandscape = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && window.innerWidth > window.innerHeight;
                    if (!isMobileLandscape) {
                        document.getElementById('chat-container').style.display = 'flex';
                    }

                    document.getElementById('room-title').innerText = data.roomName;
                    maxPlayers = data.maxPlayers || 4; // Save maxPlayers from server

                    // Save map & mode info
                    // Save map & mode info
                    currentMap = data.map || 'factory';
                    currentGameMode = data.gameMode || 'ffa';
                    gameMode = 'multi'; // CRITICAL: Sync global gameMode for start logic
                    console.log('Room map:', currentMap, 'Mode:', currentGameMode);

                    // Sync timer
                    if (data.timeLeft !== undefined) {
                        currentRoomTimeLeft = data.timeLeft;
                        updateTimerUI(data.timeLeft);
                    }

                    // [User Request] 난입 가능 (Late Join)
                    if (data.gameStarted) {
                        console.log('Joining mid-game!');
                        document.getElementById('room-waiting').style.display = 'none';
                        startGame(); // Immediately enter game

                        // [CRITICAL FIX] 난입 시 isGameStarted를 true로 설정
                        // startCountdown()을 거치지 않기 때문에 수동으로 설정해야 함
                        isGameStarted = true;
                        console.log('Late join: isGameStarted set to true');

                        // 기존 플레이어들의 메시 생성 (roomJoined에서 받은 players 사용)
                        setTimeout(() => {
                            if (window.scene && data.players) {
                                Object.values(data.players).forEach(p => {
                                    if (p.id !== myId && !otherPlayersMap[p.id]) {
                                        console.log('Late join: Creating mesh for existing player:', p.name);
                                        createRemotePlayer(p);
                                    }
                                });
                            }
                        }, 100); // scene 초기화 완료 후 실행
                    }

                    // Save own spawn position from server
                    const myData = data.players[myId];
                    if (myData && myData.position) {
                        position = new THREE.Vector3(
                            myData.position.x,
                            myData.position.y,
                            myData.position.z
                        );
                        console.log('Spawn position set from server:', position);
                    }

                    // Clear existing if scene exists
                    if (window.scene) {
                        Object.values(otherPlayersMap).forEach(mesh => scene.remove(mesh));
                    }
                    otherPlayersMap = {};
                    roomPlayersState = data.players; // Cache players

                    updatePlayersList(); // Updated from updateRoomPlayers

                    // Update start button based on player count
                    updateStartButtonState(data.isHost);

                    // Update Mobile Player Name Display
                    if (myId && data.players[myId]) {
                        const elMobileName = document.getElementById('mobile-player-name');
                        if (elMobileName) elMobileName.innerText = `ID: ${data.players[myId].name}`;
                    }
                });

                socket.on('playerJoined', (player) => {
                    roomPlayersState[player.id] = player;
                    updatePlayersList(); // Updated from updateRoomPlayers
                    addChatMessage('System', `${player.name}님이 입장했습니다.`, true);

                    // Update start button when player joins
                    const isHost = myId && roomPlayersState[myId];
                    if (isHost) updateStartButtonState(true);

                    // [User Request] 난입 지원: 게임 중이면 즉시 메시 생성
                    if (document.body.classList.contains('game-active') && window.scene) {
                        if (player.id !== myId && !otherPlayersMap[player.id]) {
                            createRemotePlayer(player);
                        }
                    }
                });

                socket.on('playerLeft', (playerId) => {
                    if (roomPlayersState[playerId]) {
                        addChatMessage('System', `${roomPlayersState[playerId].name}님이 퇴장했습니다.`, true);
                        delete roomPlayersState[playerId];
                    }
                    updatePlayersList(); // Updated from updateRoomPlayers

                    // Update start button when player leaves
                    const isHost = myId && roomPlayersState[myId];
                    if (isHost) updateStartButtonState(true);

                    const mesh = otherPlayersMap[playerId];
                    if (mesh) {
                        if (window.scene) scene.remove(mesh);
                        delete otherPlayersMap[playerId];
                    }
                });

                // Handle player numbers being reassigned after someone leaves
                socket.on('playersUpdated', (players) => {
                    roomPlayersState = players;
                    updatePlayersList();

                    // Update remote player name labels in 3D scene
                    Object.values(players).forEach(p => {
                        const mesh = otherPlayersMap[p.id];
                        if (mesh && mesh.userData.nameSprite) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 256;
                            canvas.height = 64;
                            const ctx = canvas.getContext('2d');
                            ctx.font = 'bold 32px Arial';
                            ctx.fillStyle = 'white';
                            ctx.textAlign = 'center';
                            ctx.fillText(p.name, 128, 40);
                            mesh.userData.nameSprite.material.map.dispose();
                            mesh.userData.nameSprite.material.map = new THREE.CanvasTexture(canvas);
                            mesh.userData.nameSprite.material.needsUpdate = true;
                        }
                    });

                    // Update own name display on mobile
                    if (myId && players[myId]) {
                        const elMobileName = document.getElementById('mobile-player-name');
                        if (elMobileName) elMobileName.innerText = 'ID: ' + players[myId].name;
                    }

                    addChatMessage('System', '플레이어 번호가 재정렬되었습니다.', true);
                });

                socket.on('timerSync', (data) => {
                    currentRoomTimeLeft = data.timeLeft;
                    updateTimerUI(data.timeLeft);
                });

                socket.on('gameEnded', (data) => {
                    alert(data.message);
                    location.reload(); // Simple way to reset state
                });

                socket.on('gameStart', (data) => {
                    console.log('Game Start Event Received with data:', data); // DEBUG

                    // 서버에서 받은 맵 정보로 설정
                    if (data && data.map) {
                        currentMap = data.map;
                        currentGameMode = data.gameMode || 'ffa';
                        gameMode = 'multi'; // CRITICAL: Sync global gameMode
                        updateTimerUI(data.timeLeft || 600);
                        console.log('Map set to:', currentMap, 'Mode:', currentGameMode);
                    }

                    document.getElementById('room-waiting').style.display = 'none';
                    // document.getElementById('chat-container').style.bottom = '20px'; // REMOVED: Respect CSS positioning

                    // Use spawn position from server (already set in roomJoined event)
                    // Only initialize if position is completely unset
                    if (!position) {
                        console.warn('Position not set! Using fallback (0, 1.7, 0)');
                        position = new THREE.Vector3(0, 1.7, 0);
                    }

                    // Camera position will be set after scene initialization in startGame()
                    // Store position for later use
                    console.log('Game will start at position:', position);

                    // Actual mesh creation is handled in startGame() -> createRemotePlayer
                    // This ensures scene is initialized first.

                    try {
                        console.log('Starting game and countdown...'); // DEBUG

                        // Start game logic first (Initialize scene, player, weapon)
                        startGame();

                        // Then start countdown overlay
                        startCountdown();
                    } catch (e) {
                        console.error('ERROR in startCountdown:', e);
                        isGameStarted = true;
                    }
                });



                socket.on('hostChanged', (hostId) => {
                    const startBtn = document.getElementById('btn-start-game');
                    startBtn.parentElement.style.display = (hostId === myId) ? 'block' : 'none';
                    addChatMessage('System', '방장이 변경되었습니다.', true);
                });

                socket.on('currentPlayers', (players) => {
                    // Legacy support if server still sends this... but server doesn't anymore.
                });

                // Chat
                socket.on('chatMessage', (data) => {
                    addChatMessage(data.sender, data.message);
                });

                // --- Game Events ---

                socket.on('playerMoved', (p) => {
                    // Game hasn't started yet
                    if (!window.scene) return;

                    // Update roomPlayersState for spectator camera
                    if (roomPlayersState[p.id]) {
                        roomPlayersState[p.id].position = p.position;
                        roomPlayersState[p.id].rotation = p.rotation;
                    }

                    const mesh = otherPlayersMap[p.id];
                    if (mesh) {
                        // Use server position for all axes (Adjusted to -0.8: -1.3 was sinking, 0 was floating)
                        mesh.position.set(p.position.x, p.position.y - 0.8, p.position.z);
                        // [FIX] Rotate 90 degrees (Math.PI / 2) to face correct direction relative to camera
                        mesh.rotation.y = p.rotation.y + Math.PI / 2;
                    } else {
                        // If player exists but no mesh (e.g. joined mid-game), create it
                        if (p.id !== myId) createRemotePlayer(p);
                    }
                });

                socket.on('playerActioned', (data) => {
                    if (!window.scene) return;

                    const mesh = otherPlayersMap[data.id];
                    if (mesh) {
                        if (data.action === 'switch') {
                            // Update weapon mesh when remote player switches weapons
                            const newWeaponIdx = data.weaponIdx;
                            if (newWeaponIdx !== undefined && mesh.userData.weaponIdx !== newWeaponIdx) {
                                mesh.userData.weaponIdx = newWeaponIdx;
                                // loadRemoteWeaponObj(mesh, newWeaponIdx); // Disabled per user request
                                console.log('Player', data.id, 'switched to weapon index:', newWeaponIdx);
                            }
                        } else if (data.action === 'shoot') {
                            SoundGen.playShoot(WEAPONS[data.weaponIdx].type);

                            // 나이프나 수류탄은 뮤즐 플래시 효과 제외
                            const wType = WEAPONS[data.weaponIdx].type;
                            if (wType === 'KNIFE' || wType === 'GRENADE') {
                                // No visuals for these actions in basic shoot handler
                            } else {
                                // Visual shoot effect - High Quality Muzzle Flash (Sync with Local)
                                if (!mesh.userData.muzzleFlash) {
                                    const points = 4;
                                    const outerRadius = 0.16 * 3; // Scaled up for visibility distance
                                    const innerRadius = 0.07 * 3;
                                    const muzzleShape = new THREE.Shape();
                                    for (let i = 0; i < points * 2; i++) {
                                        const r = (i % 2 === 0) ? outerRadius : innerRadius;
                                        const theta = (i / (points * 2)) * Math.PI * 2;
                                        const x = Math.cos(theta) * r;
                                        const y = Math.sin(theta) * r;
                                        if (i === 0) muzzleShape.moveTo(x, y);
                                        else muzzleShape.lineTo(x, y);
                                    }
                                    muzzleShape.closePath();

                                    const fGeo = new THREE.ShapeGeometry(muzzleShape);
                                    const fMat = new THREE.MeshBasicMaterial({
                                        color: 0xffbb77,
                                        transparent: true,
                                        opacity: 0,
                                        side: THREE.DoubleSide,
                                        blending: THREE.AdditiveBlending,
                                        depthWrite: false
                                    });
                                    const flash = new THREE.Mesh(fGeo, fMat);
                                    flash.visible = false;
                                    // Position Estimate: Slightly right, chest/head height, forward
                                    flash.position.set(0.2, 1.35, 1.2);
                                    mesh.add(flash);
                                    mesh.userData.muzzleFlash = flash;
                                }

                                const flash = mesh.userData.muzzleFlash;
                                flash.visible = true;
                                flash.material.opacity = 0.6 + Math.random() * 0.2;
                                flash.rotation.z = Math.random() * Math.PI * 2;
                                const s = 1.0 + Math.random() * 0.5;
                                flash.scale.set(s, s, 1);

                                // Remove flash after brief moment
                                setTimeout(() => {
                                    if (flash) {
                                        flash.visible = false;
                                        flash.material.opacity = 0;
                                    }
                                }, 50);

                                // Weapon recoil animation (find weapon child and animate)
                                const weapon = mesh.children.find(child => child.geometry && child.geometry.type === 'BoxGeometry' && child.material.color.getHex() === 0x222222);
                                if (weapon) {
                                    const originalZ = weapon.position.z;
                                    weapon.position.z -= 0.1; // Move back
                                    setTimeout(() => {
                                        weapon.position.z = originalZ; // Return to original
                                    }, 100);
                                }

                                // Upper body and arms recoil animation
                                mesh.children.forEach(child => {
                                    // Find arms
                                    if (child.geometry && child.geometry.type === 'CylinderGeometry' &&
                                        child.material.color && child.material.color.getHex() === 0xf4a460) {
                                        const originalRotX = child.rotation.x;
                                        const originalPosZ = child.position.z;
                                        child.rotation.x = originalRotX - 0.15;
                                        child.position.z = originalPosZ - 0.05;
                                        setTimeout(() => {
                                            child.rotation.x = originalRotX;
                                            child.position.z = originalPosZ;
                                        }, 100);
                                    }

                                    // Find body
                                    if (child.geometry && child.geometry.type === 'CylinderGeometry' &&
                                        child.material.color && child.material.color.getHex() === 0x4a90e2 &&
                                        child.position.y > 1.0) {
                                        const originalRotX = child.rotation.x;
                                        child.rotation.x = originalRotX - 0.08;
                                        setTimeout(() => {
                                            child.rotation.x = originalRotX;
                                        }, 100);
                                    }
                                });
                            }
                        }
                    }
                });

                socket.on('playerDamaged', (data) => {
                    if (data.id === myId) {
                        playerHP = data.hp;

                        // HP UI 업데이트
                        elHpBar.style.width = playerHP + '%';
                        elHpText.innerText = "HP: " + playerHP;

                        // HP에 따라 색상 변경
                        if (playerHP > 50) {
                            elHpBar.style.background = "#4caf50"; // 녹색
                        } else if (playerHP > 20) {
                            elHpBar.style.background = "#ff9800"; // 주황색
                        } else {
                            elHpBar.style.background = "#f44336"; // 빨간색
                        }

                        // 피격 효과
                        elDamage.style.opacity = 0.5;
                        setTimeout(() => elDamage.style.opacity = 0, 200);
                        hitShake.intensity = 0.1;
                        SoundGen.playHit();
                    } else {
                        const mesh = otherPlayersMap[data.id];
                        if (mesh) {
                            mesh.userData.hp = data.hp;
                            if (mesh.userData.hpBar) mesh.userData.hpBar.scale.x = Math.max(0, mesh.userData.hp / 100);
                        }
                    }
                });

                socket.on('playerDied', (data) => {
                    // [NEW] Update killer's score in client-side state
                    if (data.killerId && roomPlayersState[data.killerId]) {
                        roomPlayersState[data.killerId].kills = (roomPlayersState[data.killerId].kills || 0) + 1;
                        console.log(`Scoreboard Update: ${data.killerName} kills -> ${roomPlayersState[data.killerId].kills}`);
                    }

                    // [NEW] Show kill feed in multiplayer
                    addKillFeed(data.killerName || 'Unknown', data.victimName || 'Unknown', data.isHeadshot);

                    // [NEW] Trigger headshot overlay for both killer and victim
                    if (data.isHeadshot) {
                        if (data.id === myId || data.killerId === myId) {
                            elHeadshot.classList.add('active');
                            setTimeout(() => elHeadshot.classList.remove('active'), 500);
                            SoundGen.playHeadshot();
                        }
                    }

                    if (data.id === myId) {
                        console.log('=== YOU DIED ===');
                        console.log('Killed by:', data.killerName, '(ID:', data.killerId, ')');
                        console.log('Current otherPlayersMap:', Object.keys(otherPlayersMap));
                        console.log('Current roomPlayersState:', Object.keys(roomPlayersState));

                        playerHP = 0;
                        isDead = true;

                        // HP UI 업데이트
                        if (elHpBar) elHpBar.style.width = '0%';
                        if (elHpText) elHpText.innerText = "HP: 0";
                        if (elHpBar) elHpBar.style.background = "#f44336"; // 빨간색
                        isSpectating = true;
                        spectatingPlayerId = data.killerId;

                        console.log('Set spectatingPlayerId to:', spectatingPlayerId);

                        // Hide normal game UI
                        elGameOver.style.display = 'none';
                        elDamage.style.opacity = 0.8;
                        elDamage.style.background = 'radial-gradient(circle, rgba(0,0,0,0.9) 30%, rgba(255,0,0,0.6) 100%)';

                        // Show death overlay with killer info
                        const deathOverlay = document.getElementById('death-overlay');
                        const respawnTimerEl = document.getElementById('respawn-timer');
                        const killerNameEl = document.getElementById('killer-name');

                        deathOverlay.style.display = 'flex';
                        const manualRespawnBtn = document.getElementById('manual-respawn-btn');
                        if (manualRespawnBtn) manualRespawnBtn.style.display = 'none';

                        killerNameEl.innerText = data.killerName || 'Unknown';

                        // 3-second countdown (User requested 10s -> 3s)
                        let countdown = 3;
                        respawnTimerEl.innerText = countdown;

                        const countdownInterval = setInterval(() => {
                            countdown--;
                            respawnTimerEl.innerText = countdown;
                            console.log('Respawn countdown:', countdown, 'seconds remaining');
                            if (countdown <= 0) {
                                clearInterval(countdownInterval);
                                console.log('=== COUNTDOWN COMPLETE ===');

                                // Enable manual respawn button on the overlay as well
                                const respawnBtn = document.getElementById('manual-respawn-btn');
                                if (respawnBtn) {
                                    respawnBtn.style.display = 'block';
                                    respawnBtn.onclick = () => {
                                        if (socket && socket.connected) {
                                            console.log('Manual respawn requested');
                                            socket.emit('requestRespawn');
                                        }
                                    };
                                }

                                // Auto-Request respawn
                                if (socket && socket.connected) {
                                    console.log('Socket connected, sending requestRespawn...');
                                    socket.emit('requestRespawn');
                                } else {
                                    console.error('ERROR: Socket not connected! Cannot request respawn.');
                                    alert('서버와 연결이 끊어졌습니다. 새로고침 해주세요.');
                                }
                            }
                        }, 1000);
                    } else {
                        const mesh = otherPlayersMap[data.id];
                        if (mesh) {
                            // Death animation - Falling and fading out
                            let fallProgress = 0;
                            const fallDuration = 1000; // 1 second
                            const fallInterval = 16; // ~60fps
                            const fallSteps = fallDuration / fallInterval;

                            const originalRotation = { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z };
                            const originalScale = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };

                            const deathAnimation = setInterval(() => {
                                fallProgress++;
                                const progress = fallProgress / fallSteps;

                                // Rotate forward (falling motion)
                                mesh.rotation.x = originalRotation.x + (Math.PI / 2) * progress;

                                // Move down slightly
                                mesh.position.y = -0.5 * progress;

                                // Fade out all children (make transparent)
                                mesh.traverse((child) => {
                                    if (child.material) {
                                        if (!child.userData.originalOpacity) {
                                            child.userData.originalOpacity = child.material.opacity !== undefined ? child.material.opacity : 1;
                                        }
                                        child.material.transparent = true;
                                        child.material.opacity = child.userData.originalOpacity * (1 - progress);
                                    }
                                });

                                // Shrink slightly
                                const scale = 1 - (0.3 * progress);
                                mesh.scale.set(originalScale.x * scale, originalScale.y * scale, originalScale.z * scale);

                                if (fallProgress >= fallSteps) {
                                    clearInterval(deathAnimation);
                                    // Remove from scene after animation
                                    scene.remove(mesh);
                                    delete otherPlayersMap[data.id];
                                }
                            }, fallInterval);
                        }
                    }
                });

                socket.on('respawnDenied', (data) => {
                    console.warn(`Respawn denied by server. Too early. Waiting ${data.remainingTime}s...`);
                    // Retry automatically after 1 second
                    setTimeout(() => {
                        if (socket && socket.connected) {
                            console.log('Retrying respawn request...');
                            socket.emit('requestRespawn');
                        }
                    }, 1000);
                });

                socket.on('playerRespawned', (data) => {
                    console.log('Respawn:', data);
                    if (data.id === myId) {
                        playerHP = 100;
                        isDead = false;
                        isSpectating = false;
                        spectatingPlayerId = null;

                        // HP UI 업데이트
                        elHpBar.style.width = '100%';
                        elHpText.innerText = 'HP: 100';
                        elHpBar.style.background = '#4caf50'; // 녹색

                        // Update BOTH position variable and camera
                        position.set(data.position.x, data.position.y, data.position.z);
                        camera.position.copy(position);

                        // Hide death overlay
                        document.getElementById('death-overlay').style.display = 'none';
                        elGameOver.style.display = 'none';
                        elDamage.style.opacity = 0;
                    } else {
                        // Remote player respawned - completely recreate to avoid transparent material bug
                        const oldMesh = otherPlayersMap[data.id];
                        if (oldMesh) {
                            scene.remove(oldMesh);
                            // Deep cleanup to prevent memory leaks and "invisible" ghosts
                            oldMesh.traverse(child => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                                    else child.material.dispose();
                                }
                            });
                            delete otherPlayersMap[data.id];
                        }
                        // Create fresh player mesh
                        createRemotePlayer(data);
                        console.log('Re-created mesh for respawned player:', data.id);
                    }
                });

                // Helpers
                function updateRoomPlayers(playersMap) {
                    const list = document.getElementById('players-list');
                    list.innerHTML = '';
                    document.getElementById('player-count').innerText = `${Object.keys(playersMap).length}/4`;

                    Object.values(playersMap).forEach(p => {
                        const el = document.createElement('div');
                        el.style.fontSize = '20px';
                        el.style.margin = '10px';
                        el.innerText = p.name;
                        list.appendChild(el);

                        // Also populate global or local list for 3D creation later
                        if (p.id !== myId && !otherPlayersMap[p.id]) {
                            // We don't create 3D model in lobby, but we can when game starts.
                            // For now, let's just create it on game start.
                        }
                    });
                }

                function addChatMessage(sender, msg, isSystem) {
                    const chatMessages = document.getElementById('chat-messages');
                    const msgEl = document.createElement('div');
                    msgEl.className = 'chat-msg' + (isSystem ? ' system' : '');
                    msgEl.innerHTML = `<span class="sender">${sender}:</span> ${msg}`;
                    chatMessages.appendChild(msgEl);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }

                function updateStartButtonState(isHost) {
                    const startBtn = document.getElementById('btn-start-game');
                    if (!startBtn || !startBtn.parentElement) return;

                    const playerCount = Object.keys(roomPlayersState).length;

                    if (isHost) {
                        startBtn.parentElement.style.display = 'block';
                        if (playerCount >= 2) {
                            startBtn.disabled = false;
                            startBtn.style.opacity = '1';
                            startBtn.style.cursor = 'pointer';
                            startBtn.title = '';
                        } else {
                            startBtn.disabled = true;
                            startBtn.style.opacity = '0.5';
                            startBtn.style.cursor = 'not-allowed';
                            startBtn.title = '최소 2명의 플레이어가 필요합니다';
                        }
                    } else {
                        startBtn.parentElement.style.display = 'none';
                    }
                }

            } catch (e) {
                console.error('Socket init error:', e);
            }
        }

        function createRemotePlayer(p) {
            // [FIX] Prevent multiple meshes and race conditions
            if (otherPlayersMap[p.id]) return;

            console.log('createRemotePlayer called for:', p);

            const group = new THREE.Group();
            // Register IMMEDIATELY to prevent duplicate calls during async loads
            otherPlayersMap[p.id] = group;

            // Set user data immediately
            group.userData.hp = p.hp || 100;
            group.userData.maxHp = 100;
            group.userData.playerId = p.id;
            group.userData.weaponIdx = p.weaponIdx !== undefined ? p.weaponIdx : 0;
            group.userData.playerName = p.name || 'Unknown';

            // ... (rest of the username label creation remains same) ...

            // Create username label sprite (red text above player)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // Draw red text on transparent background
            context.fillStyle = 'rgba(0, 0, 0, 0.5)';
            // context.fillRect(0, 0, canvas.width, canvas.height); // Removed background
            context.font = 'bold 32px Arial';
            context.fillStyle = '#ff3333';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(p.name || 'Unknown', canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false  // Always visible through walls
            });
            const nameSprite = new THREE.Sprite(spriteMaterial);
            nameSprite.scale.set(2, 0.5, 1);
            nameSprite.position.y = 1.1; // Lowered (2.2 was too high at 2x scale)
            group.add(nameSprite);
            group.userData.nameSprite = nameSprite;

            // Load GLB character model
            // Load GLB character model using Cache
            const modelUrl = './char/cr.glb';
            let model = getClonedModel(modelUrl);

            function setupModel(m) {
                // Adjust scale and position of the loaded model
                m.scale.set(1, 1, 1);
                m.position.y = 0;

                // Enable shadows
                m.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // Find head & limbs for hit detection
                m.traverse((child) => {
                    const lowName = child.name ? child.name.toLowerCase() : "";

                    if (lowName.includes('head')) {
                        group.userData.head = child;
                        child.name = 'head';
                        child.userData.isHead = true;
                        child.traverse(c => {
                            if (c.isMesh) {
                                c.name = 'head';
                                c.userData.isHead = true;
                            }
                        });
                    } else if (lowName.includes('arm') || lowName.includes('leg') || lowName.includes('hand') || lowName.includes('foot')) {
                        child.userData.isLimb = true;
                        // For Mixamo rigs, arms/legs are often bones, but we want the meshes too
                        if (child.isMesh) {
                            child.userData.isLimb = true;
                        }
                    }
                });

                // Find right arm for weapon attachment (Expanded Search)
                m.traverse((child) => {
                    const n = child.name ? child.name.toLowerCase() : "";
                    // DEBUG: Log bone names to find the correct one
                    // if (child.isBone) console.log('Bone found:', child.name);

                    if (n.includes('rightarm') || n.includes('arm.r') || n.includes('hand.r') || n.includes('rhand') ||
                        n.includes('right_hand') || n.includes('mixamorigrighthand') || n.includes('hold_r')) {
                        if (!group.userData.rArm) group.userData.rArm = child;
                    }
                });

                // Fallback 1: Try Spine/Chest if Arm not found
                if (!group.userData.rArm) {
                    m.traverse((child) => {
                        const n = child.name ? child.name.toLowerCase() : "";
                        if (!group.userData.rArm && (n.includes('spine') || n.includes('chest') || n.includes('body'))) {
                            group.userData.rArm = child;
                            console.log('Using Spine/Chest as weapon anchor:', child.name);
                        }
                    });
                }

                // Fallback 2: Dummy Anchor (Lowered to chest height)
                // If still no rArm, do NOT use the model root directly as it puts gun at feet.
                if (!group.userData.rArm) {
                    console.warn(`[RemotePlayer] No suitable bone found for ${p.name}. Creating dummy anchor.`);
                    // Create a dummy object at approximate chest/hand height (Lowered from 1.3 to 0.75)
                    const dummyArm = new THREE.Object3D();
                    dummyArm.position.set(0.2, 0.75, 0.4);
                    m.add(dummyArm);
                    group.userData.rArm = dummyArm;
                }

                group.add(m);
                group.userData.model = m;

                // Load initial weapon - DISABLED: User confirmed model has embedded weapon
                /* 
                if (typeof loadRemoteWeaponObj === 'function') {
                    const wIdx = p.weaponIdx !== undefined ? p.weaponIdx : 0;
                    loadRemoteWeaponObj(group, wIdx);
                }
                */
            }

            if (model) {
                setupModel(model);
                console.log('Using cached character model for:', p.name);
            } else {
                // Fallback if not cached yet (load normally)
                loadModelCached(modelUrl).then(() => {
                    const m = getClonedModel(modelUrl);
                    if (m) setupModel(m);
                }).catch(e => {
                    console.error('Failed to load character GLB:', e);
                    // Fallback: simple box
                    const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    const fallbackMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 1.5, 0.3),
                        fallbackMat
                    );
                    fallbackMesh.position.y = 0.75;
                    group.add(fallbackMesh);
                    group.userData.head = fallbackMesh;
                });
            }

            // Ensure scene exists before adding
            if (window.scene) {
                group.scale.set(2.0, 2.0, 2.0);
                group.position.set(p.position.x, p.position.y - 0.8, p.position.z);

                if (p.rotation !== undefined) {
                    const rotY = (typeof p.rotation === 'object') ? p.rotation.y : p.rotation;
                    group.rotation.y = rotY + Math.PI / 2; // [FIX] Align with camera (90 deg offset)
                }

                scene.add(group);
                if (typeof otherPlayers !== 'undefined' && !otherPlayers.includes(group)) otherPlayers.push(group);
                console.log('Remote player group added to scene for:', p.name);

                // [FIX] Ensure visibility logic runs
                if (window.refreshUI) window.refreshUI();
            } else {
                console.error('Window.scene is missing in createRemotePlayer!');
            }
        }

        function loadRemoteWeaponObj(playerGroup, weaponIdx) {
            const w = WEAPONS[weaponIdx];
            if (!w) return;

            const rArm = playerGroup.userData.rArm;
            if (!rArm) return;

            // Remove existing weapon (Aggressive cleanup)
            // 1. Remove tracked mesh
            if (playerGroup.userData.weaponMesh) {
                if (playerGroup.userData.weaponMesh.parent) {
                    playerGroup.userData.weaponMesh.parent.remove(playerGroup.userData.weaponMesh);
                }
                playerGroup.userData.weaponMesh = null;
            }
            // 2. Remove ANY other children that might be weapons (safety net)
            // Search the entire playerGroup just in case a weapon was parented elsewhere
            // Also check by NAME in case isWeapon tag was missed
            const weaponNames = ['Assault Rifle', 'pistol', 'Sniper', 'Knife', 'gun'];
            playerGroup.traverse(child => {
                const cName = child.name ? child.name.toLowerCase() : '';
                const isWeaponName = weaponNames.some(w => cName.includes(w.toLowerCase()));

                if ((child.userData && child.userData.isWeapon) || isWeaponName) {
                    // Don't remove the group itself or the player model parts (if they happen to be named weirdly, unlikely)
                    // But 'Assault Rifle' etc are specific enough.
                    if (child.parent) {
                        console.log('Removing ghost weapon:', child.name);
                        child.parent.remove(child);
                    }
                }
            });

            // 3. Specific cleanup for rArm just to be triple sure
            for (let i = rArm.children.length - 1; i >= 0; i--) {
                const child = rArm.children[i];
                // Check name again
                const cName = child.name ? child.name.toLowerCase() : '';
                const isWeaponName = weaponNames.some(w => cName.includes(w.toLowerCase()));

                if ((child.userData && child.userData.isWeapon) || isWeaponName) {
                    rArm.remove(child);
                }
            }

            // Define Model Path & Transforms
            let modelPath = null;
            let scale = 1.0;
            // Hand Local Offset (Adjusting to fit end of lower arm)
            let offset = new THREE.Vector3(0, -0.25, 0.1);
            let rotation = new THREE.Vector3(0, Math.PI, 0);

            if (w.type === 'RIFLE') {
                modelPath = 'gun/Assault Rifle.glb';
                scale = 0.5;
                offset.set(0, -0.4, 0.3);
                rotation.set(0, Math.PI, 0);
            } else if (w.type === 'PISTOL') {
                modelPath = 'gun/pistol.glb';
                scale = 0.2;
                offset.set(0, -0.3, 0.15);
            } else if (w.type === 'SNIPER') {
                modelPath = 'gun/Sniper.glb';
                scale = 0.64;
                offset.set(0, -0.4, 0.4);
            } else if (w.type === 'KNIFE') {
                modelPath = 'gun/Knife.glb';
                scale = 0.8;
                offset.set(0, -0.3, 0.1);
                rotation.set(Math.PI / 2, Math.PI, 0);
            }

            if (modelPath) {
                let model = getClonedModel(modelPath);

                function setupWeapon(m) {
                    m.traverse(c => {
                        if (c.isMesh) {
                            c.castShadow = true;
                            c.receiveShadow = true;
                        }
                    });
                    m.scale.set(scale, scale, scale);
                    m.position.copy(offset);
                    m.rotation.set(rotation.x, rotation.y, rotation.z);

                    // Mark as weapon for cleanup
                    m.userData.isWeapon = true;

                    rArm.add(m);
                    playerGroup.userData.weaponMesh = m;
                }

                if (model) {
                    setupWeapon(model);
                } else {
                    // Fallback to load
                    loadModelCached(modelPath).then(() => {
                        const m = getClonedModel(modelPath);
                        if (m) setupWeapon(m);
                    }).catch(e => {
                        console.error('Failed to load remote weapon:', modelPath, e);
                        const geo = new THREE.BoxGeometry(0.08, 0.08, 0.4);
                        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        mesh.position.set(0, -0.4, 0.2);
                        mesh.userData.isWeapon = true; // Mark fallback too
                        rArm.add(mesh);
                        playerGroup.userData.weaponMesh = mesh;
                    });
                }
            }
        }

        const loadAudioFiles = () => {
            if (!SoundGen.ctx) SoundGen.init();
            if (SoundGen.ctx.state === 'suspended') SoundGen.ctx.resume();

            // 재장전 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/reload1.mp3', 'reload')
                .catch(err => console.warn('Failed to load reload sound:', err));

            // 저격총 발사 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/rifle.mp3', 'rifle')
                .catch(err => console.warn('Failed to load rifle sound:', err));

            // 나이프 휘두르기 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/sword.mp3', 'sword')
                .catch(err => console.warn('Failed to load sword sound:', err));

            // 나이프 교체 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/c-sword.mp3', 'c-sword')
                .catch(err => console.warn('Failed to load c-sword sound:', err));

            // 소총 교체 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/c-sochong.mp3', 'c-sochong')
                .catch(err => console.warn('Failed to load c-sochong sound:', err));

            // 권총 교체 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/c-gun.mp3', 'c-gun')
                .catch(err => console.warn('Failed to load c-gun sound:', err));

            // 저격총 교체 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/c-rifle.mp3', 'c-rifle')
                .catch(err => console.warn('Failed to load c-rifle sound:', err));

            // 빈 격발 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/empty.mp3', 'empty')
                .catch(err => console.warn('Failed to load empty sound:', err));

            // 권총 발사 오디오 파일 로드
            SoundGen.loadAudioFile('sounds/gunshot.mp3', 'gunshot')
                .catch(err => console.warn('Failed to load gunshot sound:', err));

            // [NEW] 착지 및 기타 효과음 로드
            SoundGen.loadAudioFile('sounds/chak.MP3', 'land')
                .catch(err => console.warn('Failed to load land sound:', err));

            SoundGen.loadAudioFile('sounds/grunt.mp3', 'jump')
                .catch(err => console.warn('Failed to load jump sound:', err));

            SoundGen.loadAudioFile('sounds/walking.MP3', 'walking')
                .catch(err => console.warn('Failed to load walking sound:', err));

            SoundGen.loadAudioFile('sounds/headshot.mp3', 'headshot')
                .catch(err => console.warn('Failed to load headshot sound:', err));
        };

        // 데스크톱과 모바일 모두에서 오디오 파일 로드
        document.body.addEventListener('mousedown', loadAudioFiles, { once: true });
        document.body.addEventListener('touchstart', loadAudioFiles, { once: true });

        // Global restartGame handler is already attached above

        // 조명 토글 버튼 이벤트 - 삭제됨 (사용자 요청)
        /*
        const lightToggleBtn = document.getElementById('light-toggle-btn');
        if (lightToggleBtn) {
            const toggleLight = () => {
                if (ceilingLight && ambientLight) {
                    ceilingLight.visible = !ceilingLight.visible;
                    if (ceilingLight.visible) {
                        // 조명 켤 때 더 밝게
                        ceilingLight.intensity = 2.5;
                        ambientLight.intensity = 0.7;
                    } else {
                        // 조명 끌 때 원래대로
                        ceilingLight.intensity = 2.0;
                        ambientLight.intensity = 0.4;
                    }
                    lightToggleBtn.classList.toggle('active', ceilingLight.visible);
                }
            };
            addSafeListener(lightToggleBtn, (e) => {
                e.stopPropagation();
                toggleLight();
            });
        }
        */

        // setupControls와 animate는 startGame()에서 호출됨

        // 화면 회전 감지 및 레이아웃 조정
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                onResize();
                // 모바일 컨트롤 위치 재조정 (필요시 추가)
            }, 300); // 모바일 브라우저 주소창 애니메이션 대기
        });

        // visualViewport 변경 감지 (모바일 브라우저 주소창 표시/숨김)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                onResize();
            });
            window.visualViewport.addEventListener('scroll', () => {
                // 스크롤 방지
                window.scrollTo(0, 0);
            });
        }

        // 추가 리사이즈 이벤트 (모바일 브라우저 주소창 대응)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                onResize();
            }, 100);
        });



        // --- 게임 재시작 함수 (통합형) ---
        function restartGame() {
            console.log('restartGame() called, mode:', gameMode);

            // 1. 공통 UI 초기화
            const elGameOver = document.getElementById('game-over');
            if (elGameOver) elGameOver.style.display = 'none';
            const deathOverlay = document.getElementById('death-overlay');
            if (deathOverlay) deathOverlay.style.display = 'none';
            const elDamage = document.getElementById('damage-overlay');
            if (elDamage) elDamage.style.opacity = 0;
            const elPauseOverlay = document.getElementById('pause-overlay');
            if (elPauseOverlay) elPauseOverlay.style.display = 'none';

            // 2. 공통 상태 초기화
            isDead = false;
            playerHP = 100;
            isPaused = false;
            if (typeof spawnTimer !== 'undefined') spawnTimer = 0;

            // 3. UI 바 초기화
            const hpBar = document.getElementById('hp-bar');
            const hpText = document.getElementById('hp-text');
            if (hpBar) hpBar.style.width = '100%';
            if (hpText) hpText.innerText = 'HP: 100';

            // 혼자하기 모드: 바로 재시작 (User Request)
            if (gameMode === 'single') {
                console.log('Restarting Single Player Game immediately...');

                // 적 및 아이템 제거
                if (typeof enemies !== 'undefined') {
                    enemies.forEach(e => scene.remove(e));
                    enemies = [];
                }
                if (typeof healthPills !== 'undefined') {
                    healthPills.forEach(pill => scene.remove(pill));
                    healthPills = [];
                }

                // 탄약 및 위치 리셋 (안전한 스폰 위치 - Random)
                if (typeof resetAmmo === 'function') resetAmmo();
                if (typeof position !== 'undefined') {
                    const randomSpawn = SINGLE_PLAYER_SPAWN_POINTS[Math.floor(Math.random() * SINGLE_PLAYER_SPAWN_POINTS.length)];
                    position.set(randomSpawn.x, randomSpawn.y, randomSpawn.z);
                }

                // 게임 통계 리셋
                gameStartTime = performance.now();
                killCount = 0;
                playTime = 0;
                playerHP = 100;
                isDead = false;
                isSpectating = false;
                spectatingPlayerId = null;

                const elPlayTime = document.getElementById('play-time');
                const elKillCount = document.getElementById('kill-count');
                if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
                if (elKillCount) elKillCount.innerText = "Kills: 0";

                // 게임 엔진 시작
                startGame();

                // 마우스 포인트 락 활성화 요청 (데스크톱)
                if (!isMobile) {
                    document.body.requestPointerLock();
                }
            }
            // 멀티플레이어 모드: 대기실로 이동 및 리스폰 요청
            else if (gameMode === 'multi') {
                // 멀티플레이어는 상황에 따라 reload가 필요할 수 있으나, 
                // 여기서는 최대한 lobby로 복귀를 시도함
                const roomWaiting = document.getElementById('room-waiting');
                if (roomWaiting) roomWaiting.style.display = 'flex';

                if (socket && socket.connected) {
                    socket.emit('requestRespawn');
                } else {
                    // 소켓 끊겼으면 어쩔 수 없이 새로고침
                    location.reload();
                }
            }
        }
        window.restartGame = restartGame; // 전역 바인딩 보장

        // --- 게임 시작 카운트다운 ---
        function startCountdown() {
            console.log('startCountdown() called'); // DEBUG
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 5;
            countdownEl.innerText = count;

            // Block game loop updates while counting down
            isGameStarted = false;
            if (window.weaponModel) window.weaponModel.visible = false; // Hide weapon during countdown

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.innerText = count;
                    SoundGen.playBeep();
                } else {
                    clearInterval(interval);

                    // Show GO!
                    countdownEl.innerText = "GO!";
                    SoundGen.playBeep(); // Option: Different pitch for GO? 

                    setTimeout(() => {
                        countdownEl.style.display = 'none';
                        if (window.weaponModel) window.weaponModel.visible = true; // Show weapon

                        if (gameMode === 'multi') {
                            isGameStarted = true; // Unlock game loop
                            console.log('Multiplayer Match Started!');
                        } else if (gameMode === 'single') {
                            isGameStarted = true;
                        }
                    }, 1000); // 1 second delay while showing GO!
                }
            }, 1000);
        }

        // Enter key to open chat
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                const chatInput = document.getElementById('chat-input');
                // Only if not already typing and in multiplayer game
                if (document.activeElement !== chatInput) {
                    // Check if game is running (multiplayer)
                    const chatContainer = document.getElementById('chat-container');
                    const isVisible = chatContainer && chatContainer.style.display !== 'none';

                    // Allow opening chat if we are in multiplayer mode
                    if (gameMode === 'multi') {
                        e.preventDefault();
                        if (document.pointerLockElement) {
                            document.exitPointerLock();
                        }
                        chatInput.focus();
                    }
                }
            }
        });

        async function loadJsonMap(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const mapData = await response.json();
                createCustomMap(mapData);
                console.log(`Map ${url} loaded successfully via fetch`);
            } catch (err) {
                console.error(`Error loading map ${url}:`, err);
                createFactoryMap();
            }
        }

        // --- 게임 시작 함수 ---
        async function startGame() {
            if (window.isGameInitialized) return;
            window.isGameInitialized = true;
            console.log('startGame() CALLED'); // DEBUG
            console.log('Current gameMode:', gameMode); // DEBUG: Check mode

            // 전체화면 요청 제거 (소켓 이벤트 등 비동기 호출 시 오류 방지)
            // 버튼 핸들러(btn-single-player 등)에서 이미 처리됨
            // enterFullscreen(); 

            // 게임 활성화 클래스 추가
            document.body.classList.add('game-active');

            // 0. 게임 통계 초기화
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            const gameOverTitle = document.getElementById('game-over-title');
            if (gameOverTitle) gameOverTitle.innerText = 'YOU DIED';
            const gameOverKills = document.getElementById('final-kill-count');
            if (gameOverKills) gameOverKills.innerText = killCount;

            // [User Request] 멀티플레이어 매치 타이머 초기값 표시

            if (gameMode === 'multi') {
                // 서버 연동 시에는 서버에서 받은 timeLeft를 보여줌
                // timeLeft가 있으면 즉시 UI 업데이트, 없으면 10분 기본값
                const initialTime = (typeof currentRoomTimeLeft !== 'undefined') ? currentRoomTimeLeft : 600;
                updateTimerUI(initialTime);
            } else {
                singlePlayerTimeLeft = 600;
                updateTimerUI(singlePlayerTimeLeft);
            }
            if (elKillCount) elKillCount.innerText = `Kills: ${killCount}`;


            // HP Bar Reset
            if (elHpBar) {
                elHpBar.style.width = '100%';
                elHpBar.style.background = '#4caf50'; // Reset color
                if (elHpText) elHpText.innerText = Math.floor(playerHP);
            }


            // 1. 엔진 초기화
            initGame();

            // Show light toggle button during gameplay
            const lightToggleBtn = document.getElementById('light-toggle-btn');
            if (lightToggleBtn) {
                if (gameMode === 'single' && !isMobile) {
                    lightToggleBtn.style.display = 'none';
                } else {
                    lightToggleBtn.style.display = 'flex';
                }
            }


            // 1.5. 멀티플레이어 맵 생성 (currentMap은 gameStart 이벤트에서 설정됨)
            if (gameMode === 'multi') {
                console.log('Creating map for multiplayer:', currentMap);

                // Clear map group before creating new map
                if (mapGroup) {
                    mapGroup.clear();
                } else {
                    // mapGroup이 없으면(드문 경우) 새로 생성
                    mapGroup = new THREE.Group();
                    scene.add(mapGroup);
                }

                if (currentMap === 'hotel') {
                    createHotelMap();
                } else if (currentMap === 'test') {
                    await loadJsonMap('map/c.json');
                } else {
                    createFactoryMap(); // 기본값
                }

                // Show exit button for multiplayer
                const exitBtn = document.getElementById('exit-game-btn');
                if (exitBtn) exitBtn.style.display = 'flex';

                // Show ingame player list overlay
                const igList = document.getElementById('ingame-players-list');
                if (igList) igList.style.display = 'block';
            }
            // 1.6. 싱글플레이어 맵 생성 (강제 재생성)
            else if (gameMode === 'single') {
                console.log(`Loading Single Player Map: ${selectedSinglePlayerMap}`);

                // Clear map group before creating new map
                if (mapGroup) {
                    mapGroup.clear();
                } else {
                    mapGroup = new THREE.Group();
                    scene.add(mapGroup);
                }

                // 싱글플레이어 맵 로드
                if (selectedSinglePlayerMap === 'hotel') {
                    createHotelMap();
                } else if (selectedSinglePlayerMap === 'test') {
                    await loadJsonMap('map/c.json');
                } else if (selectedSinglePlayerMap === 'bridge') {
                    await loadJsonMap('map/dari.json');
                } else {
                    createFactoryMap(); // Default
                }

                // [CRITICAL FIX] Force Start Game Loop for Single Player
                isGameStarted = true;

                // [CRITICAL FIX] Ensure Environment (Background/Fog) is correct
                // (Fixes darkness if initGame was skipped)
                if (scene) {
                    scene.background = new THREE.Color(0x87CEEB);
                    scene.fog = new THREE.Fog(0x87CEEB, 10, 150);
                }

                // [CRITICAL FIX] Re-initialize Player State & Camera
                // (Fixes camera being stuck at 0,0,0 or dead state)
                initPlayer();
                isDead = false;
                playerHP = 100;

                // [FIX] Reset Low Health Overlay
                const overlay = document.getElementById('low-health-overlay');
                if (overlay) {
                    overlay.classList.remove('active');
                    overlay.style.opacity = ""; // Clear inline opacity to allow CSS animation
                }

                // Ensure lighting exists (in case scene was cleared or invalid)
                // Simply checking if we have lights, if not, add them.
                const lights = scene.children.filter(c => c.isLight);
                if (lights.length === 0) {
                    console.log('Restoring missing lights...');
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(50, 50, 50);
                    scene.add(dirLight);
                }
            }

            // 2. 룸에 있는 다른 플레이어 메시 생성
            // (게임 시작 시점에 로비에 있던 플레이어들을 3D 씬에 추가)
            console.log('startGame: Creating meshes for remote players...', roomPlayersState);
            if (roomPlayersState && window.scene) {
                Object.values(roomPlayersState).forEach(p => {
                    if (p.id !== myId && !otherPlayersMap[p.id]) {
                        createRemotePlayer(p);
                    }
                });
            }

            // 2.5. 혼자하기 모드일 때 적 생성
            if (gameMode === 'single') {
                for (let i = 0; i < 6; i++) createEnemyAI();
            }

            // Pause Overlay Click -> Resume & Fullscreen (User Request)
            const elPauseOverlay = document.getElementById('pause-overlay');
            if (elPauseOverlay) {
                elPauseOverlay.addEventListener('click', () => {
                    if (isPaused) {
                        isPaused = false;
                        elPauseOverlay.style.display = 'none';
                        // Resume Pointer Lock
                        document.body.requestPointerLock();
                        // Request Fullscreen
                        enterFullscreen();
                    }
                });
            }

            // 3. 컨트롤 설정
            setupControls();
            setupSensitivityControl();

            // 4. 애니메이션 루프 시작
            if (typeof animate === 'function') {
                animate();
            } else {
                console.error('animate function not found!');
            }

            // Force UI Refresh (Ensure HUD shows up on PC)
            if (typeof window.refreshUI === 'function') {
                window.refreshUI();
            }
        }

        // --- 주요 초기화 (3D/엔진 등) ---
        function initGame() {
            // 이미 초기화되었으면 중복 실행 방지
            if (scene) {
                // Ensure window.scene is set even if scene already exists
                if (!window.scene) window.scene = scene;

                if (camera && renderer) {
                    if (renderer.domElement && !document.body.contains(renderer.domElement)) {
                        document.body.appendChild(renderer.domElement);
                    }
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    console.log("Game engine already initialized, skipping re-init");
                    return;
                }

                if (!camera) {
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                }
                if (!listener) {
                    listener = new THREE.AudioListener();
                    camera.add(listener);
                }
                if (!renderer) {
                    renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    document.body.appendChild(renderer.domElement);
                }

                scene.background = new THREE.Color(0x87CEEB);
                scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

                if (!mapGroup) {
                    mapGroup = new THREE.Group();
                    scene.add(mapGroup);
                }

                const lights = scene.children.filter(c => c.isLight);
                if (lights.length === 0) {
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    dirLight.position.set(50, 100, 50);
                    dirLight.castShadow = true;
                    // Expand shadow camera frustum for larger map coverage
                    dirLight.shadow.camera.left = -100;
                    dirLight.shadow.camera.right = 100;
                    dirLight.shadow.camera.top = 100;
                    dirLight.shadow.camera.bottom = -100;
                    dirLight.shadow.camera.near = 0.5;
                    dirLight.shadow.camera.far = 300;
                    dirLight.shadow.mapSize.width = 2048;
                    dirLight.shadow.mapSize.height = 2048;
                    scene.add(dirLight);
                    window.sunLight = dirLight; // Expose for following player
                }

                console.log("Game engine partially initialized, repaired missing components");
                return;
            }

            console.log("Initializing Game Engine...");

            // 1) 씬 생성
            scene = new THREE.Scene();
            window.scene = scene; // Expose globally for checks
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 150); // Extended fog for larger map

            // 2) 카메라 생성 (FOV 75, 화면비, near 0.1, far 1000)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // 3) 오디오 리스너 추가 (SoundGen에서 사용)
            listener = new THREE.AudioListener();
            camera.add(listener);

            // 4) 렌더러 생성
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 5) 조명 추가
            // [User Request] Brighter on Mobile
            const ambientInt = isMobile ? 0.9 : 0.6;
            const ambientLight = new THREE.AmbientLight(0xffffff, ambientInt);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            // Expand shadow camera frustum for larger map coverage around the player
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 300;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            window.sunLight = dirLight; // Expose for following player

            // 5.5) 맵 전용 그룹 생성 및 추가
            mapGroup = new THREE.Group();
            scene.add(mapGroup);

            // 6) 맵 생성 & 7) 플레이어 초기화
            // (기존 코드에 의존하거나 여기서 간단히 생성)
            // 6) 맵 생성 & 7) 플레이어 초기화
            // mapGroup이 생성된 후 맵을 생성해야 함
            if (currentMap === 'hotel') {
                createHotelMap();
            } else {
                createFactoryMap();
            }
            initPlayer();

            // 텍스처 시스템 초기화 (기존 함수 호출)
            initTextureSystem();
            initDecalSystem();
            initParticles();

            // 9) 마우스 락 이벤트 연결
            document.addEventListener('pointerlockchange', () => {
                if (isDead) return;
                if (!usePointerLock) return;
                isPaused = !document.pointerLockElement;
                document.body.classList.toggle('paused', isPaused);
                const elPauseOverlay = document.getElementById('pause-overlay');
                if (elPauseOverlay) {
                    elPauseOverlay.style.display = isPaused ? 'flex' : 'none';
                    if (isPaused) {
                        // Reset all key states when paused to prevent continuous movement
                        keys.w = 0;
                        keys.a = 0;
                        keys.s = 0;
                        keys.d = 0;
                        keys.shift = false;
                        keys.ctrl = false;
                        keys.space = false;
                        if (typeof setupSensitivityControl === 'function') setupSensitivityControl();
                    }
                }
            });

            // Reset keys when window loses focus (Alt+Tab, etc.)
            window.addEventListener('blur', () => {
                keys.w = 0;
                keys.a = 0;
                keys.s = 0;
                keys.d = 0;
                keys.shift = false;
                keys.ctrl = false;
                keys.space = false;
            });

            window.addEventListener('resize', onResize, false);
        }

        // ========================================
        // DATA-DRIVEN MAP SYSTEM
        // ========================================

        /**
         * Creates a map object mesh based on type
         * @param {Object} obj - Object definition with type, pos, rot, scale
         * @param {Object} materials - Material library (matConcrete, matMetal, matRust, matWall)
         * @returns {THREE.Mesh} Created mesh
         */
        // --- Detailed Object Creators ---
        function createOpenContainer(obj, materials) {
            const group = new THREE.Group();
            group.userData.complexCollision = true;
            const w = obj.size[0], h = obj.size[1], d = obj.size[2];
            const t = 0.2; // thickness

            const mat = materials.matMetal.clone();
            mat.color.setHex(0x446688);
            mat.side = THREE.DoubleSide;

            // Floor
            const floor = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), mat);
            floor.position.y = t / 2;
            floor.receiveShadow = true;
            group.add(floor);

            // Ceiling
            const ceil = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), mat);
            ceil.position.y = h - t / 2;
            ceil.castShadow = true;
            group.add(ceil);

            // Walls (Left, Right, Back) - Opening at +Z
            // Left (-X)
            const left = new THREE.Mesh(new THREE.BoxGeometry(t, h, d), mat);
            left.position.x = -w / 2 + t / 2;
            left.position.y = h / 2;
            left.castShadow = true;
            left.receiveShadow = true;
            group.add(left);

            // Right (+X)
            const right = new THREE.Mesh(new THREE.BoxGeometry(t, h, d), mat);
            right.position.x = w / 2 - t / 2;
            right.position.y = h / 2;
            right.castShadow = true;
            right.receiveShadow = true;
            group.add(right);

            // Back (-Z)
            const back = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), mat);
            back.position.z = -d / 2 + t / 2;
            back.position.y = h / 2;
            back.castShadow = true;
            back.receiveShadow = true;
            group.add(back);

            // Fix floating: Adjust Y to match bottom-pivot (Editor uses center-pivot)
            group.position.set(obj.pos[0], obj.pos[1] - h / 2, obj.pos[2]);
            if (obj.rot) group.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            return group;
        }

        function createVehicle(obj, materials) {
            const group = new THREE.Group();
            group.userData.complexCollision = true;
            const w = obj.size[0], h = obj.size[1], d = obj.size[2];

            const matBody = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.4, metalness: 0.6 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.9, transparent: true, opacity: 0.7 });
            const matWheel = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });

            // Body (Lower part)
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h * 0.4, d), matBody);
            body.position.y = h * 0.4; // Wheels take bottom space
            body.castShadow = true;
            group.add(body);

            // Cabin (Upper part, slightly set back)
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, h * 0.4, d * 0.5), matBody);
            cabin.position.y = h * 0.8;
            cabin.position.z = -d * 0.1;
            cabin.castShadow = true;
            group.add(cabin);

            // Windshield
            const glass = new THREE.Mesh(new THREE.BoxGeometry(w * 0.85, h * 0.3, d * 0.05), matGlass);
            glass.position.y = h * 0.8;
            glass.position.z = d * 0.15 + 0.01;
            group.add(glass);

            // Wheels
            const r = h * 0.25;
            const wGeo = new THREE.CylinderGeometry(r, r, w * 0.2, 16);
            wGeo.rotateZ(Math.PI / 2);

            // Move wheels slightly outward to avoid Z-fighting (w*0.4 -> w*0.45)
            // Wheel width is w*0.2 (0.8). Center at 0.45w (1.8). Range: 1.4 ~ 2.2.
            // Body width is w (4). Range: -2.0 ~ 2.0.
            // Overlap: 1.4 ~ 2.0. Protrusion: 2.0 ~ 2.2. Good.
            const wx = w * 0.42;
            const wheels = [
                [wx, r, d * 0.3], [-wx, r, d * 0.3],
                [wx, r, -d * 0.3], [-wx, r, -d * 0.3]
            ];
            wheels.forEach(p => {
                const wh = new THREE.Mesh(wGeo, matWheel);
                wh.position.set(...p);
                wh.castShadow = true;
                group.add(wh);
            });

            // Fix floating: Adjust Y to match bottom-pivot
            group.position.set(obj.pos[0], obj.pos[1] - h / 2, obj.pos[2]);
            if (obj.rot) group.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            return group;
        }

        function createVendingMachine(obj, materials) {
            const group = new THREE.Group();
            const w = obj.size[0], h = obj.size[1], d = obj.size[2];

            // Main Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d),
                new THREE.MeshStandardMaterial({ color: 0xcc4444, roughness: 0.3, metalness: 0.4 }));
            body.position.y = h / 2;
            body.castShadow = true;
            group.add(body);

            // Glass Panel
            const glass = new THREE.Mesh(new THREE.PlaneGeometry(w * 0.8, h * 0.6),
                new THREE.MeshStandardMaterial({ color: 0x88ccff, emissive: 0x224466, roughness: 0.1 }));
            glass.position.set(0, h * 0.6, d / 2 + 0.01);
            group.add(glass);

            // Dispenser
            const slot = new THREE.Mesh(new THREE.PlaneGeometry(w * 0.8, h * 0.15),
                new THREE.MeshStandardMaterial({ color: 0x111111 }));
            slot.position.set(0, h * 0.15, d / 2 + 0.01);
            group.add(slot);

            // Fix floating
            group.position.set(obj.pos[0], obj.pos[1] - h / 2, obj.pos[2]);
            if (obj.rot) group.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            return group;
        }

        function createBarrel(obj, materials) {
            const group = new THREE.Group();
            const r = obj.size[0] / 2;
            const h = obj.size[1];

            const matRust = materials.matRust.clone();

            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, 16), matRust);
            barrel.position.y = h / 2;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            group.add(barrel);

            // Rings
            const matDark = new THREE.MeshStandardMaterial({ color: 0x332211, roughness: 1 });
            const ringGeo = new THREE.CylinderGeometry(r * 1.02, r * 1.02, h * 0.05, 16);

            const ring1 = new THREE.Mesh(ringGeo, matDark);
            ring1.position.y = h * 0.7;
            group.add(ring1);

            const ring2 = new THREE.Mesh(ringGeo, matDark);
            ring2.position.y = h * 0.3;
            group.add(ring2);

            // Fix floating
            group.position.set(obj.pos[0], obj.pos[1] - h / 2, obj.pos[2]);
            if (obj.rot) group.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            return group;
        }

        function createFence(obj, materials) {
            const group = new THREE.Group();
            group.userData.complexCollision = true;
            const w = obj.size[0], h = obj.size[1];
            const mat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7, metalness: 0.5 });

            // Posts at ends
            const postGeo = new THREE.BoxGeometry(0.2, h, 0.2);

            const post1 = new THREE.Mesh(postGeo, mat);
            post1.position.set(-w / 2 + 0.1, h / 2, 0);
            post1.castShadow = true;
            group.add(post1);

            const post2 = new THREE.Mesh(postGeo, mat);
            post2.position.set(w / 2 - 0.1, h / 2, 0);
            post2.castShadow = true;
            group.add(post2);

            // Rails
            const railGeo = new THREE.BoxGeometry(w, 0.1, 0.1);
            const rail1 = new THREE.Mesh(railGeo, mat);
            rail1.position.y = h * 0.8;
            group.add(rail1);

            const rail2 = new THREE.Mesh(railGeo, mat);
            rail2.position.y = h * 0.4;
            group.add(rail2);

            // Pickets (Vertical bars)
            const picketGeo = new THREE.BoxGeometry(0.1, h * 0.8, 0.05);
            const count = Math.floor(w / 0.5);
            for (let i = 1; i < count; i++) {
                const picket = new THREE.Mesh(picketGeo, mat);
                picket.position.set(-w / 2 + i * 0.5, h / 2, 0);
                group.add(picket);
            }

            // Fix floating
            group.position.set(obj.pos[0], obj.pos[1] - h / 2, obj.pos[2]);
            if (obj.rot) group.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            return group;
        }

        function createMapObject(obj, materials) {
            let geometry, material;

            switch (obj.type) {
                case 'wall':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 200, obj.size[1] || 20, obj.size[2] || 1);
                    material = materials.matWall || materials.matConcrete;
                    break;
                case 'coverWall':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 6, obj.size[1] || 1.5, obj.size[2] || 0.3);
                    material = materials.matConcrete;
                    break;
                case 'platform':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 8, obj.size[1] || 0.5, obj.size[2] || 8);
                    material = materials.matMetal;
                    break;
                case 'crate':
                case 'largeCrate':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 3, obj.size[1] || 3, obj.size[2] || 3);
                    material = materials.matRust;
                    break;
                case 'smallCrate':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 1.5, obj.size[1] || 1.5, obj.size[2] || 1.5);
                    material = materials.matRust;
                    break;
                case 'pillar':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 2, obj.size[1] || 6, obj.size[2] || 2);
                    material = materials.matConcrete;
                    break;
                case 'container':
                    geometry = new THREE.BoxGeometry(obj.size[0] || 6, obj.size[1] || 4, obj.size[2] || 3);
                    material = materials.matMetal;
                    break;
                case 'openContainer':
                    return createOpenContainer(obj, materials);
                case 'vehicle':
                    return createVehicle(obj, materials);
                case 'vendingMachine':
                    return createVendingMachine(obj, materials);
                case 'barrel':
                    return createBarrel(obj, materials);
                case 'fence':
                    return createFence(obj, materials);
                case 'floor':
                    geometry = new THREE.PlaneGeometry(obj.size[0] || 200, obj.size[1] || 200);
                    material = materials.matConcrete;
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.receiveShadow = true;
                    mesh.position.set(obj.pos[0], obj.pos[1], obj.pos[2]);
                    return mesh;
                default:
                    console.warn('Unknown object type:', obj.type);
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    material = materials.matConcrete;
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(obj.pos[0], obj.pos[1], obj.pos[2]);
            if (obj.rot) {
                mesh.rotation.set(obj.rot[0] || 0, obj.rot[1] || 0, obj.rot[2] || 0);
            }
            if (obj.scale) {
                mesh.scale.set(obj.scale[0] || 1, obj.scale[1] || 1, obj.scale[2] || 1);
            }
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            return mesh;
        }

        /**
         * Loads a map from JSON data
         * @param {Array} mapData - Array of object definitions
         */
        function createCustomMap(mapData) {
            colliders = [];
            spatialGrid.clear();

            // Create materials (same as factory map)
            const matConcrete = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                map: window.concreteTexture || null
            });

            const matMetal = new THREE.MeshStandardMaterial({
                color: 0x556677,
                roughness: 0.4,
                metalness: 0.7,
                map: window.metalTexture || null
            });

            const matRust = new THREE.MeshStandardMaterial({
                color: 0x885544,
                roughness: 0.8,
                metalness: 0.2,
                map: window.rustTexture || null
            });

            const matWall = new THREE.MeshStandardMaterial({
                color: 0x20252a,
                roughness: 0.9,
                map: window.concreteTexture || null
            });

            const materials = { matConcrete, matMetal, matRust, matWall };

            // Ensure there is at least a floor if not present in data
            const hasFloor = mapData.some(obj => obj.type === 'floor');
            if (!hasFloor) {
                console.log('No floor detected in map data, adding default floor');
                const defaultFloor = {
                    type: 'floor',
                    pos: [0, 0, 0],
                    rot: [0, 0, 0],
                    size: [500, 500] // Large enough
                };
                const floorMesh = createMapObject(defaultFloor, materials);
                mapGroup.add(floorMesh);
            }

            // Helper function to add collider
            function addBoxCollider(mesh) {
                if (mesh.userData.complexCollision) {
                    mesh.updateMatrixWorld(true);
                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            const box = new THREE.Box3().setFromObject(child);
                            colliders.push(box);
                            spatialGrid.insert(box);
                        }
                    });
                } else {
                    const box = new THREE.Box3().setFromObject(mesh);
                    colliders.push(box);
                    spatialGrid.insert(box);
                }
            }

            // Create all objects from data
            mapData.forEach(obj => {
                const mesh = createMapObject(obj, materials);
                mapGroup.add(mesh);

                // Add collider for non-floor objects
                if (obj.type !== 'floor') {
                    addBoxCollider(mesh);
                }
            });

            console.log(`Custom map loaded: ${mapData.length} objects created`);
        }

        /**
         * Extracts current map objects to JSON data for use in the map editor
         */
        function extractMapData() {
            if (!mapGroup || mapGroup.children.length === 0) {
                console.warn('Map group is empty. Load a map first.');
                return;
            }

            const data = [];
            let unknownCount = 0;

            mapGroup.children.forEach(mesh => {
                // Skip if not a mesh or is a ghost/temp object
                if (!mesh.isMesh || mesh.userData.isGhost) return;

                // Determine dimensions
                let size = [1, 1, 1];
                if (mesh.geometry.parameters) {
                    const p = mesh.geometry.parameters;
                    size = [p.width, p.height, p.depth || 1]; // Plane has no depth property sometimes
                } else if (mesh.geometry.type === 'BoxGeometry') {
                    // Fallback if parameters are missing
                }

                // Determine type based on size
                let type = 'crate'; // Default type
                const [w, h, d] = size;

                if (mesh.geometry.type === 'PlaneGeometry' && w >= 100) type = 'floor';
                else if (w >= 100 && h >= 10) type = 'wall';
                else if (Math.abs(w - 6) < 0.1 && Math.abs(h - 1.5) < 0.1) type = 'coverWall';
                else if (Math.abs(w - 8) < 0.1 && Math.abs(h - 0.5) < 0.1) type = 'platform';
                else if (Math.abs(w - 3) < 0.1 && Math.abs(h - 3) < 0.1) type = 'crate';
                else if (Math.abs(w - 1.5) < 0.1 && Math.abs(h - 1.5) < 0.1) type = 'smallCrate';
                else if (Math.abs(w - 2) < 0.1 && Math.abs(h - 6) < 0.1) type = 'pillar';
                else if (Math.abs(w - 6) < 0.1 && Math.abs(h - 4) < 0.1) type = 'container';
                else {
                    // Helper logic for non-standard objects (like platform supports)
                    if (h > w * 2) type = 'pillar'; // Tall -> pillar-like
                    else if (w > h * 4) type = 'platform'; // Flat -> platform-like
                    else type = 'crate'; // Blocky -> crate-like
                    unknownCount++;
                }

                data.push({
                    type: type,
                    pos: [Number(mesh.position.x.toFixed(2)), Number(mesh.position.y.toFixed(2)), Number(mesh.position.z.toFixed(2))],
                    rot: [Number(mesh.rotation.x.toFixed(2)), Number(mesh.rotation.y.toFixed(2)), Number(mesh.rotation.z.toFixed(2))],
                    size: size
                });
            });

            console.log(`%c[MAP EXTRACT] Extracted ${data.length} objects (${unknownCount} approximated)`, 'color: #00ff00; font-weight: bold');
            console.log(JSON.stringify(data, null, 2));
            console.log('%cCopy the JSON above and save to a file (e.g. factory.json) to import in the editor.', 'font-weight: bold');

            return data;
        }

        window.extractMapData = extractMapData;

        // ========================================
        // END DATA-DRIVEN MAP SYSTEM
        // ========================================

        // ========================================
        // MAP EDITOR MODE
        // ========================================

        /**
         * Starts the map editor mode (developer console access only)
         */
        function startEditor() {
            if (isGameStarted || gameMode === 'multi') {
                console.warn('Cannot start editor while game is running or in multiplayer');
                return;
            }

            isEditorActive = true;
            editorObjects = [];
            editorSelectedIndex = 0;
            editorCurrentObjectType = editorObjectTypes[0];

            console.log('%c[MAP EDITOR] Started', 'color: #00ff00; font-weight: bold');
            console.log('Controls:');
            console.log('  Left Click: Place object');
            console.log('  Right Click: Delete object under cursor');
            console.log('  Mouse Wheel: Cycle object types');
            console.log('  R Key: Rotate ghost object');
            console.log('  Call exportMap() to get JSON data');

            // Initialize scene if not already
            if (!scene) {
                initGame();
            }

            // Clear existing map and load empty floor
            if (mapGroup) {
                mapGroup.clear();
            }
            colliders = [];
            spatialGrid.clear();

            // Add floor
            const floorData = [{ type: 'floor', pos: [0, 0, 0], size: [200, 200] }];
            createCustomMap(floorData);

            // Start game loop if not running
            if (!isGameStarted) {
                isGameStarted = true;
                gameMode = 'single';
                position.set(0, 1.7, 5);
                camera.position.copy(position);
                if (!window.animateRunning) animate();
            }

            // Create ghost mesh
            updateEditorGhostMesh();

            // Show editor UI hint
            showEditorHint();
        }

        /**
         * Updates the ghost mesh based on current object type
         */
        function updateEditorGhostMesh() {
            if (editorGhostMesh) {
                scene.remove(editorGhostMesh);
            }

            const objDef = {
                type: editorCurrentObjectType,
                pos: [0, 1, 0],
                rot: [0, 0, 0]
            };

            const materials = {
                matConcrete: new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }),
                matMetal: new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }),
                matRust: new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }),
                matWall: new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
            };

            editorGhostMesh = createMapObject(objDef, materials);
            editorGhostMesh.userData.isGhost = true;
            scene.add(editorGhostMesh);
        }

        /**
         * Places object at raycast hit point
         */
        function placeEditorObject(hitPoint) {
            const objDef = {
                type: editorCurrentObjectType,
                pos: [Math.round(hitPoint.x), hitPoint.y, Math.round(hitPoint.z)],
                rot: editorGhostMesh ? [0, editorGhostMesh.rotation.y, 0] : [0, 0, 0],
                size: getSizeForType(editorCurrentObjectType)
            };

            editorObjects.push(objDef);

            // Create actual mesh
            const materials = {
                matConcrete: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 }),
                matMetal: new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.4, metalness: 0.7 }),
                matRust: new THREE.MeshStandardMaterial({ color: 0x885544, roughness: 0.8, metalness: 0.2 }),
                matWall: new THREE.MeshStandardMaterial({ color: 0x20252a, roughness: 0.9 })
            };

            const mesh = createMapObject(objDef, materials);
            mesh.userData.editorIndex = editorObjects.length - 1;
            mapGroup.add(mesh);

            const box = new THREE.Box3().setFromObject(mesh);
            colliders.push(box);
            spatialGrid.insert(box);

            console.log(`Placed ${editorCurrentObjectType} at (${objDef.pos[0]}, ${objDef.pos[1]}, ${objDef.pos[2]})`);
        }

        /**
         * Deletes object at raycast hit
         */
        function deleteEditorObject(hitMesh) {
            if (hitMesh && hitMesh.userData.editorIndex !== undefined) {
                const index = hitMesh.userData.editorIndex;
                editorObjects.splice(index, 1);
                mapGroup.remove(hitMesh);

                // Update indices
                mapGroup.children.forEach((child, i) => {
                    if (child.userData.editorIndex !== undefined && child.userData.editorIndex > index) {
                        child.userData.editorIndex--;
                    }
                });

                console.log(`Deleted object at index ${index}`);
            }
        }

        /**
         * Exports current map to JSON
         */
        function exportMap() {
            const mapDataWithFloor = [
                { type: 'floor', pos: [0, 0, 0], size: [200, 200] },
                ...editorObjects
            ];
            const jsonStr = JSON.stringify(mapDataWithFloor, null, 2);
            console.log('%c[MAP EXPORT]', 'color: #ffaa00; font-weight: bold');
            console.log(jsonStr);
            console.log('Copy the above JSON and save it to use with createCustomMap()');
            return mapDataWithFloor;
        }

        /**
         * Helper to get default size for object type
         */
        function getSizeForType(type) {
            const sizes = {
                'crate': [3, 3, 3],
                'smallCrate': [1.5, 1.5, 1.5],
                'coverWall': [6, 1.5, 0.3],
                'platform': [8, 0.5, 8],
                'pillar': [2, 6, 2],
                'container': [6, 4, 3],
                'wall': [200, 20, 1]
            };
            return sizes[type] || [1, 1, 1];
        }

        /**
         * Shows editor hint in console
         */
        function showEditorHint() {
            console.log('%c[MAP EDITOR]', 'color: #00ffff; font-weight: bold',
                `Current object: ${editorCurrentObjectType}`);
        }

        // Make editor functions globally accessible
        window.startEditor = startEditor;
        window.exportMap = exportMap;

        // ========================================
        // END MAP EDITOR MODE
        // ========================================

        function createMap() {
            // 바닥
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);
            window.baseFloor = floor;

            // 벽 (임시)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            for (let i = 0; i < 10; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set((Math.random() - 0.5) * 40, 0.5, (Math.random() - 0.5) * 40);
                mapGroup.add(box);
            }
        }

        function initPlayer() {
            // [CRITICAL FIX] Multiplayer: Do NOT overwrite camera position if already set by server
            if (gameMode === 'multi' && position && (position.x !== 0 || position.z !== 0)) {
                console.log('initPlayer: Keeping existing position for multiplayer:', position);
                camera.position.copy(position);
            } else {
                // Single player or fallback
                camera.position.set(0, 1.6, 5);
                // Also reset position var
                if (typeof position !== 'undefined') position.set(0, 1.6, 5);
            }

            // [FIX] 기존 weaponContainer가 scene에 직접 추가되어 있으면 제거하고 camera에 추가
            // 이전 init()에서 scene.add(weaponContainer)로 추가된 경우
            if (weaponContainer && weaponContainer.parent === scene) {
                scene.remove(weaponContainer);
            }

            // weaponContainer가 없으면 새로 생성
            if (!weaponContainer) {
                weaponContainer = new THREE.Group();
            }

            // Camera에 weaponContainer 추가 (1인칭 시점에서 보이도록)
            if (weaponContainer.parent !== camera) {
                camera.add(weaponContainer);
            }
            scene.add(camera);

            // [FIX] weaponModel이 없거나 비어있으면 새로 생성
            if (!weaponModel) {
                weaponModel = new THREE.Group();
                weaponContainer.add(weaponModel);
            }

            // [FIX] 상세한 무기 모델을 buildWeapon으로 생성 (단순 박스 대신)
            buildWeapon(curWeaponIdx);

            // [FIX] Ensure all weapon parts cast shadows
            weaponContainer.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                }
            });
        }

        function initDecalSystem() {
            // 데칼 헬퍼 초기화 (필요시)
        }

        function initParticles() {
            // 파티클 초기화 (배열 생성 등)
            particles = [];
            shells = [];
            healthPills = [];
            grenadeDrops = [];

            // Shell casing geometry and material
            shellGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.015, 8);
            shellMat = new THREE.MeshStandardMaterial({
                color: 0xd4af37, // Brass color
                metalness: 0.8,
                roughness: 0.3
            });
        }

        // --- 텍스처 시스템 초기화 ---
        function initTextureSystem() {

            // Canvas를 사용한 간단한 텍스처 생성
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // 콘크리트 텍스처 패턴
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.3)`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
            }
            window.concreteTexture = new THREE.CanvasTexture(canvas);
            window.concreteTexture.wrapS = THREE.RepeatWrapping;
            window.concreteTexture.wrapT = THREE.RepeatWrapping;
            window.concreteTexture.repeat.set(4, 4);

            // 메탈 텍스처 패턴
            const metalCanvas = document.createElement('canvas');
            metalCanvas.width = 256;
            metalCanvas.height = 256;
            const metalCtx = metalCanvas.getContext('2d');
            const gradient = metalCtx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#556677');
            gradient.addColorStop(0.5, '#778899');
            gradient.addColorStop(1, '#445566');
            metalCtx.fillStyle = gradient;
            metalCtx.fillRect(0, 0, 256, 256);
            window.metalTexture = new THREE.CanvasTexture(metalCanvas);
            window.metalTexture.wrapS = THREE.RepeatWrapping;
            window.metalTexture.wrapT = THREE.RepeatWrapping;
        }

        // --- 3D 모델 로더 초기화 (GLTF 파일 로딩) ---
        function initModelLoader() {
            // GLTFLoader는 Three.js 예제 파일이 필요하지만,
            // 기본 구조와 사용법을 제공합니다.

            // 사용 예제:
            // 1. Three.js examples 폴더에서 GLTFLoader.js 다운로드
            // 2. 로컬 파일로 추가: script 태그로 GLTFLoader.js 포함
            // 3. loadGLTFModel('model.gltf', (model) => { scene.add(model); });

            console.log('Model loader system ready (GLTFLoader.js file required)');
        }

        // --- 3D 모델 로드 함수 ---
        function loadGLTFModel(url, callback, onError) {
            // GLTFLoader 사용 예제 함수
            // 실제 사용하려면 GLTFLoader.js 파일이 필요합니다

            if (typeof THREE.GLTFLoader !== 'undefined') {
                if (!gltfLoader) {
                    gltfLoader = new THREE.GLTFLoader();
                }
                gltfLoader.load(
                    url,
                    (gltf) => {
                        callback(gltf.scene);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading GLTF model:', error);
                        if (onError) onError(error);
                    }
                );
            } else {
                console.warn('GLTFLoader not available. Please include GLTFLoader.js');
                if (onError) onError(new Error('GLTFLoader not available'));
            }
        }

        // --- 절차적 3D 모델 생성 함수 (GLTF 없이 사용 가능) ---
        function createProceduralModel(type, options = {}) {
            // GLTF 파일 없이 절차적으로 모델을 생성하는 함수
            const group = new THREE.Group();

            switch (type) {
                case 'crate':
                    const size = options.size || 1;
                    const crateGeo = new THREE.BoxGeometry(size, size, size);
                    const crateMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x8B4513,
                        roughness: 0.8
                    });
                    const crate = new THREE.Mesh(crateGeo, crateMat);
                    group.add(crate);
                    break;

                case 'barrel':
                    const radius = options.radius || 0.5;
                    const height = options.height || 1;
                    const barrelGeo = new THREE.CylinderGeometry(radius, radius, height, 16);
                    const barrelMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x654321,
                        roughness: 0.7
                    });
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    group.add(barrel);
                    break;
            }

            return group;
        }

        // --- 간단한 물리 엔진 구현 (외부 라이브러리 없이) ---
        const physicsBodies = []; // 물리 바디 배열

        function initPhysics() {
            // 간단한 물리 시스템 초기화
            physicsWorld = {
                gravity: new THREE.Vector3(0, -9.82, 0),
                bodies: []
            };
            usePhysics = true;
            console.log('Simple physics system initialized');
        }

        // --- 물리 바디 생성 함수 ---
        function createPhysicsBody(mesh, mass = 1, useGravity = true) {
            if (!usePhysics) return null;

            const body = {
                mesh: mesh,
                velocity: new THREE.Vector3(0, 0, 0),
                mass: mass,
                useGravity: useGravity,
                position: mesh.position.clone(),
                active: true
            };

            physicsWorld.bodies.push(body);
            return body;
        }

        // --- 물리 업데이트 함수 ---
        function updatePhysics(dt) {
            if (!usePhysics || !physicsWorld) return;

            for (let i = 0; i < physicsWorld.bodies.length; i++) {
                const body = physicsWorld.bodies[i];
                if (!body.active) continue;

                // 중력 적용
                if (body.useGravity && body.mass > 0) {
                    body.velocity.y += physicsWorld.gravity.y * dt;
                }

                // 속도로 위치 업데이트
                body.position.x += body.velocity.x * dt;
                body.position.y += body.velocity.y * dt;
                body.position.z += body.velocity.z * dt;

                // 메시 위치 동기화
                body.mesh.position.copy(body.position);

                // 바닥 충돌 (간단한 예제)
                if (body.position.y < 0.5) {
                    body.position.y = 0.5;
                    body.velocity.y = 0;
                }

                // 공기 저항
                body.velocity.multiplyScalar(0.98);
            }
        }

        // --- 간단한 후처리 효과 구현 (WebGL 쉐이더 사용) ---
        // let postProcessingCanvas, postProcessingCtx; // Moved to global

        // let postProcessingEnabled = false; // Moved to global

        function initPostProcessing() {
            try {
                // Canvas를 사용한 간단한 후처리 효과
                postProcessingCanvas = document.createElement('canvas');
                postProcessingCanvas.width = window.innerWidth;
                postProcessingCanvas.height = window.innerHeight;
                postProcessingCtx = postProcessingCanvas.getContext('2d');

                // 후처리 효과 변수 (게임 분위기에 맞게 조정)
                window.postProcessingEffects = {
                    brightness: 1.1,      // 약간 밝게
                    contrast: 1.05,       // 약간 대비 증가
                    saturation: 1.1,     // 약간 채도 증가
                    vignette: 0.2        // 약한 비네팅 효과
                };

                usePostProcessing = true;
                postProcessingEnabled = true;
                console.log('Post-processing system initialized with enhanced quality');
            } catch (error) {
                console.warn('Post-processing initialization failed:', error);
                usePostProcessing = false;
            }
        }

        // --- 후처리 효과 적용 함수 ---
        function applyPostProcessing() {
            if (!usePostProcessing || !postProcessingEnabled) return;

            const effects = window.postProcessingEffects;
            if (!effects) return;

            // 전체 장면의 밝기 조정 (더 부드러운 효과)
            if (window.scene) {
                scene.traverse((object) => {
                    if (object.isMesh && object.material) {
                        // emissive를 사용한 간접적인 밝기 조정
                        if (object.material.emissive && effects.brightness !== 1.0) {
                            const baseEmissive = object.userData.baseEmissive || new THREE.Color(0x000000);
                            if (!object.userData.baseEmissive) {
                                object.userData.baseEmissive = object.material.emissive.clone();
                            }
                            object.material.emissive.copy(baseEmissive).multiplyScalar(effects.brightness * 0.1);
                        }
                    }
                });
            }
        }

        // --- Map with Collision ---
        function createFactoryMap() {
            colliders = []; // Init array
            spatialGrid.clear(); // Clear grid

            // 텍스처 적용 (절차적 생성된 텍스처 사용)

            // Ensure matConcrete is defined exactly once
            const matConcrete = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                map: window.concreteTexture || null
            });

            const matMetal = new THREE.MeshStandardMaterial({
                color: 0x556677,
                roughness: 0.4,
                metalness: 0.7,
                map: window.metalTexture || null
            });

            // Rust 텍스처 생성
            const rustCanvas = document.createElement('canvas');
            rustCanvas.width = 256;
            rustCanvas.height = 256;
            const rustCtx = rustCanvas.getContext('2d');
            rustCtx.fillStyle = '#885544';
            rustCtx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 500; i++) {
                rustCtx.fillStyle = `rgba(${100 + Math.random() * 30}, ${60 + Math.random() * 20}, ${40 + Math.random() * 15}, 0.5)`;
                rustCtx.fillRect(Math.random() * 256, Math.random() * 256, 3, 3);
            }
            window.rustTexture = new THREE.CanvasTexture(rustCanvas);
            window.rustTexture.wrapS = THREE.RepeatWrapping;
            window.rustTexture.wrapT = THREE.RepeatWrapping;

            const matRust = new THREE.MeshStandardMaterial({
                color: 0x885544,
                roughness: 0.8,
                metalness: 0.2,
                map: window.rustTexture || null
            });

            const matWall = new THREE.MeshStandardMaterial({
                color: 0x20252a,
                roughness: 0.9,
                map: window.concreteTexture || null
            });

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), matConcrete);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);

            function addBoxCollider(mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                colliders.push(box);
                spatialGrid.insert(box);
            }




            const wallGeo = new THREE.BoxGeometry(200, 20, 1);
            const createWall = (x, y, z, rotY) => {
                const w = new THREE.Mesh(wallGeo, matWall);
                w.position.set(x, y, z);
                if (rotY) w.rotation.y = rotY;
                mapGroup.add(w);
                addBoxCollider(w);
            };
            // Walls at ±100 for 200x200 map
            createWall(0, 10, -100, 0);
            createWall(0, 10, 100, 0);
            createWall(-100, 10, 0, Math.PI / 2);
            createWall(100, 10, 0, Math.PI / 2);

            // === DETAILED MAP STRUCTURES FOR 200x200 MAP ===

            // Cover Walls - Low walls for tactical cover
            const coverWallGeo = new THREE.BoxGeometry(6, 1.5, 0.3);
            const coverPositions = [
                { x: -30, z: -30 }, { x: 30, z: 30 }, { x: -30, z: 30 }, { x: 30, z: -30 },
                { x: -50, z: 0 }, { x: 50, z: 0 }, { x: 0, z: -50 }, { x: 0, z: 50 },
                { x: -40, z: -20 }, { x: 40, z: 20 }, { x: -20, z: 40 }, { x: 20, z: -40 }
            ];
            coverPositions.forEach((p, i) => {
                const wall = new THREE.Mesh(coverWallGeo, matConcrete);
                wall.position.set(p.x, 0.75, p.z);
                wall.rotation.y = (i % 2) * Math.PI / 2; // Alternate orientation
                wall.castShadow = true;
                wall.receiveShadow = true;
                mapGroup.add(wall);
                addBoxCollider(wall);
            });

            // Elevated Platforms - For height advantage
            const platformGeo = new THREE.BoxGeometry(8, 0.5, 8);
            const platformSupport = new THREE.BoxGeometry(0.5, 3, 0.5);
            const platforms = [
                { x: -60, z: -60, height: 3 },
                { x: 60, z: 60, height: 3 },
                { x: -60, z: 60, height: 4 },
                { x: 60, z: -60, height: 4 }
            ];
            platforms.forEach(p => {
                const platform = new THREE.Mesh(platformGeo, matMetal);
                platform.position.set(p.x, p.height, p.z);
                platform.castShadow = true;
                platform.receiveShadow = true;
                mapGroup.add(platform);
                addBoxCollider(platform);

                // Support pillars
                for (let dx = -3; dx <= 3; dx += 6) {
                    for (let dz = -3; dz <= 3; dz += 6) {
                        const support = new THREE.Mesh(platformSupport, matMetal);
                        support.position.set(p.x + dx, p.height / 2, p.z + dz);
                        support.castShadow = true;
                        mapGroup.add(support);
                        addBoxCollider(support); // Added missing collider
                    }
                }
            });

            // Large Crates - Scattered cover
            const largeCrateGeo = new THREE.BoxGeometry(3, 3, 3);
            const cratePositions = [
                { x: -45, z: -15 }, { x: 45, z: 15 }, { x: -15, z: 45 }, { x: 15, z: -45 },
                { x: -70, z: -30 }, { x: 70, z: 30 }, { x: -30, z: 70 }, { x: 30, z: -70 },
                { x: -55, z: 25 }, { x: 55, z: -25 }, { x: 25, z: 55 }, { x: -25, z: -55 }
            ];
            cratePositions.forEach(p => {
                const crate = new THREE.Mesh(largeCrateGeo, matRust);
                crate.position.set(p.x, 1.5, p.z);
                crate.castShadow = true;
                crate.receiveShadow = true;
                mapGroup.add(crate);
                addBoxCollider(crate);
            });

            // Small Crates Clusters - Additional cover
            const smallCrateGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const smallCrateClusters = [
                { x: -35, z: -5 }, { x: 35, z: 5 }, { x: -5, z: 35 }, { x: 5, z: -35 },
                { x: -80, z: -50 }, { x: 80, z: 50 }, { x: -50, z: 80 }, { x: 50, z: -80 }
            ];
            smallCrateClusters.forEach(p => {
                for (let i = 0; i < 3; i++) {
                    const crate = new THREE.Mesh(smallCrateGeo, matRust);
                    const offsetX = (Math.random() - 0.5) * 4;
                    const offsetZ = (Math.random() - 0.5) * 4;
                    crate.position.set(p.x + offsetX, 0.75, p.z + offsetZ);
                    crate.rotation.y = Math.random() * Math.PI;
                    crate.castShadow = true;
                    crate.receiveShadow = true;
                    mapGroup.add(crate);
                    addBoxCollider(crate);
                }
            });

            // Corridors - Narrow pathways
            const corridorWallGeo = new THREE.BoxGeometry(20, 3, 0.5);
            const corridors = [
                { x: -75, z: 0, vertical: false },
                { x: 75, z: 0, vertical: false },
                { x: 0, z: -75, vertical: true },
                { x: 0, z: 75, vertical: true }
            ];
            corridors.forEach(c => {
                const wall1 = new THREE.Mesh(corridorWallGeo, matWall);
                const wall2 = new THREE.Mesh(corridorWallGeo, matWall);
                if (c.vertical) {
                    wall1.position.set(c.x - 2, 1.5, c.z);
                    wall2.position.set(c.x + 2, 1.5, c.z);
                } else {
                    wall1.position.set(c.x, 1.5, c.z - 2);
                    wall2.position.set(c.x, 1.5, c.z + 2);
                    wall1.rotation.y = Math.PI / 2;
                    wall2.rotation.y = Math.PI / 2;
                }
                wall1.castShadow = true;
                wall2.castShadow = true;
                mapGroup.add(wall1);
                mapGroup.add(wall2);
                addBoxCollider(wall1);
                addBoxCollider(wall2);
            });

            // Central Structure - Multi-level focal point
            const centralBase = new THREE.Mesh(new THREE.BoxGeometry(15, 1, 15), matConcrete);
            centralBase.position.set(0, 0.5, 0);
            centralBase.receiveShadow = true;
            mapGroup.add(centralBase);
            addBoxCollider(centralBase);

            // Ramps for central structure
            const rampGeo = new THREE.BoxGeometry(4, 0.2, 8);
            [-6, 6].forEach(offset => {
                const ramp = new THREE.Mesh(rampGeo, matMetal);
                ramp.position.set(offset, 1, 0);
                ramp.rotation.x = Math.PI / 12;
                mapGroup.add(ramp);
                addBoxCollider(ramp); // 램프 충돌 박스 추가
            });

            // Keep existing pillars for vertical gameplay
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            for (let x = -20; x <= 20; x += 10) {
                for (let z = -20; z <= 20; z += 10) {
                    if (x === 0 && z === 0) continue;
                    const pillar = new THREE.Mesh(pillarGeo, matMetal);
                    pillar.position.set(x, 5, z);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    mapGroup.add(pillar);
                    addBoxCollider(pillar);
                }
            }

            const beamGeo = new THREE.BoxGeometry(200, 0.5, 0.5);
            for (let z = -20; z <= 20; z += 5) {
                const beam = new THREE.Mesh(beamGeo, matMetal);
                beam.position.set(0, 9, z);
                mapGroup.add(beam);
                addBoxCollider(beam); // Added missing collider
            }

            // Old barrels for decoration (non-collidable)
            const barrelGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8);
            const barrelPositions = [
                { x: -65, z: -45 }, { x: 65, z: 45 }, { x: -45, z: 65 }, { x: 45, z: -65 },
                { x: -85, z: -20 }, { x: 85, z: 20 }
            ];
            barrelPositions.forEach(p => {
                const barrel = new THREE.Mesh(barrelGeo, matRust);
                barrel.position.set(p.x, 0.6, p.z);
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                mapGroup.add(barrel);

                // 원통형 충돌 박스 (간단한 박스로 근사)
                const barrelCollider = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(p.x, 0.6, p.z),
                    new THREE.Vector3(1.2, 1.2, 1.2)
                );
                colliders.push(barrelCollider);
            });

            // === SHIPPING CONTAINERS - MAJOR COVER OBJECTS ===
            const containerGeo = new THREE.BoxGeometry(12, 2.6, 2.6); // Standard 40ft container proportions
            const matContainer1 = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.3 });
            const matContainer2 = new THREE.MeshStandardMaterial({ color: 0x2F4F4F, roughness: 0.8, metalness: 0.3 });
            const matContainer3 = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.8, metalness: 0.3 });

            const containerPlacements = [
                { x: -70, z: -70, rotation: 0, material: matContainer1 },
                { x: 70, z: 70, rotation: 0, material: matContainer2 },
                { x: -70, z: 70, rotation: Math.PI / 2, material: matContainer3 },
                { x: 70, z: -70, rotation: Math.PI / 2, material: matContainer1 },
                { x: -85, z: 0, rotation: 0, material: matContainer2 },
                { x: 85, z: 0, rotation: 0, material: matContainer3 },
                { x: 0, z: -85, rotation: Math.PI / 2, material: matContainer1 },
                { x: 0, z: 85, rotation: Math.PI / 2, material: matContainer2 },
                // Stacked containers
                { x: -40, z: -60, rotation: 0, material: matContainer3, height: 2.6 },
                { x: 40, z: 60, rotation: Math.PI / 2, material: matContainer1, height: 2.6 }
            ];

            containerPlacements.forEach(c => {
                const container = new THREE.Mesh(containerGeo, c.material);
                container.position.set(c.x, c.height || 1.3, c.z);
                container.rotation.y = c.rotation;
                container.castShadow = true;
                container.receiveShadow = true;
                mapGroup.add(container);
                addBoxCollider(container);

                // Add container details (corrugated pattern simulation)
                const stripGeo = new THREE.BoxGeometry(12.1, 0.1, 0.1);
                for (let i = -1; i <= 1; i += 0.5) {
                    const strip = new THREE.Mesh(stripGeo, c.material);
                    strip.position.set(c.x, (c.height || 1.3) + i, c.z);
                    strip.rotation.y = c.rotation;
                    mapGroup.add(strip);
                }
            });

            // === CONCRETE BARRIERS - WAIST-HIGH COVER ===
            const barrierGeo = new THREE.BoxGeometry(4, 1.2, 0.5);
            const matBarrier = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const barrierPositions = [
                { x: -55, z: -35 }, { x: 55, z: 35 }, { x: -35, z: 55 }, { x: 35, z: -55 },
                { x: -75, z: -15 }, { x: 75, z: 15 }, { x: -15, z: 75 }, { x: 15, z: -75 },
                { x: -45, z: -45 }, { x: 45, z: 45 }
            ];

            barrierPositions.forEach((p, i) => {
                const barrier = new THREE.Mesh(barrierGeo, matBarrier);
                barrier.position.set(p.x, 0.6, p.z);
                barrier.rotation.y = (i % 3) * Math.PI / 3; // Varied angles
                barrier.castShadow = true;
                barrier.receiveShadow = true;
                mapGroup.add(barrier);
                addBoxCollider(barrier);
            });

            // === METAL FENCES - SECTIONAL BARRIERS ===
            const fenceGeo = new THREE.BoxGeometry(8, 2, 0.1);
            const matFence = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.6, metalness: 0.7 });
            const fenceSections = [
                { x: -90, z: -40, rotation: 0 },
                { x: 90, z: 40, rotation: 0 },
                { x: -40, z: -90, rotation: Math.PI / 2 },
                { x: 40, z: 90, rotation: Math.PI / 2 }
            ];

            fenceSections.forEach(f => {
                const fence = new THREE.Mesh(fenceGeo, matFence);
                fence.position.set(f.x, 1, f.z);
                fence.rotation.y = f.rotation;
                fence.castShadow = true;
                mapGroup.add(fence);
                addBoxCollider(fence);
            });

            // === STORAGE TANKS - CYLINDRICAL COVER ===
            const tankGeo = new THREE.CylinderGeometry(2, 2, 4, 16);
            const matTank = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.5, metalness: 0.6 });
            const tankPositions = [
                { x: -50, z: -70 }, { x: 50, z: 70 }, { x: -70, z: 50 }, { x: 70, z: -50 }
            ];

            tankPositions.forEach(p => {
                const tank = new THREE.Mesh(tankGeo, matTank);
                tank.position.set(p.x, 2, p.z);
                tank.castShadow = true;
                tank.receiveShadow = true;
                mapGroup.add(tank);
                addBoxCollider(tank);

                // Tank top/cap
                const capGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.2, 16);
                const cap = new THREE.Mesh(capGeo, matMetal);
                cap.position.set(p.x, 4.1, p.z);
                mapGroup.add(cap);
                addBoxCollider(cap); // 탱크 뚜껑 충돌 박스 추가
            });

            // === SANDBAG WALLS - LOW TACTICAL COVER ===
            const sandbagGeo = new THREE.BoxGeometry(5, 1, 1.5);
            const matSandbag = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 1.0 });
            const sandbagWalls = [
                { x: -25, z: -65 }, { x: 25, z: 65 }, { x: -65, z: 25 }, { x: 65, z: -25 },
                { x: -35, z: -40 }, { x: 35, z: 40 }
            ];

            sandbagWalls.forEach((p, i) => {
                const wall = new THREE.Mesh(sandbagGeo, matSandbag);
                wall.position.set(p.x, 0.5, p.z);
                wall.rotation.y = (i % 2) * Math.PI / 2;
                wall.castShadow = true;
                wall.receiveShadow = true;
                mapGroup.add(wall);
                addBoxCollider(wall);
            });
        }

        // --- Hotel Map ---
        function createHotelMap() {
            colliders = []; // Init array
            spatialGrid.clear(); // Clear grid

            // === 호텔 맵 재질 정의 ===


            // 밝은 대리석 바닥
            const matFloor = new THREE.MeshStandardMaterial({
                color: 0xddc9b4, // 크림/베이지색
                roughness: 0.3,
                metalness: 0.2
            });

            // 크림색 벽
            const matWall = new THREE.MeshStandardMaterial({
                color: 0xf5f5dc, // 베이지색
                roughness: 0.8
            });

            // 나무 문
            const matDoor = new THREE.MeshStandardMaterial({
                color: 0x8b7355, // 브라운
                roughness: 0.7
            });

            // 금색 악센트
            const matGold = new THREE.MeshStandardMaterial({
                color: 0xdaa520, // 골드
                roughness: 0.2,
                metalness: 0.9
            });

            // 빨간 소파
            const matSofa = new THREE.MeshStandardMaterial({
                color: 0x8b0000, // 다크 레드
                roughness: 0.7
            });

            // 흰색 침대
            const matBed = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.6
            });

            // 은색 엘리베이터
            const matElevator = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                roughness: 0.3,
                metalness: 0.8
            });

            // 녹색 식물
            const matPlant = new THREE.MeshStandardMaterial({
                color: 0x228b22,
                roughness: 0.9
            });

            // === 바닥 ===
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                matFloor
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);

            // === 외벽 (경계) ===
            function addBoxCollider(mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                colliders.push(box);
                spatialGrid.insert(box);
            }


            const wallGeo = new THREE.BoxGeometry(80, 10, 1);
            const createWall = (x, y, z, rotY) => {
                const w = new THREE.Mesh(wallGeo, matWall);
                w.position.set(x, y, z);
                if (rotY) w.rotation.y = rotY;
                w.castShadow = true;
                w.receiveShadow = true;
                mapGroup.add(w);
                addBoxCollider(w);
            };

            createWall(0, 5, -40, 0);           // 북쪽
            createWall(0, 5, 40, 0);            // 남쪽
            createWall(-40, 5, 0, Math.PI / 2); // 서쪽
            createWall(40, 5, 0, Math.PI / 2);  // 동쪽

            // === 로비 (입구 근처) ===

            // 리셉션 데스크
            const deskGeo = new THREE.BoxGeometry(8, 1.2, 2);
            const desk = new THREE.Mesh(deskGeo, matGold);
            desk.position.set(0, 0.6, -30);
            desk.castShadow = true;
            desk.receiveShadow = true;
            mapGroup.add(desk);
            addBoxCollider(desk);

            // 로비 소파들 (대기 공간)
            const sofaGeo = new THREE.BoxGeometry(3, 0.8, 1.5);

            const sofaPositions = [
                { x: -15, z: -25 },
                { x: -10, z: -25 },
                { x: 10, z: -25 },
                { x: 15, z: -25 }
            ];

            sofaPositions.forEach(pos => {
                const sofa = new THREE.Mesh(sofaGeo, matSofa);
                sofa.position.set(pos.x, 0.4, pos.z);
                sofa.castShadow = true;
                sofa.receiveShadow = true;
                mapGroup.add(sofa);
                addBoxCollider(sofa);
            });

            // === 복도 ===

            // 중앙 복도 벽
            const corridorWallGeo = new THREE.BoxGeometry(1, 4, 70);

            // 왼쪽 복도 벽
            const leftWall = new THREE.Mesh(corridorWallGeo, matWall);
            leftWall.position.set(-15, 2, 5);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            mapGroup.add(leftWall);
            addBoxCollider(leftWall);

            // 오른쪽 복도 벽
            const rightWall = new THREE.Mesh(corridorWallGeo, matWall);
            rightWall.position.set(15, 2, 5);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            mapGroup.add(rightWall);
            addBoxCollider(rightWall);

            // === 객실 (양쪽) ===

            const roomWallGeo = new THREE.BoxGeometry(12, 4, 1);
            const roomSpacing = 14;

            // 왼쪽 객실들
            for (let i = 0; i < 5; i++) {
                const z = -20 + i * roomSpacing;

                // 객실 앞벽
                const frontWall = new THREE.Mesh(roomWallGeo, matWall);
                frontWall.position.set(-25, 2, z);
                frontWall.castShadow = true;
                frontWall.receiveShadow = true;
                mapGroup.add(frontWall);
                addBoxCollider(frontWall);

                // 객실 문
                const doorGeo = new THREE.BoxGeometry(2, 3, 0.2);
                const door = new THREE.Mesh(doorGeo, matDoor);
                door.position.set(-19, 1.5, z);
                door.castShadow = true;
                door.receiveShadow = true;
                mapGroup.add(door);
                // 문은 충돌체에 추가하지 않음 (통과 가능)

                // 객실 침대
                const bedGeo = new THREE.BoxGeometry(3, 0.6, 2);
                const bed = new THREE.Mesh(bedGeo, matBed);
                bed.position.set(-28, 0.3, z);
                bed.castShadow = true;
                bed.receiveShadow = true;
                mapGroup.add(bed);
                addBoxCollider(bed);

                // 객실 뒷벽 (추가)
                const backWallGeo = new THREE.BoxGeometry(12, 4, 1);
                const backWall = new THREE.Mesh(backWallGeo, matWall);
                backWall.position.set(-31, 2, z);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                mapGroup.add(backWall);
                addBoxCollider(backWall);
            }

            // 오른쪽 객실들
            for (let i = 0; i < 5; i++) {
                const z = -20 + i * roomSpacing;

                // 객실 앞벽
                const frontWall = new THREE.Mesh(roomWallGeo, matWall);
                frontWall.position.set(25, 2, z);
                frontWall.castShadow = true;
                frontWall.receiveShadow = true;
                mapGroup.add(frontWall);
                addBoxCollider(frontWall);

                // 객실 문
                const doorGeo = new THREE.BoxGeometry(2, 3, 0.2);
                const door = new THREE.Mesh(doorGeo, matDoor);
                door.position.set(19, 1.5, z);
                door.castShadow = true;
                door.receiveShadow = true;
                mapGroup.add(door);

                // 객실 침대
                const bedGeo = new THREE.BoxGeometry(3, 0.6, 2);
                const bed = new THREE.Mesh(bedGeo, matBed);
                bed.position.set(28, 0.3, z);
                bed.castShadow = true;
                bed.receiveShadow = true;
                mapGroup.add(bed);
                addBoxCollider(bed);

                // 객실 뒷벽
                const backWallGeo = new THREE.BoxGeometry(12, 4, 1);
                const backWall = new THREE.Mesh(backWallGeo, matWall);
                backWall.position.set(31, 2, z);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                mapGroup.add(backWall);
                addBoxCollider(backWall);
            }

            // === 엘리베이터 (장식용) ===
            const elevatorGeo = new THREE.BoxGeometry(3, 5, 3);
            const elevator = new THREE.Mesh(elevatorGeo, matElevator);
            elevator.position.set(0, 2.5, 35);
            elevator.castShadow = true;
            elevator.receiveShadow = true;
            mapGroup.add(elevator);
            addBoxCollider(elevator);

            // === 화분 (장식) ===
            const plantGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.5, 8);

            const plantPositions = [
                { x: -8, z: -15 },
                { x: 8, z: -15 },
                { x: -8, z: 20 },
                { x: 8, z: 20 }
            ];

            plantPositions.forEach(pos => {
                const plant = new THREE.Mesh(plantGeo, matPlant);
                plant.position.set(pos.x, 0.75, pos.z);
                plant.castShadow = true;
                plant.receiveShadow = true;
                mapGroup.add(plant);
                addBoxCollider(plant);
            });
        }


        // --- Weapon Building ---
        function buildWeapon(idx) {
            while (weaponModel.children.length > 0) weaponModel.remove(weaponModel.children[0]);

            const wData = WEAPONS[idx];
            if (wData.type === 'RIFLE') buildRifle();
            else if (wData.type === 'PISTOL') buildPistol();
            else if (wData.type === 'SNIPER') buildSniper();
            else if (wData.type === 'KNIFE') buildKnife();
            else if (wData.type === 'GRENADE') buildGrenade();


            if (wData.type !== 'KNIFE' && wData.type !== 'GRENADE') {
                const muzzleShape = new THREE.Shape();
                const points = 4;
                // [User Request] 소총 섬광 크기 증가 (0.08 -> 0.16, 0.035 -> 0.07)
                const outerRadius = (wData.type === 'RIFLE') ? 0.16 : 0.08;
                const innerRadius = (wData.type === 'RIFLE') ? 0.07 : 0.035;
                for (let i = 0; i < points * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const theta = (i / (points * 2)) * Math.PI * 2;
                    const x = Math.cos(theta) * r;
                    const y = Math.sin(theta) * r;
                    if (i === 0) muzzleShape.moveTo(x, y);
                    else muzzleShape.lineTo(x, y);
                }
                muzzleShape.closePath();

                const fGeo = new THREE.ShapeGeometry(muzzleShape);
                const fMat = new THREE.MeshBasicMaterial({
                    color: 0xffbb77,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                muzzleFlash = new THREE.Mesh(fGeo, fMat);
                muzzleFlash.visible = false;
                const mPos = (isAiming && wData.muzzleAds) ? wData.muzzleAds : (wData.muzzleHip || new THREE.Vector3(0, 0, -0.5));
                muzzleFlash.position.copy(mPos);

                weaponModel.add(muzzleFlash);
            }
        }

        function buildRifleGeometry() {
            // 리시버 (본체)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.06, 0.3), matBody);
            weaponModel.add(receiver);

            // 배럴 (더 상세하게)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.4);
            weaponModel.add(barrel);

            // 배럴 가드 (Barrel Guard) - 배럴 보호대
            const barrelGuard = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.4, 16), matParts);
            barrelGuard.rotation.x = Math.PI / 2; barrelGuard.position.set(0, 0.015, -0.35);
            weaponModel.add(barrelGuard);

            // 가스 블록 (Gas Block)
            const gasBlock = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.025, 0.03), matSilver);
            gasBlock.position.set(0, 0.015, -0.2);
            weaponModel.add(gasBlock);

            // 탄창 (Magazine)
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.18, 0.06), matParts);
            mag.rotation.x = 0.25; mag.position.set(0, -0.1, 0.05);
            weaponModel.add(mag);

            // 탄창 클립 디테일
            const magClip = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.07), matSilver);
            magClip.position.set(0, -0.18, 0.05);
            weaponModel.add(magClip);

            // 개머리판 (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.2), matParts);
            stock.position.set(0, -0.02, 0.25);
            weaponModel.add(stock);

            // 개머리판 패드
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.042, 0.12, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.36);
            weaponModel.add(stockPad);

            // 핸드가드 (Handguard)
            const hg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.25), matParts);
            hg.position.set(0, 0.005, -0.28);
            weaponModel.add(hg);

            // 핸드가드 라일 (Rail) - 상단
            const railTop = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.01, 0.2), matSilver);
            railTop.position.set(0, 0.04, -0.28);
            weaponModel.add(railTop);

            // 트리거 가드 (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // 트리거 (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.02), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // 볼트 핸들 (Bolt Handle)
            const boltHandle = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.008, 0.03), matSilver);
            boltHandle.position.set(0.025, 0.03, 0.1);
            weaponModel.add(boltHandle);

            // 가늠자 (Rear Sight) - 더 상세하게
            const rs = new THREE.Mesh(new THREE.TorusGeometry(0.012, 0.003, 8, 16), matParts);
            rs.position.set(0, 0.062, 0.14);
            weaponModel.add(rs);

            // 가늠쇠 (Front Sight) - 빨간 점 (높이를 가늠자 구멍 중심인 0.062로 정밀 정렬)
            const fs = new THREE.Mesh(new THREE.BoxGeometry(0.0025, 0.0025, 0.0025), matSight);
            fs.position.set(0, 0.062, -0.45);
            fs.userData.isSight = true;
            weaponModel.add(fs);

            // 가늠쇠 기둥
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.015, 0.002), matParts);
            fsPost.position.set(0, 0.055, -0.45);
            weaponModel.add(fsPost);

            // 가늠쇠 베이스
            const fsBase = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.003, 0.008), matParts);
            fsBase.position.set(0, 0.048, -0.45);
            weaponModel.add(fsBase);

            // Left Arm - Adjusted to cup the handguard
            createArm(-0.04, -0.08, -0.32, 0.4, 0.1, -0.1, false);
            // Right Arm
            createArm(0.12, -0.15, 0.22, 0.2, -0.2, 0.4, true);
        }

        function buildRifle() {
            // [Fix] Re-enable GLB loading explicitly
            console.log("Attempting to load Rifle GLB...");
            if (typeof THREE.GLTFLoader !== 'undefined') {
                // ---- Direct Arm Implementation (Refined for Rifle Grip - Pistol Style) ----

                // [FIX] Define arm materials INLINE (avoid external variable issues)
                const armSleeveMat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b }); // Dark grey sleeve
                const armGloveMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a }); // Black glove
                const armSkinMat = new THREE.MeshBasicMaterial({ color: 0xeebb99 }); // [MOD] Skin color

                // [FIX] Remove existing arms if any (Prevent Duplication Loop)
                const oldLArm = weaponModel.getObjectByName('LeftArmGroup');
                if (oldLArm) weaponModel.remove(oldLArm);
                const oldRArm = weaponModel.getObjectByName('RightArmGroup');
                if (oldRArm) weaponModel.remove(oldRArm);

                // Left Arm Group (Gripping Handguard)
                const lArmGroup = new THREE.Group();
                lArmGroup.name = 'LeftArmGroup'; // Tag for cleanup
                const lSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.14, 0.55), armSleeveMat); // Standard Knife-style sleeve
                lSleeve.position.set(0, 0, 0.25);
                lSleeve.castShadow = true; // [FIX] Shadow
                lArmGroup.add(lSleeve);

                // Left Hand
                const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.1, 0.14), armSkinMat); // [MOD] Skin Color Hand
                lHand.position.set(0, 0, -0.05);
                lHand.castShadow = true; // [FIX] Shadow
                lArmGroup.add(lHand);

                // [User Request] Position Left Arm using WEAPONS data
                const wData = WEAPONS.find(w => w.type === 'RIFLE');
                if (wData && wData.lArmHip) {
                    lArmGroup.position.copy(wData.lArmHip.pos);
                    lArmGroup.rotation.set(wData.lArmHip.rot.x, wData.lArmHip.rot.y, wData.lArmHip.rot.z);
                } else {
                    lArmGroup.position.set(-0.15, -0.22, -0.5);
                    lArmGroup.rotation.set(0.4, 0.2, -0.1);
                }
                lArmGroup.scale.set(2.5, 2.5, 2.5); // [MOD] Standardized Scale 2.5
                weaponModel.add(lArmGroup);


                // Right Arm Group (Trigger Finger)
                const rArmGroup = new THREE.Group();
                rArmGroup.name = 'RightArmGroup'; // Tag for cleanup
                const rSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.14, 0.55), armSleeveMat);
                rSleeve.position.set(0, 0, 0.25);
                rSleeve.castShadow = true; // [FIX] Shadow
                rArmGroup.add(rSleeve);

                // Right Hand
                const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.1, 0.14), armSkinMat); // [MOD] Skin Color Hand
                rHand.position.set(0, 0, -0.05);
                rHand.castShadow = true; // [FIX] Shadow
                rArmGroup.add(rHand);

                // Position Right Arm (Grip Position for Scale 2.5)
                rArmGroup.position.set(0.08, -0.25, 0.1);
                rArmGroup.rotation.set(0.1, -0.1, 0.2);
                rArmGroup.scale.set(2.5, 2.5, 2.5); // [MOD] Standardized Scale 2.5
                weaponModel.add(rArmGroup);

                // Clear any previous async load results using global token
                const token = weaponLoadToken;

                const loader = new THREE.GLTFLoader();
                // [User Request] Disable GLB Model (Use procedural manual build instead)
                if (true) {
                    loader.load('gun/Assault Rifle.glb', function (gltf) {

                        if (token !== weaponLoadToken) return;
                        const model = gltf.scene;

                        model.traverse(function (child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // [User Request] Apply GLB transform from Debug UI screenshot
                        model.scale.set(0.50, 0.50, 0.50);
                        model.rotation.set(0.43, 1.69, -0.25);
                        model.position.set(0.23, -0.47, 0.44);

                        // Remove any previous GLB rifle model
                        if (window.rifleModel) {
                            weaponModel.remove(window.rifleModel);
                        }

                        window.rifleModel = model;
                        setupRifleDebugUI(); // [USER REQUEST] Show Debug Panel
                        if (document.getElementById('rifle-debug-panel')) {
                            // document.getElementById('rifle-debug-panel').style.display = 'block';
                            document.getElementById('rifle-debug-panel').style.display = 'none';
                        }

                        weaponModel.add(model);
                        weaponModel.updateMatrixWorld(true);

                        // Auto-align muzzle flash to rifle front
                        if (muzzleFlash) {
                            const box = new THREE.Box3().setFromObject(model);
                            const center = new THREE.Vector3();
                            box.getCenter(center);
                            const muzzleWorld = new THREE.Vector3(center.x, center.y + 0.1, box.min.z - 0.02);
                            weaponModel.worldToLocal(muzzleWorld);
                            // muzzleFlash.position.copy(muzzleWorld);
                        }
                    }, undefined, function (error) {
                        console.error('Rifle GLB load failed:', error);
                        // Clear weaponModel (arms + anything else) and rebuild geometry
                        while (weaponModel.children.length > 0) {
                            weaponModel.remove(weaponModel.children[0]);
                        }
                        buildRifleGeometry();
                    });
                } else {
                    // [FIX] Ensure geometry is built if GLB is disabled
                    buildRifleGeometry();
                }
            }
        }

        function setupRifleDebugUI() {
            const panel = document.getElementById('rifle-debug-panel');
            if (!panel || !window.rifleModel || panel.dataset.bound === '1') return;
            panel.dataset.bound = '1';

            const stop = (e) => { e.stopPropagation(); };
            panel.addEventListener('pointerdown', stop);
            panel.addEventListener('pointermove', stop);
            panel.addEventListener('pointerup', stop);
            panel.addEventListener('click', stop);
            panel.addEventListener('mousedown', stop);
            panel.addEventListener('touchstart', stop, { passive: true });
            panel.addEventListener('touchmove', stop, { passive: true });
            panel.addEventListener('touchend', stop, { passive: true });
            panel.addEventListener('wheel', stop, { passive: true });

            // Elements
            const ids = ['rifle-x', 'rifle-y', 'rifle-z', 'rifle-scale', 'rifle-rx', 'rifle-ry', 'rifle-rz', 'rifle-x-step', 'rifle-mx', 'rifle-my', 'rifle-mz', 'rifle-lax', 'rifle-lay', 'rifle-laz', 'rifle-larx', 'rifle-lary', 'rifle-larz'];
            const inputs = {};
            const vals = {};

            ids.forEach(id => {
                inputs[id] = document.getElementById(id);
                vals[id] = document.getElementById(id + '-val');
            });

            const xMinus = document.getElementById('rifle-x-minus');
            const xPlus = document.getElementById('rifle-x-plus');
            const xNudgeVal = document.getElementById('rifle-x-nudge-val');
            const copy = document.getElementById('rifle-copy');

            const apply = () => {
                if (!window.rifleModel) return;

                const v = (id) => inputs[id] ? parseFloat(inputs[id].value) : 0;
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'RIFLE') return;

                const xv = v('rifle-x'), yv = v('rifle-y'), zv = v('rifle-z');
                const sv = v('rifle-scale'), rxv = v('rifle-rx'), ryv = v('rifle-ry'), rzv = v('rifle-rz');
                const mxv = v('rifle-mx'), myv = v('rifle-my'), mzv = v('rifle-mz');
                const laxv = v('rifle-lax'), layv = v('rifle-lay'), lazv = v('rifle-laz');
                const larxv = v('rifle-larx'), laryv = v('rifle-lary'), larzv = v('rifle-larz');

                // ADS-Aware: Update WEAPONS data directly
                const targetTransform = isAiming ? w.glbAds : w.glbHip;
                if (targetTransform) {
                    targetTransform.pos.set(xv, yv, zv);
                    targetTransform.scale.set(sv, sv, sv);
                    targetTransform.rot.set(rxv, ryv, rzv);
                }

                const targetMuzzle = isAiming ? w.muzzleAds : w.muzzleHip;
                if (targetMuzzle) {
                    targetMuzzle.set(mxv, myv, mzv);
                }

                const targetArm = isAiming ? w.lArmAds : w.lArmHip;
                if (targetArm) {
                    targetArm.pos.set(laxv, layv, lazv);
                    targetArm.rot.set(larxv, laryv, larzv);
                }

                // Update text displays
                ids.forEach(id => {
                    if (vals[id] && inputs[id]) {
                        const prec = (inputs[id].step && parseFloat(inputs[id].step) < 0.01) ? 3 : 2;
                        vals[id].textContent = parseFloat(inputs[id].value).toFixed(prec);
                    }
                });

                // Special update for X-Step display on the Nudge row
                if (xNudgeVal && inputs['rifle-x-step']) {
                    xNudgeVal.textContent = parseFloat(inputs['rifle-x-step'].value).toFixed(3);
                }

                // Immediate visual update
                window.rifleModel.position.set(xv, yv, zv);
                window.rifleModel.scale.set(sv, sv, sv);
                window.rifleModel.rotation.set(rxv, ryv, rzv);
                if (muzzleFlash) muzzleFlash.position.set(mxv, myv, mzv);

                const lArm = weaponModel.getObjectByName('LeftArmGroup');
                if (lArm) {
                    lArm.position.set(laxv, layv, lazv);
                    lArm.rotation.set(larxv, laryv, larzv);
                }
            };

            // Sync from current state
            const syncFromState = () => {
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'RIFLE') return;
                const t = isAiming ? w.glbAds : w.glbHip;
                const m = isAiming ? w.muzzleAds : w.muzzleHip;
                const a = isAiming ? w.lArmAds : w.lArmHip;

                if (t && inputs['rifle-x']) {
                    inputs['rifle-x'].value = t.pos.x.toFixed(3);
                    inputs['rifle-y'].value = t.pos.y.toFixed(3);
                    inputs['rifle-z'].value = t.pos.z.toFixed(3);
                    inputs['rifle-scale'].value = t.scale.x.toFixed(3);
                    inputs['rifle-rx'].value = t.rot.x.toFixed(3);
                    inputs['rifle-ry'].value = t.rot.y.toFixed(3);
                    inputs['rifle-rz'].value = t.rot.z.toFixed(3);
                }
                if (m && inputs['rifle-mx']) {
                    inputs['rifle-mx'].value = m.x.toFixed(3);
                    inputs['rifle-my'].value = m.y.toFixed(3);
                    inputs['rifle-mz'].value = m.z.toFixed(3);
                }
                if (a && inputs['rifle-lax']) {
                    inputs['rifle-lax'].value = a.pos.x.toFixed(3);
                    inputs['rifle-lay'].value = a.pos.y.toFixed(3);
                    inputs['rifle-laz'].value = a.pos.z.toFixed(3);
                    inputs['rifle-larx'].value = a.rot.x.toFixed(3);
                    inputs['rifle-lary'].value = a.rot.y.toFixed(3);
                    inputs['rifle-larz'].value = a.rot.z.toFixed(3);
                }
                apply(); // Refresh displays
            };

            syncFromState();
            let lastAiming = isAiming;
            setInterval(() => {
                if (panel.style.display === 'block' && lastAiming !== isAiming) {
                    syncFromState();
                    lastAiming = isAiming;
                }
            }, 100);

            if (copy) {
                copy.addEventListener('click', () => {
                    const w = WEAPONS[curWeaponIdx];
                    console.log('[Rifle GLB] Hip:', w.glbHip, 'Ads:', w.glbAds, 'MuzzleHip:', w.muzzleHip, 'MuzzleAds:', w.muzzleAds, 'LArmHip:', w.lArmHip, 'LArmAds:', w.lArmAds);
                    const original = copy.textContent;
                    copy.textContent = "Copied to Console";
                    setTimeout(() => copy.textContent = original, 1000);
                });
            }

            // Attach input listeners
            ids.forEach(id => {
                if (inputs[id]) inputs[id].addEventListener('input', apply);
            });

            // Helper for nudge buttons (Delegation)
            panel.addEventListener('pointerdown', (e) => {
                const btn = e.target.closest('.nudge-btn');
                if (!btn) return;

                const targetId = btn.dataset.target;
                const dir = parseFloat(btn.dataset.dir || 0);
                const input = inputs[targetId];

                if (input && dir !== 0) {
                    const step = parseFloat(input.step) || 0.01;
                    const val = parseFloat(input.value);

                    // Determine precision from step
                    const stepStr = input.step.toString();
                    const decimals = stepStr.includes('.') ? stepStr.split('.')[1].length : 2;

                    input.value = (val + (step * dir)).toFixed(decimals);
                    apply();
                }
            });

            // Existing X-Nudge buttons logic
            if (xMinus && inputs['rifle-x'] && inputs['rifle-x-step']) {
                xMinus.addEventListener('click', () => {
                    const step = parseFloat(inputs['rifle-x-step'].value);
                    const x = inputs['rifle-x'];
                    x.value = (parseFloat(x.value) - step).toFixed(3);
                    apply();
                });
            }
            if (xPlus && inputs['rifle-x'] && inputs['rifle-x-step']) {
                xPlus.addEventListener('click', () => {
                    const step = parseFloat(inputs['rifle-x-step'].value);
                    const x = inputs['rifle-x'];
                    x.value = (parseFloat(x.value) + step).toFixed(3);
                    apply();
                });
            }

            if (copy) {
                copy.addEventListener('click', () => {
                    console.log('[Rifle GLB] position:', window.rifleModel.position, 'scale:', window.rifleModel.scale.x, 'rotation:', window.rifleModel.rotation);
                    const original = copy.textContent;
                    copy.textContent = "Copied to Console";
                    setTimeout(() => copy.textContent = original, 1000);
                });
            }
            // Initialize sliders from current model transform (do not override)
            if (window.rifleModel) {
                inputs['rifle-x'].value = window.rifleModel.position.x.toFixed(3);
                inputs['rifle-y'].value = window.rifleModel.position.y.toFixed(3);
                inputs['rifle-z'].value = window.rifleModel.position.z.toFixed(3);
                inputs['rifle-scale'].value = window.rifleModel.scale.x.toFixed(3);
                inputs['rifle-rx'].value = window.rifleModel.rotation.x.toFixed(3);
                inputs['rifle-ry'].value = window.rifleModel.rotation.y.toFixed(3);
                inputs['rifle-rz'].value = window.rifleModel.rotation.z.toFixed(3);
            }
            if (muzzleFlash) {
                inputs['rifle-mx'].value = muzzleFlash.position.x.toFixed(3);
                inputs['rifle-my'].value = muzzleFlash.position.y.toFixed(3);
                inputs['rifle-mz'].value = muzzleFlash.position.z.toFixed(3);
            }
            apply();

        }

        function setupPistolDebugUI() {
            const panel = document.getElementById('pistol-debug-panel');
            if (!panel || !window.pistolModel || panel.dataset.bound === '1') return;
            panel.dataset.bound = '1';

            const stop = (e) => { e.stopPropagation(); };
            panel.addEventListener('pointerdown', stop);
            panel.addEventListener('pointermove', stop);
            panel.addEventListener('pointerup', stop);
            panel.addEventListener('click', stop);
            panel.addEventListener('mousedown', stop);
            panel.addEventListener('touchstart', stop, { passive: true });
            panel.addEventListener('touchmove', stop, { passive: true });
            panel.addEventListener('touchend', stop, { passive: true });
            panel.addEventListener('wheel', stop, { passive: true });

            // Elements
            const ids = ['pistol-x', 'pistol-x-step', 'pistol-y', 'pistol-z', 'pistol-scale', 'pistol-rx', 'pistol-ry', 'pistol-rz', 'pistol-mx', 'pistol-my', 'pistol-mz'];
            const inputs = {};
            const vals = {};

            ids.forEach(id => {
                inputs[id] = document.getElementById(id);
                vals[id] = document.getElementById(id + '-val');
            });

            const xMinus = document.getElementById('pistol-x-minus');
            const xPlus = document.getElementById('pistol-x-plus');
            const xNudgeVal = document.getElementById('pistol-x-nudge-val');
            const copy = document.getElementById('pistol-copy');

            const apply = () => {
                if (!window.pistolModel) return;

                const v = (id) => inputs[id] ? parseFloat(inputs[id].value) : 0;
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'PISTOL') return;

                const xv = v('pistol-x'), yv = v('pistol-y'), zv = v('pistol-z');
                const sv = v('pistol-scale'), rxv = v('pistol-rx'), ryv = v('pistol-ry'), rzv = v('pistol-rz');
                const mxv = v('pistol-mx'), myv = v('pistol-my'), mzv = v('pistol-mz');

                // [User Request] ADS-Aware: Update WEAPONS data directly
                const targetTransform = isAiming ? w.glbAds : w.glbHip;
                if (targetTransform) {
                    targetTransform.pos.set(xv, yv, zv);
                    targetTransform.scale.set(sv, sv, sv);
                    targetTransform.rot.set(rxv, ryv, rzv);
                }

                const targetMuzzle = isAiming ? w.muzzleAds : w.muzzleHip;
                if (targetMuzzle) {
                    targetMuzzle.set(mxv, myv, mzv);
                }

                // Update text displays
                ids.forEach(id => {
                    if (vals[id] && inputs[id]) {
                        const prec = (inputs[id].step && parseFloat(inputs[id].step) < 0.01) ? 3 : 2;
                        vals[id].textContent = parseFloat(inputs[id].value).toFixed(prec);
                    }
                });
                if (xNudgeVal && inputs['pistol-x-step']) {
                    xNudgeVal.textContent = parseFloat(inputs['pistol-x-step'].value).toFixed(3);
                }

                // Immediate visual update (lerp will handle the rest in next frame, but this makes it snappy)
                window.pistolModel.position.set(xv, yv, zv);
                window.pistolModel.scale.set(sv, sv, sv);
                window.pistolModel.rotation.set(rxv, ryv, rzv);
                if (muzzleFlash) muzzleFlash.position.set(mxv, myv, mzv);
            };

            // Attach input listeners
            ids.forEach(id => {
                if (inputs[id]) inputs[id].addEventListener('input', apply);
            });

            // Nudge button delegation
            panel.addEventListener('pointerdown', (e) => {
                const btn = e.target.closest('.nudge-btn');
                if (!btn) return;

                const targetId = btn.dataset.target;
                const dir = parseFloat(btn.dataset.dir || 0);
                const input = inputs[targetId];

                if (input && dir !== 0) {
                    const step = parseFloat(input.step) || 0.01;
                    const val = parseFloat(input.value);
                    const stepStr = input.step.toString();
                    const decimals = stepStr.includes('.') ? stepStr.split('.')[1].length : 3;
                    input.value = (val + (step * dir)).toFixed(decimals);
                    apply();
                }
            });

            // Fine nudge logic
            if (xMinus && inputs['pistol-x'] && inputs['pistol-x-step']) {
                xMinus.addEventListener('click', () => {
                    const step = parseFloat(inputs['pistol-x-step'].value);
                    const x = inputs['pistol-x'];
                    x.value = (parseFloat(x.value) - step).toFixed(3);
                    apply();
                });
            }
            if (xPlus && inputs['pistol-x'] && inputs['pistol-x-step']) {
                xPlus.addEventListener('click', () => {
                    const step = parseFloat(inputs['pistol-x-step'].value);
                    const x = inputs['pistol-x'];
                    x.value = (parseFloat(x.value) + step).toFixed(3);
                    apply();
                });
            }

            if (copy) {
                copy.addEventListener('click', () => {
                    const w = WEAPONS[curWeaponIdx];
                    console.log('[Pistol GLB] Hip:', w.glbHip, 'Ads:', w.glbAds, 'MuzzleHip:', w.muzzleHip, 'MuzzleAds:', w.muzzleAds);
                    const original = copy.textContent;
                    copy.textContent = "Copied to Console";
                    setTimeout(() => copy.textContent = original, 1000);
                });
            }

            // Sync from current state
            const syncFromState = () => {
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'PISTOL') return;
                const t = isAiming ? w.glbAds : w.glbHip;
                const m = isAiming ? w.muzzleAds : w.muzzleHip;

                if (t && inputs['pistol-x']) {
                    inputs['pistol-x'].value = t.pos.x.toFixed(3);
                    inputs['pistol-y'].value = t.pos.y.toFixed(3);
                    inputs['pistol-z'].value = t.pos.z.toFixed(3);
                    inputs['pistol-scale'].value = t.scale.x.toFixed(3);
                    inputs['pistol-rx'].value = t.rot.x.toFixed(3);
                    inputs['pistol-ry'].value = t.rot.y.toFixed(3);
                    inputs['pistol-rz'].value = t.rot.z.toFixed(3);
                }
                if (m && inputs['pistol-mx']) {
                    inputs['pistol-mx'].value = m.x.toFixed(3);
                    inputs['pistol-my'].value = m.y.toFixed(3);
                    inputs['pistol-mz'].value = m.z.toFixed(3);
                }
                apply(); // Refresh displays
            };

            // Call sync whenever panel is shown or state changes?
            // For now, just sync once on load, but in a real app would need a listener.
            syncFromState();
            let lastAiming = isAiming;
            setInterval(() => {
                if (panel.style.display === 'block' && lastAiming !== isAiming) {
                    syncFromState();
                    lastAiming = isAiming;
                }
            }, 100);
        }

        function buildSniper() {
            // [User Request] Load Sniper.glb model instead of procedural mesh
            console.log("Attempting to load Sniper GLB...");
            if (typeof THREE.GLTFLoader !== 'undefined') {
                // Remove existing arms if any
                const oldLArm = weaponModel.getObjectByName('LeftArmGroup');
                if (oldLArm) weaponModel.remove(oldLArm);
                const oldRArm = weaponModel.getObjectByName('RightArmGroup');
                if (oldRArm) weaponModel.remove(oldRArm);

                // Global token check for async load
                const token = weaponLoadToken;

                const loader = new THREE.GLTFLoader();
                loader.load('gun/Sniper.glb', function (gltf) {
                    if (token !== weaponLoadToken) return;
                    const model = gltf.scene;

                    model.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Initial transform (use glbHip from config if available, else defaults)
                    const wData = WEAPONS.find(w => w.type === 'SNIPER');
                    if (wData && wData.glbHip) {
                        model.position.copy(wData.glbHip.pos);
                        model.rotation.set(wData.glbHip.rot.x, wData.glbHip.rot.y, wData.glbHip.rot.z);
                        model.scale.copy(wData.glbHip.scale);
                    } else {
                        model.scale.set(0.2, 0.2, 0.2);
                        model.rotation.set(0, 3.14, 0);
                        model.position.set(0.15, -0.3, 1.0);
                    }

                    // Remove any previous GLB sniper model
                    if (window.sniperModel) {
                        weaponModel.remove(window.sniperModel);
                    }

                    window.sniperModel = model;
                    weaponModel.add(model);
                    weaponModel.updateMatrixWorld(true);

                    // Show debug panel for adjusting Sniper GLB position
                    setupSniperDebugUI();
                    const sniperPanel = document.getElementById('sniper-debug-panel');
                    if (sniperPanel) sniperPanel.style.display = 'none';

                    console.log("Sniper GLB loaded successfully");
                }, undefined, function (error) {
                    console.error('Sniper GLB load failed:', error);
                    // Fallback to procedural geometry
                    buildSniperGeometry();
                });
            } else {
                // GLTFLoader not available, use procedural geometry
                buildSniperGeometry();
            }

            // Arms for Sniper (Standardized Scale 2.5)
            const w = WEAPONS.find(weapon => weapon.type === 'SNIPER');
            const targetLArm = isAiming ? (w.lArmAds || w.lArmHip) : w.lArmHip;
            const targetRArm = isAiming ? (w.rArmAds || w.rArmHip) : w.rArmHip;

            const lArm = createArm(targetLArm.pos.x, targetLArm.pos.y, targetLArm.pos.z, targetLArm.rot.x, targetLArm.rot.y, targetLArm.rot.z, false);
            lArm.name = 'LeftArmGroup';
            const rArm = createArm(targetRArm.pos.x, targetRArm.pos.y, targetRArm.pos.z, targetRArm.rot.x, targetRArm.rot.y, targetRArm.rot.z, true);
            rArm.name = 'RightArmGroup';
        }

        function setupSniperDebugUI() {
            const panel = document.getElementById('sniper-debug-panel');
            if (!panel || !window.sniperModel || panel.dataset.bound === '1') return;
            panel.dataset.bound = '1';

            const stop = (e) => { e.stopPropagation(); };
            panel.addEventListener('pointerdown', stop);
            panel.addEventListener('pointermove', stop);
            panel.addEventListener('pointerup', stop);
            panel.addEventListener('click', stop);
            panel.addEventListener('mousedown', stop);
            panel.addEventListener('touchstart', stop, { passive: true });
            panel.addEventListener('touchmove', stop, { passive: true });
            panel.addEventListener('touchend', stop, { passive: true });
            panel.addEventListener('wheel', stop, { passive: true });

            // Elements
            const ids = ['sniper-x', 'sniper-x-step', 'sniper-y', 'sniper-z', 'sniper-scale', 'sniper-rx', 'sniper-ry', 'sniper-rz', 'sniper-mx', 'sniper-my', 'sniper-mz',
                'sniper-lax', 'sniper-lay', 'sniper-laz', 'sniper-larx', 'sniper-lary', 'sniper-larz',
                'sniper-rax', 'sniper-ray', 'sniper-raz', 'sniper-rarx', 'sniper-rary', 'sniper-rarz'];
            const inputs = {};
            const vals = {};

            ids.forEach(id => {
                inputs[id] = document.getElementById(id);
                vals[id] = document.getElementById(id + '-val');
            });

            const xMinus = document.getElementById('sniper-x-minus');
            const xPlus = document.getElementById('sniper-x-plus');
            const xNudgeVal = document.getElementById('sniper-x-nudge-val');
            const copy = document.getElementById('sniper-copy');

            const apply = () => {
                if (!window.sniperModel) return;

                const v = (id) => inputs[id] ? parseFloat(inputs[id].value) : 0;
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'SNIPER') return;

                const xv = v('sniper-x'), yv = v('sniper-y'), zv = v('sniper-z');
                const sv = v('sniper-scale'), rxv = v('sniper-rx'), ryv = v('sniper-ry'), rzv = v('sniper-rz');
                const mxv = v('sniper-mx'), myv = v('sniper-my'), mzv = v('sniper-mz');
                const laxv = v('sniper-lax'), layv = v('sniper-lay'), lazv = v('sniper-laz');
                const larxv = v('sniper-larx'), laryv = v('sniper-lary'), larzv = v('sniper-larz');
                const raxv = v('sniper-rax'), rayv = v('sniper-ray'), razv = v('sniper-raz');
                const rarxv = v('sniper-rarx'), raryv = v('sniper-rary'), rarzv = v('sniper-rarz');

                // ADS-Aware: Update WEAPONS data directly
                const targetTransform = isAiming ? w.glbAds : w.glbHip;
                if (targetTransform) {
                    targetTransform.pos.set(xv, yv, zv);
                    targetTransform.scale.set(sv, sv, sv);
                    targetTransform.rot.set(rxv, ryv, rzv);
                }

                const targetMuzzle = isAiming ? w.muzzleAds : w.muzzleHip;
                if (targetMuzzle) {
                    targetMuzzle.set(mxv, myv, mzv);
                }

                const targetLArm = isAiming ? w.lArmAds : w.lArmHip;
                if (targetLArm) {
                    targetLArm.pos.set(laxv, layv, lazv);
                    targetLArm.rot.set(larxv, laryv, larzv);
                }

                const targetRArm = isAiming ? w.rArmAds : w.rArmHip;
                if (targetRArm) {
                    targetRArm.pos.set(raxv, rayv, razv);
                    targetRArm.rot.set(rarxv, raryv, rarzv);
                }

                // Update text displays
                ids.forEach(id => {
                    if (vals[id] && inputs[id]) {
                        const prec = (inputs[id].step && parseFloat(inputs[id].step) < 0.01) ? 3 : 2;
                        vals[id].textContent = parseFloat(inputs[id].value).toFixed(prec);
                    }
                });
                if (xNudgeVal && inputs['sniper-x-step']) {
                    xNudgeVal.textContent = parseFloat(inputs['sniper-x-step'].value).toFixed(3);
                }

                // Immediate visual update
                window.sniperModel.position.set(xv, yv, zv);
                window.sniperModel.scale.set(sv, sv, sv);
                window.sniperModel.rotation.set(rxv, ryv, rzv);
                if (muzzleFlash) muzzleFlash.position.set(mxv, myv, mzv);

                const lArm = weaponModel.getObjectByName('LeftArmGroup');
                if (lArm) {
                    lArm.position.set(laxv, layv, lazv);
                    lArm.rotation.set(larxv, laryv, larzv);
                }
                const rArm = weaponModel.getObjectByName('RightArmGroup');
                if (rArm) {
                    rArm.position.set(raxv, rayv, razv);
                    rArm.rotation.set(rarxv, raryv, rarzv);
                }
            };

            // Attach input listeners
            ids.forEach(id => {
                if (inputs[id]) inputs[id].addEventListener('input', apply);
            });

            // Nudge button delegation
            panel.addEventListener('pointerdown', (e) => {
                const btn = e.target.closest('.nudge-btn');
                if (!btn) return;

                const targetId = btn.dataset.target;
                const dir = parseFloat(btn.dataset.dir || 0);
                const input = inputs[targetId];

                if (input && dir !== 0) {
                    const step = parseFloat(input.step) || 0.01;
                    const val = parseFloat(input.value);
                    const stepStr = input.step.toString();
                    const decimals = stepStr.includes('.') ? stepStr.split('.')[1].length : 3;
                    input.value = (val + (step * dir)).toFixed(decimals);
                    apply();
                }
            });

            // Fine nudge logic
            if (xMinus && inputs['sniper-x'] && inputs['sniper-x-step']) {
                xMinus.addEventListener('click', () => {
                    const step = parseFloat(inputs['sniper-x-step'].value);
                    const x = inputs['sniper-x'];
                    x.value = (parseFloat(x.value) - step).toFixed(3);
                    apply();
                });
            }
            if (xPlus && inputs['sniper-x'] && inputs['sniper-x-step']) {
                xPlus.addEventListener('click', () => {
                    const step = parseFloat(inputs['sniper-x-step'].value);
                    const x = inputs['sniper-x'];
                    x.value = (parseFloat(x.value) + step).toFixed(3);
                    apply();
                });
            }

            if (copy) {
                copy.addEventListener('click', () => {
                    const w = WEAPONS[curWeaponIdx];
                    console.log('[Sniper GLB] Hip:', w.glbHip, 'Ads:', w.glbAds, 'MuzzleHip:', w.muzzleHip, 'MuzzleAds:', w.muzzleAds, 'LArmHip:', w.lArmHip, 'LArmAds:', w.lArmAds, 'RArmHip:', w.rArmHip, 'RArmAds:', w.rArmAds);
                    const original = copy.textContent;
                    copy.textContent = "Copied to Console";
                    setTimeout(() => copy.textContent = original, 1000);
                });
            }

            // Sync from current state
            const syncFromState = () => {
                const w = WEAPONS[curWeaponIdx];
                if (!w || w.type !== 'SNIPER') return;
                const t = isAiming ? w.glbAds : w.glbHip;
                const m = isAiming ? w.muzzleAds : w.muzzleHip;
                const la = isAiming ? w.lArmAds : w.lArmHip;
                const ra = isAiming ? w.rArmAds : w.rArmHip;

                if (t && inputs['sniper-x']) {
                    inputs['sniper-x'].value = t.pos.x.toFixed(3);
                    inputs['sniper-y'].value = t.pos.y.toFixed(3);
                    inputs['sniper-z'].value = t.pos.z.toFixed(3);
                    inputs['sniper-scale'].value = t.scale.x.toFixed(3);
                    inputs['sniper-rx'].value = t.rot.x.toFixed(3);
                    inputs['sniper-ry'].value = t.rot.y.toFixed(3);
                    inputs['sniper-rz'].value = t.rot.z.toFixed(3);
                }
                if (m && inputs['sniper-mx']) {
                    inputs['sniper-mx'].value = m.x.toFixed(3);
                    inputs['sniper-my'].value = m.y.toFixed(3);
                    inputs['sniper-mz'].value = m.z.toFixed(3);
                }
                if (la && inputs['sniper-lax']) {
                    inputs['sniper-lax'].value = la.pos.x.toFixed(3);
                    inputs['sniper-lay'].value = la.pos.y.toFixed(3);
                    inputs['sniper-laz'].value = la.pos.z.toFixed(3);
                    inputs['sniper-larx'].value = la.rot.x.toFixed(3);
                    inputs['sniper-lary'].value = la.rot.y.toFixed(3);
                    inputs['sniper-larz'].value = la.rot.z.toFixed(3);
                }
                if (ra && inputs['sniper-rax']) {
                    inputs['sniper-rax'].value = ra.pos.x.toFixed(3);
                    inputs['sniper-ray'].value = ra.pos.y.toFixed(3);
                    inputs['sniper-raz'].value = ra.pos.z.toFixed(3);
                    inputs['sniper-rarx'].value = ra.rot.x.toFixed(3);
                    inputs['sniper-rary'].value = ra.rot.y.toFixed(3);
                    inputs['sniper-rarz'].value = ra.rot.z.toFixed(3);
                }
                apply(); // Refresh displays
            };

            syncFromState();
            let lastAiming = isAiming;
            setInterval(() => {
                if (panel.style.display === 'block' && lastAiming !== isAiming) {
                    syncFromState();
                    lastAiming = isAiming;
                }
            }, 100);
        }

        function applyKnifeDebug() {
            if (!window.knifeModel) return;

            const v = (id) => {
                const el = document.getElementById(id);
                return el ? parseFloat(el.value) : 0;
            };
            const w = WEAPONS.find(weapon => weapon.type === 'KNIFE');
            if (!w) return;

            const xv = v('knife-x'), yv = v('knife-y'), zv = v('knife-z');
            const rxv = v('knife-rx'), ryv = v('knife-ry'), rzv = v('knife-rz');
            const sv = v('knife-scale');

            const laxv = v('knife-lax'), layv = v('knife-lay'), lazv = v('knife-laz');
            const larxv = v('knife-larx'), laryv = v('knife-lary'), larzv = v('knife-larz');

            const raxv = v('knife-rax'), rayv = v('knife-ray'), razv = v('knife-raz');
            const rarxv = v('knife-rarx'), raryv = v('knife-rary'), rarzv = v('knife-rarz');

            // Update WEAPONS data
            if (w.glbHip) {
                w.glbHip.pos.set(xv, yv, zv);
                w.glbHip.rot.set(rxv, ryv, rzv);
                w.glbHip.scale.set(sv, sv, sv);
            }
            if (w.lArmHip) {
                w.lArmHip.pos.set(laxv, layv, lazv);
                w.lArmHip.rot.set(larxv, laryv, larzv);
            }
            if (w.rArmHip) {
                w.rArmHip.pos.set(raxv, rayv, razv);
                w.rArmHip.rot.set(rarxv, raryv, rarzv);
            }

            // Update text displays
            const ids = [
                'knife-x', 'knife-y', 'knife-z', 'knife-rx', 'knife-ry', 'knife-rz', 'knife-scale',
                'knife-lax', 'knife-lay', 'knife-laz', 'knife-larx', 'knife-lary', 'knife-larz',
                'knife-rax', 'knife-ray', 'knife-raz', 'knife-rarx', 'knife-rary', 'knife-rarz'
            ];
            ids.forEach(id => {
                const valEl = document.getElementById(id + '-val');
                const inputEl = document.getElementById(id);
                if (valEl && inputEl) {
                    valEl.textContent = parseFloat(inputEl.value).toFixed(2);
                }
            });

            // Immediate visual update
            window.knifeModel.position.set(xv, yv, zv);
            window.knifeModel.rotation.set(rxv, ryv, rzv);
            window.knifeModel.scale.set(sv, sv, sv);
            window.knifeModel.updateMatrix();

            const lArm = weaponModel.getObjectByName('LeftArmGroup');
            if (lArm) {
                lArm.position.set(laxv, layv, lazv);
                lArm.rotation.set(larxv, laryv, larzv);
            }
            const rArm = weaponModel.getObjectByName('RightArmGroup');
            if (rArm) {
                rArm.position.set(raxv, rayv, razv);
                rArm.rotation.set(rarxv, raryv, rarzv);
            }
        }

        function syncKnifeFromState() {
            const w = WEAPONS.find(weapon => weapon.type === 'KNIFE');
            const panel = document.getElementById('knife-debug-panel');
            if (!w || !panel) return;

            const setEl = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.value = val;
            };

            if (w.glbHip) {
                setEl('knife-x', w.glbHip.pos.x);
                setEl('knife-y', w.glbHip.pos.y);
                setEl('knife-z', w.glbHip.pos.z);
                setEl('knife-rx', w.glbHip.rot.x);
                setEl('knife-ry', w.glbHip.rot.y);
                setEl('knife-rz', w.glbHip.rot.z);
                setEl('knife-scale', w.glbHip.scale.x);
            }
            if (w.lArmHip) {
                setEl('knife-lax', w.lArmHip.pos.x);
                setEl('knife-lay', w.lArmHip.pos.y);
                setEl('knife-laz', w.lArmHip.pos.z);
                setEl('knife-larx', w.lArmHip.rot.x);
                setEl('knife-lary', w.lArmHip.rot.y);
                setEl('knife-larz', w.lArmHip.rot.z);
            }
            if (w.rArmHip) {
                setEl('knife-rax', w.rArmHip.pos.x);
                setEl('knife-ray', w.rArmHip.pos.y);
                setEl('knife-raz', w.rArmHip.pos.z);
                setEl('knife-rarx', w.rArmHip.rot.x);
                setEl('knife-rary', w.rArmHip.rot.y);
                setEl('knife-rarz', w.rArmHip.rot.z);
            }
            applyKnifeDebug();
        }

        function setupKnifeDebugUI() {
            const panel = document.getElementById('knife-debug-panel');
            if (!panel || !window.knifeModel) return;

            if (panel.dataset.bound === '1') {
                console.log('[Knife Debug] Re-syncing panel');
                syncKnifeFromState();
                return;
            }
            console.log('[Knife Debug] Binding panel');
            panel.dataset.bound = '1';

            const stop = (e) => { e.stopPropagation(); };
            panel.addEventListener('pointerdown', stop);
            panel.addEventListener('pointermove', stop);
            panel.addEventListener('pointerup', stop);
            panel.addEventListener('click', stop);
            panel.addEventListener('mousedown', stop);
            panel.addEventListener('touchstart', stop, { passive: true });
            panel.addEventListener('touchmove', stop, { passive: true });
            panel.addEventListener('touchend', stop, { passive: true });
            panel.addEventListener('wheel', stop, { passive: true });

            const ids = [
                'knife-x', 'knife-y', 'knife-z', 'knife-rx', 'knife-ry', 'knife-rz', 'knife-scale',
                'knife-lax', 'knife-lay', 'knife-laz', 'knife-larx', 'knife-lary', 'knife-larz',
                'knife-rax', 'knife-ray', 'knife-raz', 'knife-rarx', 'knife-rary', 'knife-rarz'
            ];

            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', applyKnifeDebug);
            });

            // Handler for nudge buttons
            const handleNudge = (e) => {
                const btn = e.target.closest('.nudge-btn');
                if (!btn) return;
                e.preventDefault();
                const targetId = btn.dataset.target;
                const dir = parseFloat(btn.dataset.dir || 0);
                const input = document.getElementById(targetId);
                if (input && dir !== 0) {
                    const step = parseFloat(input.step) || 0.01;
                    const val = parseFloat(input.value);
                    input.value = (val + (step * dir)).toFixed(2);
                    applyKnifeDebug();
                }
            };
            panel.addEventListener('pointerdown', (e) => {
                if (e.target.closest('.nudge-btn')) handleNudge(e);
            });
            panel.addEventListener('click', (e) => {
                if (e.target.closest('.nudge-btn')) handleNudge(e);
            });

            const copyBtn = document.getElementById('knife-copy');
            if (copyBtn) {
                copyBtn.addEventListener('click', () => {
                    const w = WEAPONS.find(weapon => weapon.type === 'KNIFE');
                    console.log('[Knife GLB] config:', w.glbHip, 'LArmHip:', w.lArmHip, 'RArmHip:', w.rArmHip);
                    const original = copyBtn.textContent;
                    copyBtn.textContent = "Copied to Console";
                    setTimeout(() => copyBtn.textContent = original, 1000);
                });
            }

            syncKnifeFromState();
        }

        function buildSniperGeometry() {
            // 리시버 (본체)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.07, 0.4), matBody);
            weaponModel.add(receiver);

            // 배럴 (더 상세하게)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.8, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.6);
            weaponModel.add(barrel);

            // 머즐 브레이크 (Muzzle Brake) - 더 상세하게
            const brake = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.08, 16), matSilver);
            brake.rotation.x = Math.PI / 2; brake.position.set(0, 0.015, -1.0);
            weaponModel.add(brake);

            // 머즐 브레이크 구멍들
            for (let i = 0; i < 3; i++) {
                const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.1, 8), matBody);
                hole.rotation.x = Math.PI / 2;
                hole.rotation.z = (i - 1) * 0.3;
                hole.position.set(0, 0.015 + (i - 1) * 0.01, -1.0);
                weaponModel.add(hole);
            }

            // 스코프 몸체 (Scope Body)
            const scopeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.25, 16), matParts);
            scopeBody.rotation.x = Math.PI / 2; scopeBody.position.set(0, 0.075, 0);
            weaponModel.add(scopeBody);

            // 스코프 링 (Scope Rings)
            const scopeRing1 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing1.rotation.x = Math.PI / 2; scopeRing1.position.set(0, 0.075, -0.1);
            weaponModel.add(scopeRing1);
            const scopeRing2 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing2.rotation.x = Math.PI / 2; scopeRing2.position.set(0, 0.075, 0.1);
            weaponModel.add(scopeRing2);

            // 스코프 렌즈 (전면)
            const lensF = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.01, 16), matParts);
            lensF.rotation.x = Math.PI / 2; lensF.position.set(0, 0.075, -0.13);
            weaponModel.add(lensF);

            // 스코프 유리 (후면)
            const glass = new THREE.Mesh(new THREE.CircleGeometry(0.02, 16), matLens);
            glass.position.set(0, 0.075, 0.13);
            weaponModel.add(glass);

            // 조정 노브 (Adjustment Knobs)
            const knob1 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob1.rotation.x = Math.PI / 2; knob1.position.set(0.03, 0.075, 0);
            weaponModel.add(knob1);
            const knob2 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob2.rotation.x = Math.PI / 2; knob2.position.set(-0.03, 0.075, 0);
            weaponModel.add(knob2);

            // 볼트 (Bolt)
            const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), matSilver);
            bolt.position.set(0.04, 0.02, 0.1);
            weaponModel.add(bolt);

            // 볼트 핸들
            const boltHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.03, 8), matSilver);
            boltHandle.rotation.x = Math.PI / 2; boltHandle.position.set(0.06, 0.02, 0.1);
            weaponModel.add(boltHandle);

            // 개머리판 (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.12, 0.25), matParts);
            stock.position.set(0, -0.02, 0.3);
            weaponModel.add(stock);

            // 개머리판 체크 레스트
            const cheekRest = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.04, 0.15), matParts);
            cheekRest.position.set(0, 0.05, 0.25);
            weaponModel.add(cheekRest);

            // 개머리판 패드
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.14, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.42);
            weaponModel.add(stockPad);

            // 바이포드 (Bipod) - 더 상세하게
            const bipodBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.15), matParts);
            bipodBase.position.set(0, -0.05, -0.4);
            weaponModel.add(bipodBase);

            // 바이포드 다리들
            const bipodLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg1.position.set(-0.015, -0.13, -0.4);
            bipodLeg1.rotation.z = 0.3;
            weaponModel.add(bipodLeg1);
            const bipodLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg2.position.set(0.015, -0.13, -0.4);
            bipodLeg2.rotation.z = -0.3;
            weaponModel.add(bipodLeg2);

            // 트리거 가드
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // 탄창 (Magazine) - NEW for Sniper
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.09, 0.06), matParts);
            magazine.name = "magazine";
            magazine.position.set(0, -0.08, 0.04);
            weaponModel.add(magazine);

            const lArm = createArm(-0.15, -0.25, -0.6, 0.7, 0.3, -0.35, false); // Adjusted for Scale 2.5
            lArm.name = 'LeftArmGroup';
            const rArm = createArm(0.12, -0.28, 0.1, 0.2, -0.2, 0.4, true);
            rArm.name = 'RightArmGroup';
        }

        function buildPistol() {
            // [User Request] Load pistol.glb model instead of procedural mesh
            console.log("Attempting to load Pistol GLB...");
            if (typeof THREE.GLTFLoader !== 'undefined') {
                // Define arm materials
                const armSleeveMat = new THREE.MeshBasicMaterial({ color: 0x2b2b2b });
                const armSkinMat = new THREE.MeshBasicMaterial({ color: 0xeebb99 });

                // Remove existing arms if any
                const oldLArm = weaponModel.getObjectByName('LeftArmGroup');
                if (oldLArm) weaponModel.remove(oldLArm);
                const oldRArm = weaponModel.getObjectByName('RightArmGroup');
                if (oldRArm) weaponModel.remove(oldRArm);

                // Right Arm Group (Grip Position)
                const rArmGroup = new THREE.Group();
                rArmGroup.name = 'RightArmGroup';
                const rSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.14, 0.55), armSleeveMat);
                rSleeve.position.set(0, 0, 0.25);
                rArmGroup.add(rSleeve);
                const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.1, 0.14), armSkinMat);
                rHand.position.set(0, 0, -0.05);
                rArmGroup.add(rHand);
                rArmGroup.position.set(0.06, -0.15, 0.05);
                rArmGroup.rotation.set(0.1, 0, 0.05);
                rArmGroup.scale.set(1.6, 1.6, 1.6);
                weaponModel.add(rArmGroup);

                // Left Arm Group (Support Hand)
                const lArmGroup = new THREE.Group();
                lArmGroup.name = 'LeftArmGroup';
                const lSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.14, 0.55), armSleeveMat);
                lSleeve.position.set(0, 0, 0.25);
                lArmGroup.add(lSleeve);
                const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.1, 0.14), armSkinMat);
                lHand.position.set(0, 0, -0.05);
                lArmGroup.add(lHand);
                lArmGroup.position.set(-0.06, -0.15, 0.05);
                lArmGroup.rotation.set(0.1, 0, -0.05);
                lArmGroup.scale.set(1.6, 1.6, 1.6);
                weaponModel.add(lArmGroup);

                // Global token check for async load
                const token = weaponLoadToken;

                const loader = new THREE.GLTFLoader();
                loader.load('gun/pistol.glb', function (gltf) {
                    if (token !== weaponLoadToken) return;
                    const model = gltf.scene;

                    model.traverse(function (child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    // Initial transform - user configured values
                    model.scale.set(0.20, 0.20, 0.20);
                    model.rotation.set(0.04, 1.61, 0.05);
                    model.position.set(-0.02, 0.02, 0.09);

                    // Remove any previous GLB pistol model
                    if (window.pistolModel) {
                        weaponModel.remove(window.pistolModel);
                    }

                    window.pistolModel = model;
                    weaponModel.add(model);
                    weaponModel.updateMatrixWorld(true);

                    // Show debug panel for adjusting pistol GLB position
                    setupPistolDebugUI();
                    const pistolPanel = document.getElementById('pistol-debug-panel');
                    // [User Request] Hide debug panel after configuration
                    if (pistolPanel) pistolPanel.style.display = 'none';

                    console.log("Pistol GLB loaded successfully");
                }, undefined, function (error) {
                    console.error('Pistol GLB load failed:', error);
                    // Fallback to procedural geometry
                    buildPistolGeometry();
                });
            } else {
                // GLTFLoader not available, use procedural geometry
                buildPistolGeometry();
            }
        }

        // Fallback procedural pistol geometry
        function buildPistolGeometry() {
            // 슬라이드 (Slide) - 더 상세하게
            const slide = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.04, 0.18), matSilver);
            slide.position.y = 0.02;
            weaponModel.add(slide);

            // 슬라이드 세리레이션 (Serrations)
            for (let i = 0; i < 8; i++) {
                const serration = new THREE.Mesh(new THREE.BoxGeometry(0.001, 0.01, 0.02), matBody);
                serration.position.set(0, 0.02, 0.05 - i * 0.015);
                weaponModel.add(serration);
            }

            // 배럴
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.15, 12), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.02, -0.08);
            weaponModel.add(barrel);

            // 프레임 (Frame)
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.08, 0.12), matBody);
            frame.position.set(0, -0.02, 0.03);
            weaponModel.add(frame);

            // 그립 (Grip) - 더 상세하게
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.1, 0.05), matParts);
            grip.position.set(0, -0.04, 0.05); grip.rotation.x = 0.1;
            weaponModel.add(grip);

            // 그립 텍스처 (패턴)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    const gripDot = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, 0.01, 8), matParts);
                    gripDot.rotation.x = Math.PI / 2;
                    gripDot.position.set((j - 0.5) * 0.015, -0.04 + i * 0.03, 0.05);
                    weaponModel.add(gripDot);
                }
            }

            // 해머 (Hammer)
            const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.01), matSilver);
            hammer.position.set(0, 0.01, 0.1);
            hammer.rotation.x = 0.3;
            weaponModel.add(hammer);

            // 트리거 가드 (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // 트리거 (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.012, 0.015), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // 가늠자 (Rear Sight) - ㄷ자 형태
            const rsBase = new THREE.Mesh(new THREE.BoxGeometry(0.022, 0.003, 0.008), matParts);
            rsBase.position.set(0, 0.048, 0.08);
            weaponModel.add(rsBase);
            const rsL = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsL.position.set(-0.01, 0.048, 0.08);
            weaponModel.add(rsL);
            const rsR = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsR.position.set(0.01, 0.048, 0.08);
            weaponModel.add(rsR);

            // 가늠쇠 (Front Sight) - 빨간 점
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.012, 0.003), matParts);
            fsPost.position.set(0, 0.045, -0.09);
            weaponModel.add(fsPost);
            const fsDot = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.003, 0.001), matSight);
            fsDot.position.set(0, 0.0482, -0.09);
            fsDot.userData.isSight = true;
            weaponModel.add(fsDot);

            // 탄창 (Magazine)
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.08, 0.04), matParts);
            magazine.name = "magazine";
            magazine.position.set(0, -0.08, 0.05);
            weaponModel.add(magazine);

            // 탄창 바닥 플레이트
            const magPlate = new THREE.Mesh(new THREE.BoxGeometry(0.027, 0.01, 0.042), matSilver);
            magPlate.position.set(0, -0.12, 0.05);
            weaponModel.add(magPlate);

            // Arms (Standardized Scale 1.6 for Pistol)
            const rArm = createArm(0.06, -0.15, 0.05, 0.1, 0, 0.05, true);
            rArm.name = 'RightArmGroup';
            rArm.scale.set(1.6, 1.6, 1.6);
            const lArm = createArm(-0.06, -0.15, 0.05, 0.1, 0, -0.05, false);
            lArm.name = 'LeftArmGroup';
            lArm.scale.set(1.6, 1.6, 1.6);
        }

        function buildKnife() {
            const w = WEAPONS.find(weapon => weapon.type === 'KNIFE');
            if (!w) return;

            // Clear previous
            if (window.knifeModel) weaponModel.remove(window.knifeModel);

            const loader = new THREE.GLTFLoader();
            loader.load('gun/Knife.glb', (gltf) => {
                const knifeGroup = gltf.scene;
                window.knifeModel = knifeGroup;

                // Position knife from WEAPONS config
                if (w.glbHip) {
                    knifeGroup.position.copy(w.glbHip.pos);
                    knifeGroup.rotation.set(w.glbHip.rot.x, w.glbHip.rot.y, w.glbHip.rot.z);
                    knifeGroup.scale.copy(w.glbHip.scale);
                } else {
                    knifeGroup.scale.set(1.0, 1.0, 1.0);
                    knifeGroup.position.set(0.1, -0.2, 0.1);
                }
                weaponModel.add(knifeGroup);
                setupKnifeDebugUI();
            });

            // --- RIGHT ARM (Holding the knife) ---
            const rArm = createArm(0, 0, 0, 0, 0, 0, true);
            rArm.name = 'RightArmGroup';
            const ra = w.rArmHip;
            if (ra) {
                rArm.position.copy(ra.pos);
                rArm.rotation.set(ra.rot.x, ra.rot.y, ra.rot.z);
            } else {
                rArm.position.set(0.12, -0.2, -0.15);
                rArm.rotation.set(0, -0.15, 0.05);
            }
            // Overriding createArm's default fingers for knife grip
            // (Note: createArm already adds sleeve/hand/fingers)

            // --- LEFT ARM (Supporting/Ready) ---
            const lArm = createArm(0, 0, 0, 0, 0, 0, false);
            lArm.name = 'LeftArmGroup';
            const la = w.lArmHip;
            if (la) {
                lArm.position.copy(la.pos);
                lArm.rotation.set(la.rot.x, la.rot.y, la.rot.z);
            } else {
                lArm.position.set(-1.2, -0.35, -0.25);
                lArm.rotation.set(0.2, 0.3, -0.15);
            }

        }



        function createArm(x, y, z, rotX, rotY, rotZ, isTrigger) {
            const grp = new THREE.Group();

            // Sleeve (Standardized 2.5 Scale Thickness)
            const sleeve = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.14, 0.55), matSleeve);
            sleeve.position.set(0, 0, 0.25);
            sleeve.castShadow = true;
            grp.add(sleeve);

            // Hand (Standardized Skin Color)
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.1, 0.14), matSkin); // [MOD] Skin color by default
            hand.position.set(0, 0, -0.05);
            hand.castShadow = true;
            grp.add(hand);

            if (isTrigger) {
                // Trigger Finger
                const finger = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.03, 0.08), matSkin);
                finger.position.set(0.04, 0.02, -0.12);
                finger.castShadow = true;
                grp.add(finger);
            }
            // [FIX] Removed extra 'fingers' block for left hand to prevent doubled geometry

            grp.position.set(x, y, z);
            grp.rotation.set(rotX, rotY, rotZ);

            // [MOD] Standardized Scale 2.5 for all weapons
            grp.scale.set(2.5, 2.5, 2.5);

            weaponModel.add(grp);
            return grp;
        }

        function buildGrenade() {
            const grp = new THREE.Group();

            // Grenade Body
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.065, 16, 16), matGrenade);
            body.position.set(0.02, 0.0, 0.0);
            grp.add(body);

            // Pin/Handle
            const pin = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.07, 8), matSilver);
            pin.position.set(0.02, 0.065, 0.0);
            grp.add(pin);

            // Hand (Grip)
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.16), matGlove);
            hand.position.set(0.0, -0.06, 0.02);
            grp.add(hand);

            // Forearm (Extra visibility)
            const forearm = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.11, 1.0), matSleeve);
            forearm.position.set(0.0, -1.0, 0.02);
            grp.add(forearm);


            grp.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            weaponModel.add(grp);
            return grp;
        }

        // --- Enemy AI & Parts ---
        function createEnemyAI() {
            const enemy = new THREE.Group();


            // FIX: Clone Materials to prevent shared color change
            const mClothes = matZombieClothes.clone();
            const mSkin = matZombieSkin.clone();

            // 색상 랜덤화 (좀비마다 약간씩 다른 느낌)
            mClothes.color.setHSL(0.1 + Math.random() * 0.1, 0.4, 0.2 + Math.random() * 0.2); // 썩은 옷 색깔
            mSkin.color.setHSL(0.3 + Math.random() * 0.1, 0.4, 0.4 + Math.random() * 0.2);   // 썩은 피부 (녹색 계열)

            // 좀비 그룹 스케일 랜덤화 (키 차이)
            const scale = 0.9 + Math.random() * 0.2;
            enemy.scale.set(scale, scale, scale);

            // 1. 몸통 (Torso) - 갈비뼈 느낌의 텍스처(단순화된 형태) 대신 구부정한 자세 표현
            const bodyGeo = new THREE.BoxGeometry(0.45, 0.6, 0.25);
            // 상체 굽히기
            bodyGeo.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0.3, 0));
            bodyGeo.applyMatrix4(new THREE.Matrix4().makeRotationX(0.2));
            const body = new THREE.Mesh(bodyGeo, mClothes);
            body.position.y = 0.8;
            body.name = 'body';
            enemy.add(body);

            // 2. 머리 (Head) - 턱이 빠진 듯한 느낌 + 퀭한 눈
            const headGroup = new THREE.Group();

            // 두개골
            const skull = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 0.24), mSkin);
            skull.position.y = 0.05;
            headGroup.add(skull);

            // 턱 (Jaw) - 약간 벌어진 입
            const jaw = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.08, 0.20), mSkin);
            jaw.position.set(0, -0.12, 0.02);
            jaw.rotation.x = 0.3; // 입 벌림
            headGroup.add(jaw);

            // 눈 (Eyes) - 비대칭 및 붉은 안광
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            // 왼쪽 눈
            const lEye = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), eyeMat);
            lEye.position.set(-0.06, 0.08, 0.12);
            headGroup.add(lEye);
            // 오른쪽 눈 (약간 튀어나오거나 위치 다르게)
            const rEye = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), eyeMat);
            rEye.position.set(0.06, 0.07, 0.11);
            headGroup.add(rEye);

            headGroup.position.set(0, 1.55, 0.1); // 몸보다 약간 앞으로 나온 머리 (거북목)
            headGroup.rotation.x = 0.1;
            headGroup.name = 'head';
            enemy.add(headGroup);

            // 3. 팔 (Arms) - 좀비 특유의 앞으로 뻗은 팔 (비대칭)

            // 왼팔
            const lArmGroup = new THREE.Group();
            const lUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.06, 0.35, 6), mClothes);
            lUpperArm.position.y = -0.15;
            lArmGroup.add(lUpperArm);

            const lForeArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.35, 6), mSkin); // 팔뚝은 살이 드러남
            lForeArm.position.y = -0.5;
            lArmGroup.add(lForeArm);

            lArmGroup.position.set(-0.28, 1.45, 0.05);
            lArmGroup.rotation.x = -1.4; // 앞으로 뻗음
            lArmGroup.rotation.z = 0.2;  // 약간 벌림
            lArmGroup.name = 'limb'; // Explicitly name for hit detection
            enemy.add(lArmGroup);
            enemy.userData.lArm = lArmGroup; // 애니메이션용

            // 오른팔 (약간 더 내려가거나 꺾임)
            const rArmGroup = new THREE.Group();
            const rUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.06, 0.35, 6), mClothes);
            rUpperArm.position.y = -0.15;
            rArmGroup.add(rUpperArm);

            const rForeArm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.35, 6), mSkin);
            rForeArm.position.y = -0.5;
            rArmGroup.add(rForeArm);

            rArmGroup.position.set(0.28, 1.45, 0.05);
            rArmGroup.rotation.x = -1.3;
            rArmGroup.rotation.z = -0.2;
            rArmGroup.name = 'limb'; // Explicitly name for hit detection
            enemy.add(rArmGroup);
            enemy.userData.rArm = rArmGroup;

            // 4. 다리 (Legs) - 뒤틀린 걸음걸이를 위한 분리

            // 왼쪽 다리
            const lLegGroup = new THREE.Group();
            const lThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.08, 0.45, 6), mClothes);
            lThigh.position.y = -0.2;
            lLegGroup.add(lThigh);

            const lCalf = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.07, 0.45, 6), mClothes); // 바지 입음
            lCalf.position.y = -0.65;
            lLegGroup.add(lCalf);

            const lFoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.22), mClothes);
            lFoot.position.set(0, -0.9, 0.05);
            lLegGroup.add(lFoot);

            lLegGroup.position.set(-0.15, 0.8, 0);
            lLegGroup.name = 'limb'; // Explicitly name for hit detection
            enemy.add(lLegGroup);

            // 오른쪽 다리
            const rLegGroup = new THREE.Group();
            const rThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.08, 0.45, 6), mClothes);
            rThigh.position.y = -0.2;
            rLegGroup.add(rThigh);

            const rCalf = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.07, 0.45, 6), mClothes);
            rCalf.position.y = -0.65;
            rLegGroup.add(rCalf);

            const rFoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.22), mClothes);
            rFoot.position.set(0, -0.9, 0.05);
            rLegGroup.add(rFoot);

            rLegGroup.position.set(0.15, 0.8, 0);
            rLegGroup.name = 'limb'; // Explicitly name for hit detection
            enemy.add(rLegGroup);

            // HP Bar (Billboard)
            const hpGroup = new THREE.Group();
            const bgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpBg);
            const fgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpFg);
            fgBar.position.z = 0.01;
            hpGroup.add(bgBar);
            const fgWrapper = new THREE.Group();
            fgWrapper.add(fgBar);
            fgBar.position.x = 0.3; fgWrapper.position.x = -0.3; fgWrapper.position.z = 0.01;
            hpGroup.add(fgWrapper);
            hpGroup.position.set(0, 2.0, 0);
            enemy.add(hpGroup);
            enemy.userData.hpGroup = hpGroup;
            enemy.userData.hpBar = fgWrapper;

            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 20;
            enemy.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);

            // Generate safe spawn - 더 많은 시도와 더 정확한 체크
            let safe = false;
            for (let i = 0; i < 50; i++) {
                // Check if inside collider - 더 정확한 크기로 체크
                const testBox = new THREE.Box3(
                    new THREE.Vector3(enemy.position.x - ENEMY_RADIUS, enemy.position.y, enemy.position.z - ENEMY_RADIUS),
                    new THREE.Vector3(enemy.position.x + ENEMY_RADIUS, enemy.position.y + 1.8, enemy.position.z + ENEMY_RADIUS)
                );
                let hits = false;
                for (let c of colliders) {
                    if (testBox.intersectsBox(c)) {
                        hits = true;
                        break;
                    }
                }
                if (!hits) {
                    safe = true;
                    break;
                }

                // Retry pos - 더 넓은 범위에서 시도
                const ang = Math.random() * Math.PI * 2;
                const d = 15 + Math.random() * 35;
                enemy.position.set(Math.cos(ang) * d, 0, Math.sin(ang) * d);
            }

            // 안전한 위치를 찾지 못해도 최종 위치에서 스폰 시도 (게임 진행을 위해)
            if (!safe) {
                // 최후의 수단: 원점에서 더 먼 거리에서 시도
                const finalAngle = Math.random() * Math.PI * 2;
                const finalDist = 25 + Math.random() * 20;
                enemy.position.set(Math.cos(finalAngle) * finalDist, 0, Math.sin(finalAngle) * finalDist);
                // 그래도 안 되면 그냥 스폰 (게임 진행을 위해)
            }

            enemy.userData.hp = 100;
            enemy.userData.maxHp = 100;
            enemy.userData.attackTimer = 0;
            enemy.userData.isDead = false;
            enemy.userData.moveSpeed = ZOMBIE_SPEED + Math.random();
            enemy.userData.animState = 0;
            enemy.userData.flashTimer = 0;
            enemy.userData.stuckTimer = 0; // 끼어있는 시간 추적
            enemy.userData.lastValidPos = enemy.position.clone(); // 마지막 유효한 위치

            scene.add(enemy);
            enemies.push(enemy);

            // [FIX] Ensure all meshes in the enemy model cast and receive shadows
            enemy.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        }

        function showHitMarker() {
            // Ensure global availability
            if (!window.showHitMarker) window.showHitMarker = showHitMarker;

            if (elHitMarker) {
                elHitMarker.style.opacity = '1';
                elHitMarker.style.transform = 'translate(-50%, -50%) scale(1.2)';
                setTimeout(() => {
                    if (elHitMarker) {
                        elHitMarker.style.transform = 'translate(-50%, -50%) scale(1)';
                        elHitMarker.style.opacity = '0';
                    }
                }, 150);
            }
        }
        // Force global assignment immediately
        window.showHitMarker = showHitMarker;

        function showGrenadeKillMessage() {
            if (elGrenadeKill) {
                elGrenadeKill.style.display = 'block';
                elGrenadeKill.style.opacity = '1';
                elGrenadeKill.style.transform = 'translate(-50%, -50%) scale(1.5)';

                // Animation
                setTimeout(() => {
                    if (elGrenadeKill) elGrenadeKill.style.transform = 'translate(-50%, -50%) scale(1.0)';
                }, 100);

                setTimeout(() => {
                    if (elGrenadeKill) elGrenadeKill.style.display = 'none';
                }, 2000);
            }
        }

        function explodeGrenade(pos) {
            // 1. Visuals - Bigger and more impressive
            const blastGeo = new THREE.SphereGeometry(0.5, 32, 32); // Increased base size 0.2 -> 0.5
            const blastMat = new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.9 });
            const blast = new THREE.Mesh(blastGeo, blastMat);
            blast.position.copy(pos);
            scene.add(blast);

            // Expand animation loop
            let duration = 0;
            const expandAnim = () => {
                duration += 0.04; // Slightly faster updates
                const scale = 1 + duration * 60;
                blast.scale.set(scale, scale, scale);
                blast.material.opacity = 0.9 * (1 - duration / 0.6); // Fade out over 0.6s
                if (duration < 0.6) requestAnimationFrame(expandAnim);
                else scene.remove(blast);
            };
            expandAnim();

            // 2. Sound
            SoundGen.playExplosion();

            // 3. Damage (AoE) - WIDER RANGE
            const EXPLOSION_RADIUS = 10.0;
            const MAX_DAMAGE = 300;

            // Enemies
            enemies.forEach(e => {
                const dist = e.position.distanceTo(pos);
                if (dist < EXPLOSION_RADIUS) {
                    const dmg = Math.floor(MAX_DAMAGE * (1 - dist / EXPLOSION_RADIUS));
                    if (dmg > 0 && e.userData.hp > 0) {
                        e.userData.hp -= dmg;

                        // [FIX] Update Health Bar UI
                        if (e.userData.hpBar) {
                            const hpPercent = Math.max(0, e.userData.hp / e.userData.maxHp);
                            e.userData.hpBar.scale.x = hpPercent;
                            e.userData.hpBar.visible = hpPercent > 0;
                        }

                        // Hit Marker
                        showHitMarker();

                        if (e.userData.hp <= 0) {
                            killEnemy(e);
                            showGrenadeKillMessage(); // [FIX] Show Big Text
                        } else {
                            // [FIX] Hit feedback (Flash Red & Restore)
                            e.traverse(c => {
                                if (c.isMesh && c.material && c.material.emissive) {
                                    // Force Red
                                    c.material.emissive.setHex(0xff0000);

                                    // Clear existing timer if any to prevent flicker
                                    if (c.userData.flashTimeout) clearTimeout(c.userData.flashTimeout);

                                    // Restore to Black (assuming default is black)
                                    c.userData.flashTimeout = setTimeout(() => {
                                        if (c && c.material) c.material.emissive.setHex(0x000000);
                                    }, 100);
                                }
                            });
                        }
                    }
                }
            });

            // 4. Local Player Damage (Self Damage)
            const distToPlayer = position.distanceTo(pos);
            if (distToPlayer < EXPLOSION_RADIUS) {
                const dmg = Math.floor(MAX_DAMAGE * (1 - distToPlayer / EXPLOSION_RADIUS));
                if (dmg > 0) damagePlayer(dmg);
            }

            // 5. Other Players Damage (Multiplayer)
            if (gameMode === 'multi') {
                otherPlayers.forEach(p => {
                    const dist = p.position.distanceTo(pos);
                    if (dist < EXPLOSION_RADIUS) {
                        const dmg = Math.floor(MAX_DAMAGE * (1 - dist / EXPLOSION_RADIUS));
                        if (dmg > 0 && socket && socket.connected) {
                            socket.emit('damagePlayer', {
                                targetId: p.userData.playerId,
                                damage: dmg
                            });
                        }
                    }
                });
            }
        }

        function updateGrenades(dt) {
            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];

                // Gravity
                g.vel.y += GRAVITY * dt;

                // Move
                const nextPos = g.mesh.position.clone().add(g.vel.clone().multiplyScalar(dt));

                // Collision (Simple Box Check)
                let collided = false;

                // Floor check
                if (nextPos.y < 0.15) {
                    nextPos.y = 0.15;
                    g.vel.y *= -0.5; // Bounce dampen
                    g.vel.x *= 0.7; // Friction
                    g.vel.z *= 0.7;
                    collided = true;
                }

                // Wall check (Spatial Grid Optimization)
                const gBox = new THREE.Box3(
                    new THREE.Vector3(nextPos.x - g.radius, nextPos.y - g.radius, nextPos.z - g.radius),
                    new THREE.Vector3(nextPos.x + g.radius, nextPos.y + g.radius, nextPos.z + g.radius)
                );

                const nearby = spatialGrid.query(gBox);
                for (const c of nearby) {
                    if (gBox.intersectsBox(c)) {
                        // Very simple bounce: reverse velocity roughly
                        g.vel.x *= -0.5;
                        g.vel.z *= -0.5;
                        collided = true;
                        break;
                    }
                }


                if (!collided) {
                    g.mesh.position.copy(nextPos);
                    g.mesh.rotation.x += g.vel.length() * dt; // Spin
                } else {
                    g.mesh.position.copy(nextPos); // Still update pos if bouncing
                }

                // Fuse
                g.fuse -= dt;
                if (g.fuse <= 0) {
                    explodeGrenade(g.mesh.position);
                    scene.remove(g.mesh);
                    grenades.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt) {
            if (isDead) return;

            // Spawn - 타이머는 항상 증가, 적 생성만 일시정지 상태가 아닐 때
            // 리젠 수 제한 없음 - 게임이 끝날 때까지 계속 스폰
            if (!isPaused) {
                spawnTimer += dt;
                if (spawnTimer >= SPAWN_INTERVAL) {
                    spawnTimer = 0; // 타이머 리셋 (생성 여부와 무관)
                    createEnemyAI();
                }
            }

            if (isPaused) return; // 일시정지는 적 이동/공격만 중지

            enemies.forEach(e => {
                if (e.userData.isDead) return;

                // Color Flash Update
                if (e.userData.flashTimer > 0) {
                    e.userData.flashTimer -= dt;
                    if (e.userData.flashTimer <= 0) {
                        e.children.forEach(c => {
                            if (c.isMesh && c.material && c.material.emissive) c.material.emissive.setHex(0x000000);
                        });
                    }
                }

                e.lookAt(position.x, e.position.y, position.z);
                e.userData.hpGroup.lookAt(camera.position);

                const dist = e.position.distanceTo(position);

                // --- Simple Enemy Collision vs Walls ---
                // Calculate desired move
                let nextPos = e.position.clone();
                if (dist > ATTACK_RANGE && e.userData.animState <= 0) {
                    const dir = new THREE.Vector3().subVectors(position, e.position).normalize();
                    const moveStep = dir.multiplyScalar(e.userData.moveSpeed * dt);

                    // 현재 위치가 벽에 끼어있는지 체크
                    const currentBox = new THREE.Box3(
                        new THREE.Vector3(e.position.x - ENEMY_RADIUS * 1.2, e.position.y, e.position.z - ENEMY_RADIUS * 1.2),
                        new THREE.Vector3(e.position.x + ENEMY_RADIUS * 1.2, e.position.y + 1.8, e.position.z + ENEMY_RADIUS * 1.2)
                    );
                    let isStuck = false;
                    for (const c of colliders) {
                        if (currentBox.intersectsBox(c)) {
                            isStuck = true;
                            break;
                        }
                    }

                    // 벽에 끼어있으면 벽에서 벗어나도록 이동
                    if (isStuck) {
                        e.userData.stuckTimer += dt;

                        // 1초 이상 끼어있으면 강제 재배치 (2초→1초로 단축)
                        if (e.userData.stuckTimer > 1.0) {
                            // 안전한 위치로 재배치
                            let newPos = null;
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 20 + Math.random() * 25;
                                const testPos = new THREE.Vector3(
                                    Math.cos(angle) * dist,
                                    0,
                                    Math.sin(angle) * dist
                                );
                                const testBox = new THREE.Box3(
                                    new THREE.Vector3(testPos.x - ENEMY_RADIUS * 1.5, testPos.y, testPos.z - ENEMY_RADIUS * 1.5),
                                    new THREE.Vector3(testPos.x + ENEMY_RADIUS * 1.5, testPos.y + 1.8, testPos.z + ENEMY_RADIUS * 1.5)
                                );
                                let canSpawn = true;
                                for (const c of colliders) {
                                    if (testBox.intersectsBox(c)) {
                                        canSpawn = false;
                                        break;
                                    }
                                }
                                if (canSpawn) {
                                    newPos = testPos;
                                    break;
                                }
                            }
                            if (newPos) {
                                e.position.copy(newPos);
                                e.userData.stuckTimer = 0;
                                e.userData.lastValidPos = newPos.clone();
                            }
                        } else {
                            // 벽에서 벗어나기 위해 더 많은 방향과 더 빠른 속도로 시도
                            const escapeDirs = [
                                new THREE.Vector3(1, 0, 0),
                                new THREE.Vector3(-1, 0, 0),
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3(0, 0, -1),
                                new THREE.Vector3(1, 0, 1).normalize(),
                                new THREE.Vector3(-1, 0, 1).normalize(),
                                new THREE.Vector3(1, 0, -1).normalize(),
                                new THREE.Vector3(-1, 0, -1).normalize(),
                                new THREE.Vector3(0.707, 0, 0.707),
                                new THREE.Vector3(-0.707, 0, 0.707),
                                new THREE.Vector3(0.707, 0, -0.707),
                                new THREE.Vector3(-0.707, 0, -0.707)
                            ];

                            let escaped = false;
                            for (const escapeDir of escapeDirs) {
                                // 더 빠른 탈출 속도 (5배→8배)
                                const escapeStep = escapeDir.multiplyScalar(e.userData.moveSpeed * dt * 8);
                                const escapePos = e.position.clone().add(escapeStep);
                                const escapeBox = new THREE.Box3(
                                    new THREE.Vector3(escapePos.x - ENEMY_RADIUS * 1.2, escapePos.y, escapePos.z - ENEMY_RADIUS * 1.2),
                                    new THREE.Vector3(escapePos.x + ENEMY_RADIUS * 1.2, escapePos.y + 1.8, escapePos.z + ENEMY_RADIUS * 1.2)
                                );
                                let canEscape = true;
                                for (const c of colliders) {
                                    if (escapeBox.intersectsBox(c)) {
                                        canEscape = false;
                                        break;
                                    }
                                }
                                if (canEscape) {
                                    e.position.copy(escapePos);
                                    e.userData.lastValidPos = escapePos.clone();
                                    escaped = true;
                                    break;
                                }
                            }

                            // 벽에서 벗어나지 못하면 마지막 유효한 위치로 복귀
                            if (!escaped) {
                                const distToLast = e.position.distanceTo(e.userData.lastValidPos);
                                if (distToLast > 0.5) {
                                    e.position.lerp(e.userData.lastValidPos, 0.3);
                                } else {
                                    // Y축으로도 시도
                                    e.position.y += 0.2;
                                }
                            } else {
                                e.userData.stuckTimer = 0; // 탈출 성공
                            }
                        }
                    } else {
                        // 정상 이동 중이면 마지막 유효 위치 업데이트 및 끼임 타이머 리셋
                        e.userData.lastValidPos = e.position.clone();
                        e.userData.stuckTimer = 0;
                        // 정상 이동
                        let testPos = e.position.clone();
                        testPos.x += moveStep.x;
                        const eBoxX = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colX = false;
                        for (const c of colliders) { if (eBoxX.intersectsBox(c)) { colX = true; break; } }
                        if (!colX) e.position.x += moveStep.x;

                        testPos = e.position.clone();
                        testPos.z += moveStep.z;
                        const eBoxZ = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colZ = false;
                        for (const c of colliders) { if (eBoxZ.intersectsBox(c)) { colZ = true; break; } }
                        if (!colZ) e.position.z += moveStep.z;
                    }

                    e.position.y = Math.abs(Math.sin(lastTime * 0.005)) * 0.1;
                }
                else if (dist <= ATTACK_RANGE) {
                    e.userData.attackTimer += dt;
                    if (e.userData.attackTimer > 1.0) {
                        e.userData.attackTimer = 0;
                        e.userData.animState = 0.5;
                        SoundGen.playZombieAttack();
                        damagePlayer(ZOMBIE_DMG);
                    }
                }

                if (e.userData.animState > 0) {
                    e.userData.animState -= dt;
                    const progress = 1 - (e.userData.animState / 0.5);
                    e.userData.rArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.userData.lArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.position.add(e.getWorldDirection(new THREE.Vector3()).multiplyScalar(Math.sin(progress * Math.PI) * 0.05));
                } else {
                    e.children.forEach(c => {
                        if (c.name === 'limb' && c.position.y > 1.0) c.rotation.x = -1.6;
                    });
                }
            });
        }
        function damagePlayer(amount) {
            if (isDead) return;
            const oldHP = playerHP;
            playerHP -= amount;
            playerHP = Math.max(0, playerHP);

            // 1. Update Main Bar
            if (elHpBar) elHpBar.style.width = playerHP + '%';
            if (elHpText) elHpText.innerText = Math.floor(playerHP);

            // 2. Ghost Bar Logic
            if (elHpGhost) {
                elHpGhost.style.width = oldHP + '%';
                elHpGhost.style.transition = 'none';
                setTimeout(() => {
                    elHpGhost.style.transition = 'width 0.5s ease-out';
                    elHpGhost.style.width = playerHP + '%';
                }, 300);
            }

            // 3. Color State
            const vitalsPanel = document.querySelector('.vitals-panel');
            if (vitalsPanel) {
                if (playerHP <= 30) vitalsPanel.classList.add('critical');
                else vitalsPanel.classList.remove('critical');
            }

            // 4. Damage Vignette
            if (elDamage) {
                elDamage.style.opacity = 1;
                setTimeout(() => elDamage.style.opacity = 0, 300);
            }

            SoundGen.playDamage();

            if (playerHP <= 0) {
                isDead = true;
                if (gameMode === 'single') {
                    const gameOverTitle = document.getElementById('game-over-title');
                    if (gameOverTitle) gameOverTitle.innerText = 'YOU DIED';
                    const gameOverKills = document.getElementById('final-kill-count');
                    if (gameOverKills) gameOverKills.innerText = killCount;
                    if (elGameOver) elGameOver.style.display = 'flex';
                }
                if (!isMobile && document.pointerLockElement === document.body) {
                    document.exitPointerLock();
                }
            }
        }

        function addKillFeed(killer, victim, isHeadshot) {
            if (!elKillFeed) return;
            const item = document.createElement('div');
            item.className = 'feed-item';
            const icon = isHeadshot ? '⌖' : '➔';
            item.innerHTML = `<span class="killer">${killer}</span> <span style="margin:0 5px;">${icon}</span> <span class="victim">${victim}</span>`;
            elKillFeed.prepend(item); // Add to top
            setTimeout(() => {
                item.style.opacity = '0';
                setTimeout(() => item.remove(), 300);
            }, 4000);
        }

        // Tab Scoreboard Functions
        function showTabScoreboard() {
            const scoreboard = document.getElementById('tab-scoreboard');
            const playersContainer = document.getElementById('tab-scoreboard-players');

            if (!scoreboard || !playersContainer) return;

            // Clear previous content
            playersContainer.innerHTML = '';

            // Get players from roomPlayersState
            const players = roomPlayersState ? Object.values(roomPlayersState) : [];

            if (players.length === 0) {
                playersContainer.innerHTML = '<div style="color: #888; text-align: center;">플레이어 없음</div>';
            } else {
                // Sort by kills (descending)
                players.sort((a, b) => (b.kills || 0) - (a.kills || 0));

                players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'scoreboard-player';
                    if (player.id === myId) {
                        playerDiv.classList.add('you');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'scoreboard-player-name';
                    nameSpan.textContent = player.name + (player.id === myId ? ' (나)' : '');

                    const killsSpan = document.createElement('span');
                    killsSpan.className = 'scoreboard-player-kills';
                    killsSpan.textContent = `${player.kills || 0} 킬`;

                    playerDiv.appendChild(nameSpan);
                    playerDiv.appendChild(killsSpan);
                    playersContainer.appendChild(playerDiv);
                });
            }

            scoreboard.style.display = 'flex';
        }

        function hideTabScoreboard() {
            const scoreboard = document.getElementById('tab-scoreboard');
            if (scoreboard) {
                scoreboard.style.display = 'none';
            }
        }

        function updateTimerUI(seconds) {
            // Update HUD Timer
            if (elTimer) {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeStr = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                elTimer.innerText = timeStr;
            }
            // Keep updating old elPlayTime if it exists (for compatibility)
            const elPlayTime = document.getElementById('play-time');
            if (elPlayTime) {
                // ... legacy logic ...
            }
        }



        function updateTimerUI(seconds) {
            // Update HUD Timer
            if (elTimer) {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timeStr = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                elTimer.innerText = timeStr;
            }
        }


        function updatePlayersList() {
            const players = roomPlayersState ? Object.values(roomPlayersState) : [];
            const count = players.length;

            // 1. Update lobby badge (the 0/0 icon)
            const elPlayerCount = document.getElementById('player-count');
            if (elPlayerCount) {
                elPlayerCount.innerText = `${count}/${maxPlayers}`;
            }

            // 2. Update lobby list area
            const playersListEl = document.getElementById('players-list');
            if (playersListEl) {
                playersListEl.innerHTML = '';
                players.forEach(p => {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'player-item';
                    playerItem.textContent = p.name;
                    playersListEl.appendChild(playerItem);
                });
                playersListEl.innerHTML += `<div style="margin-top: 10px; color: rgba(255,255,255,0.7);">참여 인원: ${count} / ${maxPlayers}</div>`;
            }

            // 3. Update in-game overlay list (top-right scoreboard)
            const igContent = document.getElementById('ingame-players-content');
            if (igContent) {
                igContent.innerHTML = '';
                players.forEach(p => {
                    const div = document.createElement('div');
                    div.style.padding = '2px 0';
                    div.style.fontSize = '14px';
                    div.innerHTML = `<span style="color: #4CAF50;">●</span> ${p.name} ${p.id === myId ? '(You)' : ''}`;
                    igContent.appendChild(div);
                });
            }
        }

        function simulatePlayerJoin() {
            // 더 이상 사용하지 않음
        }


        // OLD DUPLICATE startCountdown - REMOVED (was shadowing the correct one at line 2470)
        // function startCountdown() { ... }

        // OLD DUPLICATE startGame - REMOVED (was shadowing the correct one at line 2493)
        // function startGame() { ... }


        function resetAmmo() {
            WEAPONS.forEach(w => w.ammo = w.maxAmmo);
            // If already initialized, update UI
            if (typeof updateUI === 'function') updateUI();
        }

        // Duplicate restartGame function removed (Consolidated at line 4093)

        // 모바일 터치 컨트롤 변수
        // 더 확실한 모바일 감지: User Agent + 터치 지원 + 화면 크기

        let touchMoveActive = false;
        let touchLookActive = false;
        let touchMoveId = null;
        let touchLookId = null;
        let lastTouchX = 0, lastTouchY = 0;
        let touchStartX = 0, touchStartY = 0;
        let isAimingHeld = false;

        function setupControls() {
            if (window.isControlsSetup) return;
            window.isControlsSetup = true;
            // Re-detect or confirm if we should use desktop controls
            // Priority: If it has a mouse (fine pointer), use desktop controls regardless of touch
            const hasFinePointer = window.matchMedia && window.matchMedia('(pointer: fine)').matches;
            const isActuallyMobile = isMobile && !hasFinePointer;

            usePointerLock = !isActuallyMobile;

            if (!usePointerLock) {
                setupMobileControls();
                console.log('Mobile controls enabled');
                // 모바일에서는 포인터 락 사용 안 함
            } else {
                console.log('Desktop controls enabled');
                // 데스크톱에서만 포인터 락 사용
                // (이벤트 리스너는 initGame에서 통합 관리됨)

                document.body.addEventListener('mousedown', (e) => {
                    // EDITOR MODE: Handle placing/deleting objects
                    if (isEditorActive) {
                        e.preventDefault();
                        const raycaster = new THREE.Raycaster();
                        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const intersects = raycaster.intersectObjects(mapGroup.children, true);

                        if (e.button === 0) { // Left click: Place object
                            if (intersects.length > 0) {
                                const hitPoint = intersects[0].point;
                                placeEditorObject(hitPoint);
                            }
                        } else if (e.button === 2) { // Right click: Delete object
                            if (intersects.length > 0) {
                                const hitMesh = intersects[0].object;
                                deleteEditorObject(hitMesh);
                            }
                        }
                        return;
                    }

                    // Normal game mode
                    if (document.pointerLockElement !== document.body && !isDead && !isPaused) {
                        const promise = document.body.requestPointerLock();
                        if (promise) promise.catch(err => { });
                        return;
                    }
                    if (isDead || isPaused) return;
                    if (e.button === 0) isFiring = true;
                    if (e.button === 2) {
                        isAiming = true;
                        // [FIX] Sync Right Click Zoom with Mouse Wheel Logic (Show Scope UI)
                        if (WEAPONS[currentWeaponIdx].name.includes("SNIPER")) {
                            const scope = document.getElementById('sniper-scope');
                            if (scope) scope.style.display = 'block';
                        }
                    }
                });

                document.body.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { isFiring = false; hasFiredSemi = false; hasClickedEmpty = false; }
                    if (e.button === 2) {
                        isAiming = false;
                        // [FIX] Hide Scope UI on release
                        const scope = document.getElementById('sniper-scope');
                        if (scope) scope.style.display = 'none';
                    }
                });
                document.body.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body && !isDead && !isPaused) {
                        const sens = isAiming ? SENSITIVITY_ADS : SENSITIVITY_MOUSE;
                        rotation.y -= e.movementX * sens;
                        rotation.x -= e.movementY * sens;
                        rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                        const ray = new THREE.Raycaster();
                        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const targets = scene.children.filter(c => c !== weaponContainer);
                        const hits = ray.intersectObjects(targets, true);

                        let enemyFound = false;
                        for (let h of hits) {
                            let p = h.object;
                            while (p) {
                                if (p.userData && p.userData.hp !== undefined) {
                                    enemyFound = true;
                                    break;
                                }
                                if (p.parent === scene) break;
                                p = p.parent;
                            }
                            if (enemyFound) break;
                        }

                        if (enemyFound) elCrosshair.classList.add('enemy-detected');
                        else elCrosshair.classList.remove('enemy-detected');
                    }
                });
            }

            window.addEventListener('keydown', e => {
                // [FIX] Block Ctrl+W browser shortcut (closes tab) to allow crouch+forward
                if (e.ctrlKey && (e.key === 'w' || e.key === 'W')) {
                    e.preventDefault();
                }

                // Toggle current weapon debug panel with '[' key
                if (e.code === 'BracketLeft') {
                    const w = WEAPONS[curWeaponIdx];
                    let panelId = '';
                    if (w.type === 'RIFLE') panelId = 'rifle-debug-panel';
                    else if (w.type === 'PISTOL') panelId = 'pistol-debug-panel';
                    else if (w.type === 'SNIPER') panelId = 'sniper-debug-panel';
                    else if (w.type === 'KNIFE') panelId = 'knife-debug-panel';

                    if (panelId) {
                        const p = document.getElementById(panelId);
                        if (p) {
                            const isVisible = p.style.display === 'block';

                            // Hide all panels first
                            const allPanels = ['rifle-debug-panel', 'pistol-debug-panel', 'sniper-debug-panel', 'knife-debug-panel'];
                            allPanels.forEach(id => {
                                const el = document.getElementById(id);
                                if (el) el.style.display = 'none';
                            });

                            // Toggle only the current one
                            p.style.display = isVisible ? 'none' : 'block';
                        }
                    }
                }

                // ESC 키 처리 - key와 code 모두 체크
                if (e.key === 'Escape' || e.key === 'Esc' || e.code === 'Escape') {
                    e.preventDefault();
                    if (isDead) return;

                    if (!isPaused) {
                        // 이미 실행 중이면 포인터 락 해제 -> pointerlockchange 리스너가 일시정지 처리
                        if (document.pointerLockElement === document.body) {
                            document.exitPointerLock();
                        } else {
                            // 포인터 락이 없는 상태(모바일 등)에서의 강제 일시정지 처리
                            isPaused = true;
                            document.body.classList.add('paused');
                            const overlay = document.getElementById('pause-overlay');
                            if (overlay) overlay.style.display = 'flex';
                        }
                    } else {
                        // 일시정지 상태면 재개
                        isPaused = false;
                        document.body.classList.remove('paused');
                        const overlay = document.getElementById('pause-overlay');
                        if (overlay) overlay.style.display = 'none';
                        if (document.body.requestPointerLock) {
                            document.body.requestPointerLock();
                        }
                    }
                    return false;
                }
                const k = e.key.toLowerCase();

                // EDITOR MODE: Handle R key for rotation
                if (isEditorActive && k === 'r') {
                    if (editorGhostMesh) {
                        editorGhostMesh.rotation.y += Math.PI / 4; // Rotate 45 degrees
                        console.log(`Rotated ghost mesh to ${(editorGhostMesh.rotation.y * 180 / Math.PI).toFixed(1)}°`);
                    }
                    return;
                }

                if (isDead || isPaused) return;
                if (k === 'w') keys.w = 1;
                if (k === 's') keys.s = 1;
                if (k === 'a') keys.a = 1;
                if (k === 'd') keys.d = 1;
                if (k === 'shift') keys.shift = true;
                if (k === 'control') keys.ctrl = true;
                if (k === ' ') {
                    // Check if grounded or velocity is nearly zero (standing on surface)
                    // Allow jump if grounded OR if falling/rising velocity is very small (just landed)
                    if (!keys.space && (isGrounded || Math.abs(velocityY) < 0.5)) {
                        velocityY = 12.0; // Adjusted jump force
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }
                if (k === '1') switchWeaponTo(0);
                if (k === '2') switchWeaponTo(1);
                if (k === '3') switchWeaponTo(2);
                if (k === '4') switchWeaponTo(3);
                if (k === '5') switchWeaponTo(4);
                if (k === 'tab') {
                    e.preventDefault();
                    // Show Tab Scoreboard (only in multiplayer)
                    if (gameMode === 'multi') {
                        showTabScoreboard();
                    }
                }
                if (k === 'r') doReload();

                // Enter key: Focus chat input (multiplayer only)
                if (k === 'enter' && gameMode === 'multi') {
                    const chatInput = document.getElementById('chat-input');
                    const chatContainer = document.getElementById('chat-container');
                    if (chatInput && chatContainer && chatContainer.style.display !== 'none') {
                        e.preventDefault();
                        chatInput.focus();
                    }
                }
            });

            // EDITOR MODE: Mouse wheel to cycle object types
            window.addEventListener('wheel', (e) => {
                if (isEditorActive) {
                    e.preventDefault();
                    if (e.deltaY > 0) {
                        editorSelectedIndex = (editorSelectedIndex + 1) % editorObjectTypes.length;
                    } else {
                        editorSelectedIndex = (editorSelectedIndex - 1 + editorObjectTypes.length) % editorObjectTypes.length;
                    }
                    editorCurrentObjectType = editorObjectTypes[editorSelectedIndex];
                    updateEditorGhostMesh();
                    showEditorHint();
                }
            }, { passive: false });

            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if (k === 'w') keys.w = 0;
                if (k === 's') keys.s = 0;
                if (k === 'a') keys.a = 0;
                if (k === 'd') keys.d = 0;
                if (k === 'shift') keys.shift = false;
                if (k === 'control') keys.ctrl = false;
                if (k === ' ') keys.space = false;
                // Hide Tab Scoreboard on release
                if (k === 'tab') {
                    hideTabScoreboard();
                }
            });
        }

        // 모바일 터치 컨트롤 설정
        function setupMobileControls() {
            console.log('Setting up mobile controls');

            const screenWidth = window.innerWidth;
            const leftHalf = screenWidth / 2;

            // --- Mobile Controls Refactor (Joystick & Full Screen Look) ---

            // Joystick Variables
            const joystickZone = document.getElementById('joystick-zone');
            const joystickHandle = document.getElementById('joystick-handle');
            let joystickTouchId = null;
            const joystickMaxRadius = 35; // Handle movement range
            const joystickCenter = { x: 0, y: 0 };

            // Weapon Selector Variables
            const weaponSelectBtns = document.querySelectorAll('.weapon-select-btn');

            // 1. Joystick Logic
            if (joystickZone && joystickHandle) {
                joystickZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const touch = e.changedTouches[0];
                    joystickTouchId = touch.identifier;

                    // Center is relative to the zone
                    const rect = joystickZone.getBoundingClientRect();
                    joystickCenter.x = rect.left + rect.width / 2;
                    joystickCenter.y = rect.top + rect.height / 2;

                    updateJoystick(touch.clientX, touch.clientY);
                }, { passive: false });

                joystickZone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                    if (touch) {
                        updateJoystick(touch.clientX, touch.clientY);
                    }
                }, { passive: false });

                const endJoystick = (e) => {
                    e.preventDefault();
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                    if (touch) {
                        joystickTouchId = null;
                        joystickHandle.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
                        keys.w = 0; keys.s = 0; keys.a = 0; keys.d = 0;
                    }
                };
                joystickZone.addEventListener('touchend', endJoystick);
                joystickZone.addEventListener('touchcancel', endJoystick);
            }

            function updateJoystick(clientX, clientY) {
                const dx = clientX - joystickCenter.x;
                const dy = clientY - joystickCenter.y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), joystickMaxRadius);
                const angle = Math.atan2(dy, dx);

                const moveX = distance * Math.cos(angle);
                const moveY = distance * Math.sin(angle);

                joystickHandle.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;

                // Map to keys (normalized 0-1)
                const normX = moveX / joystickMaxRadius;
                const normY = moveY / joystickMaxRadius; // Up is negative in screen coords

                // Reset keys
                keys.w = 0; keys.s = 0; keys.a = 0; keys.d = 0;

                // Threshold for movement
                if (Math.abs(normY) > 0.1) {
                    if (normY < 0) keys.w = Math.abs(normY);
                    else keys.s = Math.abs(normY);
                }
                if (Math.abs(normX) > 0.1) {
                    if (normX < 0) keys.a = Math.abs(normX);
                    else keys.d = Math.abs(normX);
                }
            }

            // 2. Camera Look Logic (Full Screen Drag)
            let touchLookId = null;
            let lastTouchX = 0;
            let lastTouchY = 0;

            document.body.addEventListener('touchstart', (e) => {
                const target = e.target;
                // Allow camera rotation while shooting/aiming (exclude only joystick, weapon selector, light toggle, jump, reload)
                if (target.closest('#joystick-zone') ||
                    target.closest('.weapon-select-btn') ||
                    target.closest('#light-toggle-btn') ||
                    target.closest('#btn-jump') ||
                    target.closest('#btn-reload')) {
                    return;
                }

                e.preventDefault();
                const touch = e.changedTouches[0];
                touchLookId = touch.identifier;
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }, { passive: false });

            document.body.addEventListener('touchmove', (e) => {
                if (touchLookId === null) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchLookId);
                if (!touch) return;

                const target = e.target;
                // Allow camera rotation while shooting/aiming (exclude only joystick, weapon selector, and light toggle)
                if (target.closest('#joystick-zone') ||
                    target.closest('.weapon-select-btn') ||
                    target.closest('#light-toggle-btn') ||
                    target.closest('#btn-jump') ||
                    target.closest('#btn-reload')) {
                    return;
                }

                const moveDx = touch.clientX - lastTouchX;
                const moveDy = touch.clientY - lastTouchY;

                // Sensitivity
                // Sensitivity - User requested 3-4x increase
                const sens = (isAiming ? SENSITIVITY_ADS * 5.0 : SENSITIVITY_MOUSE * 4.0);
                rotation.y -= moveDx * sens;
                rotation.x -= moveDy * sens;
                rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }, { passive: false });

            document.body.addEventListener('touchend', (e) => {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchLookId);
                if (touch) {
                    touchLookId = null;
                }
            });

            // 3. Weapon Selector Logic
            weaponSelectBtns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.idx);
                    switchWeaponTo(idx);

                    // Update Active State
                    weaponSelectBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                }, { passive: false });
            });

            // 모바일 버튼 이벤트
            const btnJump = document.getElementById('btn-jump');
            const btnReload = document.getElementById('btn-reload');
            // btnCycle 제거
            const btnShoot = document.getElementById('btn-shoot');
            const btnAim = document.getElementById('btn-aim');

            if (btnJump) {
                btnJump.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Allow jump if grounded OR if velocity is nearly zero (standing on surface)
                    if (!keys.space && (isGrounded || Math.abs(velocityY) < 0.5)) {
                        velocityY = 12.0;
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }, { passive: false });
                btnJump.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    keys.space = false;
                }, { passive: false });
            }

            if (btnReload) {
                btnReload.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    doReload();
                }, { passive: false });
            }

            // btnCycle logic removed

            btnShoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // e.stopPropagation() 제거 - 격발하면서 카메라 회전 가능하도록
                isFiring = true;
                // Fix: Shoot button not working for semi-auto (Sniper)
                // Reset semi-auto flag on new touch to allow firing
                hasFiredSemi = false;
            }, { passive: false });
            btnShoot.addEventListener('touchend', (e) => {
                e.preventDefault();
                // e.stopPropagation() 제거
                isFiring = false;
            }, { passive: false });

            // 조준 버튼 - 저격 모드는 조준만, 소총은 조준+발사, 권총은 발사만
            if (btnAim) {
                btnAim.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // e.stopPropagation() 제거 - 조준하면서 카메라 회전 가능하도록
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // 권총: 조준 버튼 누르면 조준 모드 + 연속 격발 (User Request)
                        isAimingHeld = true;
                        isAiming = true;
                        isFiring = true;
                    } else if (w.type === 'SNIPER') {
                        // 저격총 (User Request): 눈 버튼 누르면 조준 (발사 준비)
                        isAimingHeld = true;
                        isAiming = true;
                        isFiring = false;
                    } else {
                        // 소총: 조준 모드 활성화 + 발사
                        isAimingHeld = true;
                        isAiming = true;
                        isFiring = true;
                    }
                }, { passive: false });

                btnAim.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // 권총: 조준 및 발사 모두 해제
                        isAimingHeld = false;
                        isAiming = false;
                        isFiring = false;
                        hasFiredSemi = false;
                    } else if (w.type === 'SNIPER') {
                        // 저격총 (User Request): 눈 버튼 떼면 발사 + 조준 해제
                        if (isAiming) {
                            // Fix: Rapid fire issue - Check cooldown
                            if (fireCooldown <= 0) {
                                shoot(w);
                                fireCooldown = w.fireRate; // Apply cooldown
                                hasFiredSemi = true;
                            }
                        }
                        isAimingHeld = false;
                        isAiming = false;
                        isFiring = false;
                    } else {
                        // 소총: 조준 모드도 해제
                        isAimingHeld = false;
                        isAiming = false;
                        isFiring = false;
                        hasFiredSemi = false;
                    }
                }, { passive: false });
            }
        }

        // PC 마우스 감도 설정
        function setupSensitivityControl() {
            // Check if elements exist (Mobile hides them?)
            // Actually, we want this available if elements are present.
            const sensitivityControl = document.getElementById('sensitivity-control');
            const sensitivitySlider = document.getElementById('sensitivity-slider');
            const sensitivityValue = document.getElementById('sensitivity-value');
            const volumeControl = document.getElementById('volume-control');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeValue = document.getElementById('volume-value');

            if (!sensitivityControl || !sensitivitySlider || !sensitivityValue) return;

            // Force visibility
            sensitivityControl.style.display = 'flex';
            if (volumeControl && volumeSlider && volumeValue) {
                volumeControl.style.display = 'flex';
            }

            // 현재 감도로 슬라이더 설정
            sensitivitySlider.value = SENSITIVITY_MOUSE;
            updateSensitivityDisplay();

            if (volumeSlider && volumeValue) {
                const savedVolume = localStorage.getItem('masterVolume');
                const initialVolume = savedVolume ? parseFloat(savedVolume) : SoundGen.masterVolume;
                const clampedVolume = isNaN(initialVolume) ? SoundGen.masterVolume : Math.max(0, Math.min(1, initialVolume));
                SoundGen.masterVolume = clampedVolume;
                volumeSlider.value = clampedVolume;
                updateVolumeDisplay();
                volumeSlider.addEventListener('input', (e) => {
                    const newVolume = Math.max(0, Math.min(1, parseFloat(e.target.value)));
                    SoundGen.masterVolume = isNaN(newVolume) ? SoundGen.masterVolume : newVolume;
                    localStorage.setItem('masterVolume', SoundGen.masterVolume.toString());
                    updateVolumeDisplay();
                });
            }

            // 슬라이더 변경 이벤트
            sensitivitySlider.addEventListener('input', (e) => {
                const newSensitivity = parseFloat(e.target.value);
                SENSITIVITY_MOUSE = newSensitivity;
                SENSITIVITY_ADS = newSensitivity * 0.25;
                localStorage.setItem('mouseSensitivity', newSensitivity.toString());
                updateSensitivityDisplay();
            });

            // Prevent clicks on slider/control from resuming the game
            sensitivityControl.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            sensitivitySlider.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            if (volumeControl) {
                volumeControl.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            if (volumeSlider) {
                volumeSlider.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            function updateSensitivityDisplay() {
                const displayValue = (SENSITIVITY_MOUSE / 0.002).toFixed(2);
                sensitivityValue.textContent = displayValue;
            }

            function updateVolumeDisplay() {
                if (!volumeValue) return;
                const percent = Math.round(SoundGen.masterVolume * 100);
                volumeValue.textContent = percent + '%';
            }
        }


        function switchWeaponTo(idx) {
            if (curWeaponIdx === idx) return;
            weaponLoadToken++; // Increment global token on every switch
            isReloading = false;
            const w = WEAPONS[idx];

            isAiming = false;
            curWeaponIdx = idx;
            buildWeapon(curWeaponIdx);

            // 무기 전환 시 초기 위치 설정
            if (w.type !== 'KNIFE') {
                weaponModel.position.set(0, -0.5, 0);
                weaponModel.rotation.set(0, 0, 0);
            } else {
                // CS Style: Lower right, pointing forward
                weaponModel.position.set(0.35, -0.15, -0.3); // [MOD] Higher and Closer
                weaponModel.rotation.set(0, 0, 0);
            }

            // Play Switch Sound
            if (w.switchSound && SoundGen.audioBuffers[w.switchSound]) {
                SoundGen.playAudioFile(w.switchSound, 0.8);
            } else {
                SoundGen.playSwitch();
            }

            // Update Weapon Selector UI (Bottom Right) - DEPRECATED / HIDDEN
            // document.querySelectorAll('.weapon-slot').forEach(slot => slot.classList.remove('active'));
            // const activeSlot = document.querySelector(`.weapon-slot[data-slot="${idx}"]`);
            // if (activeSlot) activeSlot.classList.add('active');

            // Update New Left Weapon List
            document.querySelectorAll('.weapon-item').forEach(item => item.classList.remove('active'));
            const activeItem = document.getElementById(`weapon-item-${idx}`);
            if (activeItem) activeItem.classList.add('active');

            updateUI();

            // [FIX] Apply shadows after weapon switch
            weaponContainer.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                }
            });

            // [Multiplayer] Sync Weapon Switch
            if (typeof gameMode !== 'undefined' && gameMode === 'multi' && typeof socket !== 'undefined' && socket && socket.connected) {
                socket.emit('playerAction', { action: 'switch', weaponIdx: idx });
            }
        }

        function updateUI() {
            if (!elWeaponName || !elAmmoCurrent) return;

            const w = WEAPONS[curWeaponIdx];
            elWeaponName.innerText = w.name;

            if (w.type === 'KNIFE') {
                elAmmoCurrent.innerText = "-";
                elAmmoReserve.innerText = "";
            } else if (w.type === 'GRENADE') {
                elAmmoCurrent.innerText = w.ammo;
                elAmmoReserve.innerText = "";
            } else {
                elAmmoCurrent.innerText = w.ammo;
                elAmmoReserve.innerText = "/ " + w.maxAmmo;
            }

            // Reload Warning
            if (w.ammo <= w.maxAmmo * 0.3 && w.type !== 'KNIFE') {
                elAmmoCurrent.style.color = '#ff003c'; // Red
            } else {
                elAmmoCurrent.style.color = 'white';
            }
        }

        function damagePlayer(amount) {
            if (isDead) return;
            const oldHP = playerHP;
            playerHP -= amount;
            playerHP = Math.max(0, playerHP);

            // 1. Update Main Bar
            if (elHpBar) elHpBar.style.width = playerHP + '%';
            if (elHpText) elHpText.innerText = Math.floor(playerHP);

            // 2. Ghost Bar Logic
            if (elHpGhost) {
                // Ghost bar stays at old width momentarily
                elHpGhost.style.width = oldHP + '%';
                elHpGhost.style.transition = 'none'; // Reset transition

                // Then shrinks
                setTimeout(() => {
                    elHpGhost.style.transition = 'width 0.5s ease-out';
                    elHpGhost.style.width = playerHP + '%';
                }, 300);
            }

            // 3. Color State (Critical)
            const vitalsPanel = document.querySelector('.vitals-panel');
            if (vitalsPanel) {
                if (playerHP <= 30) vitalsPanel.classList.add('critical');
                else vitalsPanel.classList.remove('critical');
            }

            // 4. Damage Vignette
            if (elDamage) {
                elDamage.style.opacity = 1;
                setTimeout(() => elDamage.style.opacity = 0, 300);
            }

            SoundGen.playDamage();

            if (playerHP <= 0) {
                isDead = true;
                if (gameMode === 'single') {
                    const gameOverTitle = document.getElementById('game-over-title');
                    if (gameOverTitle) gameOverTitle.innerText = 'YOU DIED';
                    const gameOverKills = document.getElementById('final-kill-count');
                    if (gameOverKills) gameOverKills.innerText = killCount;
                    if (elGameOver) elGameOver.style.display = 'flex';
                }
                if (!isMobile && document.pointerLockElement === document.body) {
                    document.exitPointerLock();
                }
            }
        }

        // [FIX] Add missing killEnemy function
        function killEnemy(e) {
            e.userData.isDead = true;
            createBlood(e.position);

            // Death Animation (Simple Fall)
            e.rotation.x = -Math.PI / 2;
            e.position.y = 0.2;

            // Remove after delay
            setTimeout(() => {
                scene.remove(e);
                const idx = enemies.indexOf(e);
                if (idx > -1) enemies.splice(idx, 1);
            }, 3000);

            // Drop Item (Health Pill)
            if (Math.random() < 0.3) {
                createHealthPill(e.position.clone());
            }

            // Update Kill Count
            killCount++;
            if (elKillCount) elKillCount.innerText = "Kills: " + killCount;

            // Add Kill Feed (Local)
            addKillFeed("You", "Zombie", false);
        }

        function doReload() {
            const w = WEAPONS[curWeaponIdx];
            if (w.type === 'KNIFE' || w.type === 'GRENADE' || isReloading) return;
            isReloading = true;

            const reloadOverlay = document.getElementById('reload-overlay');
            if (reloadOverlay) {
                reloadOverlay.style.display = 'flex';
                reloadOverlay.style.opacity = '1';
                setTimeout(() => {
                    reloadOverlay.style.opacity = '0';
                    reloadOverlay.style.display = 'none';
                }, 600);
            }

            if (w.type === 'SNIPER' && SoundGen.audioBuffers['c-rifle']) {
                SoundGen.playAudioFile('c-rifle', 0.8);
            } else {
                SoundGen.playReload();
            }

            if (elWeaponName) elWeaponName.innerText = "RELOADING...";

            // Find magazine mesh
            let mag = null;
            if (weaponModel) {
                weaponModel.traverse(child => {
                    if (child.name === "magazine") mag = child;
                });
            }

            const initialMagPos = mag ? mag.position.clone() : null;

            // --- RELOAD SEQUENCE ---
            // Stage 1: Tilt Up & Drop Mag (0ms)
            if (weaponModel) {
                // [User Request] Smaller motion (Reduced from 0.5 and -0.1)
                weaponModel.rotation.z = 0.15;
                weaponModel.position.y = -0.02;
                if (mag) {
                    // Start drop animation (will be handled by lerp in future or simple offset here)
                    mag.position.y -= 0.2;
                    mag.visible = true;
                }
            }

            // Stage 2: Hide dropped mag (400ms)
            setTimeout(() => {
                if (mag) mag.visible = false;
            }, 400);

            // Stage 3: New mag appears from bottom (600ms)
            setTimeout(() => {
                if (mag) {
                    mag.position.y = initialMagPos.y - 0.4;
                    mag.visible = true;
                    // Move up to initial position
                    const animateUp = () => {
                        const step = 0.05;
                        if (mag.position.y < initialMagPos.y) {
                            mag.position.y += step;
                            requestAnimationFrame(animateUp);
                        } else {
                            mag.position.y = initialMagPos.y;
                        }
                    };
                    animateUp();
                }
            }, 600);

            // Stage 4: Reset weapon pose (900ms)
            setTimeout(() => {
                if (weaponModel) {
                    weaponModel.rotation.z = 0;
                    weaponModel.position.y = 0;
                }
            }, 900);

            // Stage 5: Finish reload (1000ms)
            setTimeout(() => {
                w.ammo = w.maxAmmo;
                isReloading = false;
                if (mag && initialMagPos) mag.position.copy(initialMagPos);
                updateUI();
            }, 1000);
        }

        function createDecal(pos, normal) {
            if (!normal) return;
            createImpactSmoke(pos, normal.clone());
            const size = 0.1 + Math.random() * 0.05;
            const geo = new THREE.PlaneGeometry(size, size);
            const decal = new THREE.Mesh(geo, matDecal);
            decal.position.copy(pos);
            decal.lookAt(pos.clone().add(normal));
            decal.position.add(normal.multiplyScalar(0.01));
            scene.add(decal);
            decals.push(decal);
            if (decals.length > 50) {
                const old = decals.shift();
                scene.remove(old);
            }
        }

        function createSparks(pos, dir) {
            const count = 6;
            const geo = new THREE.BoxGeometry(0.01, 0.01, 0.04);

            for (let i = 0; i < count; i++) {
                const spark = new THREE.Mesh(geo, matSpark);
                spark.position.copy(pos);

                const spread = 0.8;
                const velocity = dir.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread
                )).normalize().multiplyScalar(2.5 + Math.random() * 2.0);

                spark.lookAt(spark.position.clone().add(velocity));
                scene.add(spark);

                sparkParticles.push({
                    mesh: spark,
                    velocity: velocity,
                    life: 0.06 + Math.random() * 0.06
                });
            }
        }

        function updateSparks(dt) {
            for (let i = sparkParticles.length - 1; i >= 0; i--) {
                const s = sparkParticles[i];
                s.life -= dt;
                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    sparkParticles.splice(i, 1);
                    continue;
                }
                s.mesh.position.addScaledVector(s.velocity, dt);
            }
        }

        function createImpactSmoke(pos, normal) {
            const geo = new THREE.DodecahedronGeometry(0.15, 0);
            const smoke = new THREE.Mesh(geo, matSmoke.clone());
            smoke.position.copy(pos).add(normal.multiplyScalar(0.1));
            smoke.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            scene.add(smoke);

            smokeParticles.push({
                mesh: smoke,
                life: 0.4,
                maxLife: 0.4,
                scaleSpeed: 1.5
            });
        }

        function updateSmoke(dt) {
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const s = smokeParticles[i];
                s.life -= dt;

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    smokeParticles.splice(i, 1);
                    continue;
                }

                const progress = 1 - (s.life / s.maxLife);
                const scale = 1 + progress * s.scaleSpeed;
                s.mesh.scale.set(scale, scale, scale);
                s.mesh.material.opacity = 0.4 * (1 - progress);
                s.mesh.position.y += 0.2 * dt;
            }
        }

        function spawnShell() {
            if (!shellGeo || !shellMat) return; // Safety check

            const shell = new THREE.Mesh(shellGeo, shellMat);

            // Start at weapon position
            const weaponPos = new THREE.Vector3();
            weaponModel.getWorldPosition(weaponPos);
            const weaponQuat = new THREE.Quaternion();
            weaponModel.getWorldQuaternion(weaponQuat);
            const cameraQuat = new THREE.Quaternion();
            camera.getWorldQuaternion(cameraQuat);

            shell.position.copy(weaponPos);
            shell.quaternion.copy(weaponQuat);

            // Offset to ejection port (Camera-right side)
            // Local offset: Right (+x), Up (+y)
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(cameraQuat);
            forward.y = 0;
            forward.normalize();
            // crossVectors(up, forward)로 올바른 오른쪽 방향 계산
            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            shell.position.addScaledVector(right, 0.08);
            shell.position.addScaledVector(up, 0.05);

            // Random rotation for realism
            shell.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

            // Velocity: 플레이어 시점에서 항상 오른쪽으로 보이도록 playerVelocity 추가
            // 탄피가 플레이어와 함께 이동하면서 오른쪽으로 배출되는 효과
            const worldVel = new THREE.Vector3();
            worldVel.addScaledVector(right, 1.8 + Math.random() * 0.4);
            worldVel.addScaledVector(up, 0.8 + Math.random() * 0.4);
            const horizontalVel = playerVelocity.clone();
            horizontalVel.y = 0;
            worldVel.add(horizontalVel); // 플레이어 속도 추가로 상대적 위치 유지

            if (debugShellVelocity) {
                console.log('[ShellDebug] playerVelocity', playerVelocity.clone(), 'worldVel', worldVel.clone());
            }


            scene.add(shell);

            shells.push({
                mesh: shell,
                velocity: worldVel,
                rotVel: new THREE.Vector3(Math.random() * 10, Math.random() * 10, Math.random() * 10),
                life: 1.5 // Short life
            });
        }

        function updateShells(dt) {
            for (let i = shells.length - 1; i >= 0; i--) {
                const s = shells[i];
                s.life -= dt;

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    shells.splice(i, 1);
                    continue;
                }

                s.velocity.y -= 9.8 * dt;
                s.mesh.position.addScaledVector(s.velocity, dt);
                s.velocity.multiplyScalar(0.8);

                s.mesh.rotation.x += s.rotVel.x * dt;
                s.mesh.rotation.y += s.rotVel.y * dt;
                s.mesh.rotation.z += s.rotVel.z * dt;

                if (s.mesh.position.y < 0.01) {
                    s.mesh.position.y = 0.01;
                    s.velocity.y *= -0.5;
                    s.velocity.x *= 0.7;
                    s.velocity.z *= 0.7;
                }
            }
        }

        // --- Blood Particle System ---
        function createBlood(pos) {
            const particleCount = 8;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 2);
                velocities.push(vel);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xaa0000, size: 0.05 }));
            scene.add(particles);

            bloodParticles.push({ mesh: particles, velocities: velocities, life: 0.5 });
        }

        function updateParticles(dt) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const bp = bloodParticles[i];
                bp.life -= dt;
                if (bp.life <= 0) {
                    scene.remove(bp.mesh);
                    bloodParticles.splice(i, 1);
                    continue;
                }

                const positions = bp.mesh.geometry.attributes.position.array;
                for (let j = 0; j < bp.velocities.length; j++) {
                    positions[j * 3] += bp.velocities[j].x * dt;
                    positions[j * 3 + 1] += bp.velocities[j].y * dt;
                    positions[j * 3 + 2] += bp.velocities[j].z * dt;
                }
                bp.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createHealthPill(pos) {
            const pillGroup = new THREE.Group();
            // 알약 크기 확대
            const pillBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.15, 8), matHealthPill);
            pillBody.rotation.x = Math.PI / 2;
            pillGroup.add(pillBody);

            // 빛나는 효과를 위한 PointLight 추가
            const pillLight = new THREE.PointLight(0xff00ff, 1.5, 2);
            pillLight.position.set(0, 0, 0);
            pillGroup.add(pillLight);

            pillGroup.position.copy(pos);
            pillGroup.position.y = 0.8;
            pillGroup.userData.isHealthPill = true;
            pillGroup.userData.pillLight = pillLight;
            pillGroup.userData.baseY = 0.8; // 원래 Y 위치 저장
            pillGroup.userData.floatTime = 0; // 부동 애니메이션용 시간
            pillGroup.userData.lifeTime = 0; // 알약 수명 (30초 후 삭제)
            scene.add(pillGroup);
            healthPills.push(pillGroup);
        }

        function getPlayerPickupPosition() {
            if (!position) return null;
            const eyeHeight = keys.ctrl ? 1.0 : 1.7;
            return new THREE.Vector3(position.x, position.y - eyeHeight, position.z);
        }

        function updateHealthPills(dt) {
            for (let i = healthPills.length - 1; i >= 0; i--) {
                const pill = healthPills[i];

                // 수명 증가
                pill.userData.lifeTime += dt;

                // 30초 지나면 삭제
                if (pill.userData.lifeTime >= 30.0) {
                    scene.remove(pill);
                    healthPills.splice(i, 1);
                    continue;
                }

                // 회전 애니메이션
                pill.rotation.y += dt * 2;

                // 부동 애니메이션 (원래 위치 기준으로 부유)
                pill.userData.floatTime += dt;
                pill.position.y = pill.userData.baseY + Math.sin(pill.userData.floatTime * 3) * 0.1;

                if (isDead || (isSpectating && gameMode === 'multi')) continue;

                const playerPos = getPlayerPickupPosition();
                if (!playerPos) continue;

                // 플레이어와의 거리 체크 (3D 거리)
                const dist = pill.position.distanceTo(playerPos);
                if (dist < 1.2) {
                    // HP가 이미 100이면 먹지 않음
                    if (playerHP >= 100) continue;

                    // HP 회복
                    const oldHP = playerHP;
                    playerHP = Math.min(100, playerHP + 20);

                    if (playerHP !== oldHP) { // 실제로 회복된 경우에만
                        elHpBar.style.width = playerHP + '%';
                        if (elHpText) elHpText.innerText = Math.floor(playerHP);
                        if (playerHP > 50) elHpBar.style.background = "#4caf50";
                        else if (playerHP > 20) elHpBar.style.background = "#ff9800";
                        else elHpBar.style.background = "#f44336";

                        // 효과음 재생
                        SoundGen.playHealthPill();
                    }

                    scene.remove(pill);
                    healthPills.splice(i, 1);
                }
            }
        }


        // --- Grenade Drops System ---
        let grenadeDrops = [];

        function createGrenadeDrop(pos) {
            const dropGroup = new THREE.Group();

            // Visual: Small Box representing crate or distinct item
            const dropGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const dropMat = new THREE.MeshStandardMaterial({
                color: 0xffff00, // Yellow
                emissive: 0xaa8800,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const dropBody = new THREE.Mesh(dropGeo, dropMat);
            dropGroup.add(dropBody);

            // Light
            const dropLight = new THREE.PointLight(0xffff00, 1.0, 3);
            dropGroup.add(dropLight);

            dropGroup.position.copy(pos);
            dropGroup.position.y = 0.5;
            dropGroup.userData.baseY = 0.5;
            dropGroup.userData.floatTime = 0;
            dropGroup.userData.lifeTime = 0;
            scene.add(dropGroup);
            grenadeDrops.push(dropGroup);
        }

        function updateGrenadeDrops(dt) {
            for (let i = grenadeDrops.length - 1; i >= 0; i--) {
                const drop = grenadeDrops[i];
                drop.userData.lifeTime += dt;

                // 30s lifetime
                if (drop.userData.lifeTime >= 30.0) {
                    scene.remove(drop);
                    grenadeDrops.splice(i, 1);
                    continue;
                }

                // Animation
                drop.rotation.y += dt;
                drop.userData.floatTime += dt;
                drop.position.y = drop.userData.baseY + Math.sin(drop.userData.floatTime * 2) * 0.1;

                // Pickup
                if (isDead || (isSpectating && gameMode === 'multi')) continue;
                const playerPos = getPlayerPickupPosition();
                if (!playerPos) continue;
                const dist = drop.position.distanceTo(playerPos);
                if (dist < 1.5) {
                    if (drop.userData.claimed) continue;

                    // Find Grenade Weapon
                    const gWeapon = WEAPONS.find(w => w.type === 'GRENADE');
                    console.log('[Grenade Pickup] Distance:', dist.toFixed(2), 'Ammo:', gWeapon?.ammo, '/', gWeapon?.maxAmmo);

                    if (gWeapon) {
                        if (!Number.isFinite(gWeapon.ammo)) gWeapon.ammo = 0;
                        if (!Number.isFinite(gWeapon.maxAmmo)) gWeapon.maxAmmo = 0;
                    }

                    if (gWeapon && gWeapon.ammo < gWeapon.maxAmmo) {
                        // Only pick up if not at max
                        drop.userData.claimed = true;

                        gWeapon.ammo++;
                        SoundGen.playSwitch();

                        if (typeof updateUI === 'function') updateUI();

                        scene.remove(drop);
                        grenadeDrops.splice(i, 1);
                        console.log('[Grenade Pickup] SUCCESS! New ammo:', gWeapon.ammo);
                    } else {
                        console.log('[Grenade Pickup] FAILED - Weapon:', !!gWeapon, 'Ammo Full:', gWeapon && gWeapon.ammo >= gWeapon.maxAmmo);
                    }
                }
            }
        }

        let fireTimer = 0;
        function handleShooting(dt) {
            if (isDead) return;
            const w = WEAPONS[curWeaponIdx];

            if (fireCooldown > 0) fireCooldown -= dt;

            if (knifeSwing > 0) {
                knifeSwing -= dt * 4.5; // 약간 느리게 (더 자연스럽게)
                if (knifeSwing < 0) knifeSwing = 0;
            }

            if (isFiring && !isReloading) {
                if (w.type === 'KNIFE' || w.ammo > 0) {
                    if (fireCooldown <= 0) {
                        // 모바일에서 권총은 자동 발사 허용 (사용자 요청: 조준 유지 시 연속 격발)
                        const isMobilePistol = isMobile && w.type === 'PISTOL';

                        if (w.automatic || isMobilePistol) {
                            fireCooldown = w.fireRate;
                            shoot(w);
                        } else {
                            if (!hasFiredSemi) {
                                fireCooldown = w.fireRate;
                                shoot(w);
                                hasFiredSemi = true;
                            }
                        }
                    }
                } else if (w.ammo <= 0 && w.type !== 'KNIFE') {
                    // 매번 빈 격발 소리 재생 (hasClickedEmpty 체크 제거)
                    if (fireCooldown <= 0) {
                        SoundGen.playDryFire();
                        elAmmoCurrent.classList.add('no-ammo');
                        setTimeout(() => elAmmoCurrent.classList.remove('no-ammo'), 200);
                        fireCooldown = 0.2; // 빈 격발도 쿨다운 적용
                    }
                }
            }
        }

        function isHitPart(obj, partName) {
            let current = obj;
            const searchName = partName.toLowerCase();

            // Define keywords for more robust "limb" detection
            const limbKeywords = ['arm', 'leg', 'hand', 'foot', 'limb', 'finger', 'toe'];

            while (current) {
                const lowName = (current.name || "").toLowerCase();

                // 1. Direct name match
                if (lowName.includes(searchName)) return true;

                // 2. Head specific (Robust)
                if (partName === 'head' && (current.userData?.isHead || lowName.includes('head'))) return true;

                // 3. Limb specific (Robust with keywords)
                if (partName === 'limb') {
                    if (current.userData?.isLimb) return true;
                    // Check if any keyword matches
                    if (limbKeywords.some(kw => lowName.includes(kw))) {
                        // Avoid false positives (spine, body, torso should not be limbs)
                        // [FIX] Continue searching parent instead of returning false immediately
                        if (!(lowName.includes('spine') || lowName.includes('body') || lowName.includes('torso'))) {
                            return true;
                        }
                    }
                }

                current = current.parent;
            }
            return false;
        }

        function shoot(w) {
            // 멀티플레이어에서 다른 플레이어에게 발사 알림
            if (gameMode === 'multi' && socket && socket.connected) {
                socket.emit('playerAction', {
                    action: 'shoot',
                    weaponIdx: curWeaponIdx
                });
            }

            if (w.type === 'GRENADE') {
                if (w.ammo > 0) {
                    w.ammo--;
                    updateUI();

                    // Play Throw Sound Immediately
                    SoundGen.playGrenadeThrow();

                    // Throw Physics
                    const throwDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
                    // Add some upward arc
                    throwDir.y += 0.2;
                    throwDir.normalize();

                    const vel = throwDir.multiplyScalar(15.0); // Throw speed

                    const gMesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), matGrenade);
                    gMesh.position.copy(camera.position).add(new THREE.Vector3(0, -0.2, 0)); // Start from slightly below camera
                    gMesh.castShadow = true;
                    scene.add(gMesh);

                    grenades.push({
                        mesh: gMesh,
                        vel: vel,
                        fuse: 3.0, // 3 seconds
                        radius: 0.15
                    });

                    // Hand animation (hide momentarily)
                    weaponModel.visible = false;
                    setTimeout(() => { if (curWeaponIdx === 4) weaponModel.visible = true; }, 500);
                }
                return; // Stop here, no raycast for grenades
            }


            if (w.type !== 'KNIFE') {
                w.ammo--;
                updateUI();
                // [User Request] Revert base kick to 0.3 for stable camera, but boost weapon model recoil separately
                const kick = isAiming ? w.recoil * 0.35 : w.recoil;

                let rotScale = 1.2;
                let posScale = 16;

                // [User Request] Rifle Recoil: Differentiated by Aim State
                if (w.type === 'RIFLE') {
                    if (isAiming) {
                        rotScale = 9.5;   // Strong pitch kick
                        posScale = 420;   // Strong backward kick
                    } else {
                        rotScale = 2.6;   // Idle: stronger kick
                        posScale = 30;    // Idle: stronger kick
                    }
                }

                const rotImpulse = kick * rotScale;
                const posImpulse = kick * posScale;
                recoilVel.x += rotImpulse;
                recoilVel.z += posImpulse;

                const yawImpulse = (Math.random() - 0.5) * kick * 7;
                cameraRecoilVel.x += kick * 4;
                cameraRecoilVel.y += yawImpulse;



                // Subtle Screen Flash
                const flashEl = document.getElementById('shoot-flash');
                if (flashEl) {
                    flashEl.style.opacity = '0.08'; // Very subtle flash
                    setTimeout(() => flashEl.style.opacity = '0', 50);
                }

                if (muzzleFlash) {
                    muzzleFlash.visible = true;

                    // [User Request] Move flash to screen center during Rifle ADS
                    if (w.type === 'RIFLE') {
                        if (isAiming) {
                            // Align with crosshair (Screen Center)
                            muzzleFlash.position.set(0.015, 0.062, muzzleFlash.position.z);
                        } else {
                            // [User Request] Move Flash to Center Crosshair in Hip-fire
                            // Manual offset to align with camera center (-0.06->-0.02 Right)
                            muzzleFlash.position.set(-0.02, 0.10, -2.0);
                        }
                    }

                    // Bright, brief flash
                    // [User Request] 2x Size (Increased from 0.28)
                    let s = 0.6 + Math.random() * 0.2;
                    if (w.type === 'SNIPER') s *= 2.0; // Scale up to 2x for sniper
                    muzzleFlash.scale.set(s, s, 1);
                    muzzleFlash.rotation.z = Math.random() * Math.PI * 2;

                    if (muzzleFlash.material) {
                        muzzleFlash.material.opacity = 0.35;
                    }

                    setTimeout(() => {
                        if (muzzleFlash.material) {
                            muzzleFlash.material.opacity = 0;
                        }
                        muzzleFlash.visible = false;
                    }, 30);
                }


                if (w.type === 'SNIPER') {
                    // PC 모드에서만 재장전 제스처 추가
                    if (!isMobile) {
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            sniperReloadGesture = true;
                            // 재장전 제스처: bolt를 당기고 다시 밀어넣기
                            const originalRotZ = weaponModel.rotation.z;
                            const originalPosZ = weaponModel.position.z;
                            const originalPosY = weaponModel.position.y;

                            // bolt를 뒤로 당기기
                            weaponModel.rotation.z = originalRotZ + 0.4;
                            weaponModel.position.z = originalPosZ - 0.08;
                            weaponModel.position.y = originalPosY - 0.04;
                            setTimeout(() => {
                                // bolt를 앞으로 밀어넣기
                                weaponModel.rotation.z = originalRotZ + 0.15;
                                setTimeout(() => {
                                    // 원래 위치로 복귀
                                    weaponModel.rotation.z = originalRotZ;
                                    weaponModel.position.z = originalPosZ;
                                    weaponModel.position.y = originalPosY;
                                    sniperReloadGesture = false;
                                }, 150);
                            }, 250);
                        }, 600);
                    } else {
                        // 모바일에서는 기존 로직 유지
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            weaponModel.rotation.z = 0.2;
                            setTimeout(() => weaponModel.rotation.z = 0, 200);
                        }, 600);
                    }
                }

                // FIXED: REMOVED THE BUGGY EMISSIVE FLASH CODE HERE

                // spawnShell(); // 탄피 효과 비활성화
                if (w.type === 'RIFLE') {
                    playRifleShot();
                } else {
                    SoundGen.playShoot(w.type);
                }
            } else {
                window.knifeSwing = window.KNIFE_SWING_DURATION;
                SoundGen.playKnife();
            }




            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (!isAiming && w.type !== 'KNIFE') {
                ray.ray.direction.x += (Math.random() - 0.5) * 0.05;
                ray.ray.direction.y += (Math.random() - 0.5) * 0.05;
            }
            const range = (w.type === 'KNIFE') ? 2.0 : 100; // Reduced from 3.0 to 2.0 per user request

            const targets = scene.children.filter(obj => obj !== weaponContainer);
            const hits = ray.intersectObjects(targets, true);

            for (let h of hits) {
                if (h.distance > range) continue;

                let isEnemy = false;
                let isOtherPlayer = false;
                let p = h.object;

                // Fix: Find parent with userData.hp
                while (p) {
                    if (p.userData && p.userData.hp !== undefined) {
                        // 다른 플레이어인지 확인 (playerId가 있으면 다른 플레이어)
                        if (gameMode === 'multi' && p.userData.playerId !== undefined) {
                            isOtherPlayer = true;
                        } else {
                            isEnemy = true;
                        }
                        break;
                    }
                    if (p.parent === scene || !p.parent) break;
                    p = p.parent;
                }

                if (!isEnemy && !isOtherPlayer) {
                    // 맵 구조물(mapGroup)인지 확인
                    let isMap = false;
                    let curr = h.object;
                    while (curr) {
                        if (curr === mapGroup) { isMap = true; break; }
                        if (curr.parent === scene || !curr.parent) break;
                        curr = curr.parent;
                    }

                    if (isMap) {
                        if (w.type !== 'KNIFE' && h.object.geometry && h.face) {
                            createDecal(h.point, h.face.normal);
                        }
                        break; // 맵에 맞으면 탄흔 생성하고 총알 멈춤
                    }

                    // 맵도 아니고 적도 아니면(탄피, 이펙트 등) 통과
                    continue;
                }

                // 다른 플레이어에게 데미지
                if (isOtherPlayer && p.userData.hp > 0) {
                    let dmg = w.damage;
                    let isHead = isHitPart(h.object, 'head');

                    // [Fallback] Geometric Headshot Detection
                    // If the mesh naming fails (GLB issue), check if the hit is high enough relative to player base.
                    // [IMPORTANT] Remote player p.position.y is EYE LEVEL (~1.7), while body base is y - 0.8
                    if (!isHead && p.position && h.object.type !== 'Sprite') {
                        const playerFeetY = p.position.y - 0.8; // Approximate base based on createRemotePlayer logic
                        const hitHeight = h.point.y - playerFeetY;

                        // Height 1.3 - 1.8 from FEET is head area
                        if (hitHeight > 1.35 && hitHeight < 1.85) {
                            isHead = true;
                            console.log('[Shoot] Geometric Headshot (Remote)! Height from feet:', hitHeight.toFixed(2));
                        }
                    }

                    // [NEW] Ignore hits on Sprites (like name tags) or anything too high relative to feet
                    if (h.object.type === 'Sprite' || (h.point.y - (p.position.y - 0.8) > 1.95)) {
                        continue;
                    }

                    console.log(`[Shoot] Hit Player: ${p.userData.playerName}. Damage: ${dmg} x ${isHead ? '3 (Head)' : (isHitPart(h.object, 'limb') ? '0.7 (Limb)' : '1 (Body)')}`);
                    if (isHead) {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (isHitPart(h.object, 'limb')) {
                        dmg *= 0.7;
                    }


                    // 서버에 데미지 이벤트 전송
                    if (socket && socket.connected) {
                        socket.emit('damagePlayer', {
                            targetId: p.userData.playerId,
                            damage: dmg,
                            isHeadshot: isHead
                        });
                    }

                    // 히트마커 등은 로컬에서 즉시 표시
                    elHitMarker.style.opacity = 1;
                    setTimeout(() => elHitMarker.style.opacity = 0, 100);
                    SoundGen.playHit();
                    createBlood(h.point);
                    break;
                }

                if (isEnemy && p.userData.hp > 0) {
                    // 강한 히트마커 효과
                    elHitMarker.style.opacity = 1;
                    elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1.5)";
                    elHitMarker.style.filter = "brightness(1.5) drop-shadow(0 0 8px red)";
                    setTimeout(() => {
                        elHitMarker.style.opacity = 0;
                        elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1)";
                        elHitMarker.style.filter = "brightness(1) drop-shadow(0 0 4px red)";
                    }, 150);

                    // 피격 사운드 효과
                    SoundGen.playHit();

                    createBlood(h.point);

                    let dmg = w.damage;
                    let isHead = isHitPart(h.object, 'head');

                    // [Fallback] Geometric for Enemies
                    if (!isHead && p.position && h.object.type !== 'Sprite') {
                        const hitHeight = h.point.y - p.position.y;
                        if (hitHeight > 1.45 && hitHeight < 1.85) {
                            isHead = true;
                        }
                    }

                    // Ignore Sprite hits
                    if (h.object.type === 'Sprite' || (h.point.y - p.position.y > 1.9)) {
                        continue;
                    }

                    if (isHead) {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (isHitPart(h.object, 'limb')) {
                        dmg *= 0.7;
                    }

                    // Flash Red - 더 강하게
                    p.children.forEach(c => {
                        if (c.isMesh && c.material && c.material.emissive) {
                            c.material.emissive.setHex(0xff0000);
                            c.material.emissiveIntensity = 1.5; // 더 밝게
                        }
                    });
                    p.userData.flashTimer = 0.15; // 더 오래 지속

                    p.userData.hp -= dmg;
                    const hpPercent = Math.max(0, p.userData.hp / p.userData.maxHp);
                    p.userData.hpBar.scale.x = hpPercent;

                    if (p.userData.hp <= 0) {
                        p.userData.isDead = true;
                        const enemyPos = p.position.clone();
                        scene.remove(p);
                        const index = enemies.indexOf(p);
                        if (index > -1) enemies.splice(index, 1);

                        // Kill 카운트 증가
                        killCount++;
                        if (elKillCount) {
                            elKillCount.innerText = `Kills: ${killCount}`;
                        }

                        // 30% 확률로 HP 회복 알약 드랍
                        if (Math.random() < 0.3) {
                            createHealthPill(enemyPos);
                        } else if (Math.random() < 0.2) { // 20% Chance for Grenade (if no pill)
                            createGrenadeDrop(enemyPos);
                        }

                        // setTimeout 제거 - spawnTimer 시스템이 처리함
                    }
                    break;
                }

                // 관통 (break 제거)
            }
        }

        function checkCollision(newPos) {
            // Player height: 1.7 (eye), collider should go from 0 (feet) to 1.8 (head)
            // relative to position (eye level)
            const playerMin = new THREE.Vector3(newPos.x - PLAYER_RADIUS, newPos.y - 1.7, newPos.z - PLAYER_RADIUS);
            const playerMax = new THREE.Vector3(newPos.x + PLAYER_RADIUS, newPos.y + 0.3, newPos.z + PLAYER_RADIUS);
            const playerBox = new THREE.Box3(playerMin, playerMax);

            // Spatial Grid Optimization
            const nearby = spatialGrid.query(playerBox);
            for (const collider of nearby) {
                if (playerBox.intersectsBox(collider)) return true;
            }
            return false;
        }


        // Duplicate checkLowHealth removed (consolidated at bottom of file)

        function onResize() {
            // Safety check: Ensure camera and renderer exist before resizing
            if (!camera || !renderer) return;

            // 모바일 가로 모드에서 실제 화면 크기 계산
            let width, height;

            if (window.visualViewport) {
                // visualViewport API 사용 (모바일 브라우저 주소창 제외)
                width = window.visualViewport.width;
                height = window.visualViewport.height;
            } else {
                // 폴백: window 크기 사용
                width = window.innerWidth;
                height = window.innerHeight;
            }

            // 모바일 가로 모드에서 최소 높이 보장
            if (isMobile && window.innerHeight < window.innerWidth) {
                // 가로 모드
                height = Math.max(height, window.screen.height || window.innerHeight);
            }

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            // 후처리 효과 리사이즈
            if (postProcessingCanvas) {
                postProcessingCanvas.width = width;
                postProcessingCanvas.height = height;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // 플레이 시간 업데이트 (싱글플레이어 전용)
            // 멀티플레이어 매치 타이머는 timerSync 소켓 이벤트가 담당함
            if (!isDead && !isPaused && gameStartTime > 0 && gameMode === 'single') {
                singlePlayerTimeLeft = Math.max(0, singlePlayerTimeLeft - dt);
                updateTimerUI(Math.ceil(singlePlayerTimeLeft));
                if (singlePlayerTimeLeft <= 0) {
                    isGameStarted = false;
                    isDead = true;
                    const gameOverTitle = document.getElementById('game-over-title');
                    if (gameOverTitle) gameOverTitle.innerText = 'TIME OVER';
                }
            }

            // --- Dynamic Crosshair Update ---
            // Calculate current spread based on state
            let targetSpread = 0; // Base offset from center (default gap)
            const BASE_GAP = 5;

            // 1. Movement Spread (Walking)
            if (keys.w || keys.a || keys.s || keys.d) {
                targetSpread += 5; // +5px when moving
            }

            // 2. Jumping Spread (In Air)
            // Assuming 'playerVelocity.y' or height check. 
            // Simplified check: if jump button pressed or in air (needs 'canJump' variable context)
            if (!canJump) { // Start with jump button/state if available, fall back to logic
                targetSpread += 15; // +15px when jumping/falling
            }

            // 3. Crouching/Walking (Ctrl/Shift) - Tighten
            if (keys.ctrl || keys.shift) {
                targetSpread -= 2; // Tighten by 2px (e.g., precise aim)
            }

            // Apply Spread to DOM
            // Get elements (cache these if optimization needed, but benign for now)
            const hairTop = document.querySelector('.crosshair .hair.top');
            const hairBottom = document.querySelector('.crosshair .hair.bottom');
            const hairLeft = document.querySelector('.crosshair .hair.left');
            const hairRight = document.querySelector('.crosshair .hair.right');

            if (hairTop && hairBottom && hairLeft && hairRight) {
                const finalGap = BASE_GAP + targetSpread;
                // Use transform for smooth performance (hardware accelerated)
                // Top: Move Up (negative Y)
                hairTop.style.transform = `translate(-50%, -${finalGap}px)`;
                // Bottom: Move Down (positive Y)
                hairBottom.style.transform = `translate(-50%, ${finalGap}px)`;
                // Left: Move Left (negative X)
                hairLeft.style.transform = `translate(-${finalGap}px, -50%)`;
                // Right: Move Right (positive X)
                hairRight.style.transform = `translate(${finalGap}px, -50%)`;
            }
            const gameOverKills = document.getElementById('final-kill-count');
            if (gameOverKills) gameOverKills.innerText = killCount;
            if (elGameOver) elGameOver.style.display = 'flex';
            const exitBtn = document.getElementById('exit-game-btn');
            if (exitBtn) exitBtn.style.display = 'none';
            if (!isMobile && document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
        }





        // Spectator Camera (Killcam) - 3rd Person Follow Camera
        if (isSpectating && spectatingPlayerId && gameMode === 'multi') {
            // Hide 1st person weapon model during 3rd person killcam
            if (weaponContainer) weaponContainer.visible = false;

            const killerMesh = otherPlayersMap[spectatingPlayerId];
            if (killerMesh) {
                // Get killer's rotation (Y-axis = horizontal facing direction)
                const killerRotY = killerMesh.rotation.y || 0;

                // Camera offset: 5m behind, 3m above the killer
                const offsetDistance = 5;
                const offsetHeight = 3;

                // Calculate camera position behind the killer
                const camX = killerMesh.position.x - Math.sin(killerRotY) * offsetDistance;
                const camY = killerMesh.position.y + offsetHeight;
                const camZ = killerMesh.position.z - Math.cos(killerRotY) * offsetDistance;

                // Smoothly interpolate camera position for smoother following
                camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.1);

                // Make camera look at the killer
                camera.lookAt(
                    killerMesh.position.x,
                    killerMesh.position.y + 1.0, // Look at chest/head level
                    killerMesh.position.z
                );
            }
            // Skip normal player control during spectating
        } else {
            // Not spectating - ensure weapon is visible (if alive)
            if (weaponContainer && !isDead) weaponContainer.visible = true;
        }


        if (!isDead && !isPaused) {
            const w = WEAPONS[curWeaponIdx];
            if (isGameStarted) {
                handleShooting(dt);
                // Redundant checkLowHealth call removed (handled at end of loop)

                // --- Improved Physics with Raycasting (Fix for Jumping on Objects) ---
                const eyeHeight = keys.ctrl ? 1.0 : 1.7; // 1.7 is standard eye level

                // Raycast down to find "ground"
                let groundY = 0.5; // Base floor level

                // Only cast ray if mapGroup exists
                if (mapGroup) {
                    const rayOrigin = position.clone();
                    rayOrigin.y += 0.5; // Start slightly above current foot position to detect very close ground
                    const downRay = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 10);
                    // Intersect with map objects (collidable)
                    // Note: We need to traverse mapGroup to find meshes, or use a known list.
                    // mapGroup.children contains meshes.
                    const intersects = downRay.intersectObjects(mapGroup.children, true);

                    if (intersects.length > 0) {
                        // Find highest valid intersection below player
                        let bestGroundY = groundY;
                        for (const hit of intersects) {
                            if (!hit.face) continue;
                            const worldNormal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
                            if (worldNormal.y > 0.3) {
                                bestGroundY = Math.max(bestGroundY, hit.point.y);
                            }
                        }
                        groundY = bestGroundY;
                    }
                }

                const targetY = groundY + eyeHeight;
                playerVelocity.copy(position).sub(lastPlayerPosition).multiplyScalar(1 / dt);

                // Apply Gravity
                velocityY -= 30.0 * dt; // Stronger gravity for snappier feel
                let nextY = position.y + velocityY * dt;

                // Ground Collision / Landing
                // We allow a small tolerance to "snap" to ground
                const groundTolerance = 0.15; // Allow small height difference for grounded state

                if (velocityY < 0 && nextY <= targetY) {
                    // Landed
                    position.y = targetY;
                    velocityY = 0;
                    isGrounded = true;
                } else if (Math.abs(position.y - targetY) < groundTolerance && velocityY <= 0) {
                    // Very close to ground (within tolerance) - still considered grounded
                    // This helps with walking on uneven surfaces or objects
                    position.y = targetY;
                    velocityY = 0;
                    isGrounded = true;
                } else {
                    position.y = nextY;
                    // Only set isGrounded to false if we're actually above ground by more than tolerance
                    if (position.y > targetY + groundTolerance) {
                        isGrounded = false;
                    }
                }

                // Landing Sound Trigger
                if (isGrounded && !lastGroundedState && velocityY <= 0) {
                    SoundGen.playLand();
                }
                lastGroundedState = isGrounded;

                let speed = 15.0; // Default: RUN (User Request - Increased from 9.0)
                if (keys.shift) speed = 4.0; // Shift: SLOW WALK (increased from 2.0)

                // Weapon-based movement speed multipliers
                if (w.type === 'KNIFE') speed *= 1.1;
                else if (w.type === 'PISTOL') speed *= 1.05;
                else if (w.type === 'SNIPER') speed *= 0.9;
                else if (w.type === 'GRENADE') speed *= 0.95;

                // Overrides (Crouch & Aim take priority)
                if (keys.ctrl) speed = 3.0; // [User Request] Slow movement when Crouched
                if (isAiming) speed = 2.0;

                const q = new THREE.Quaternion();
                q.setFromEuler(new THREE.Euler(rotation.x, rotation.y, 0, 'YXZ'));
                camera.quaternion.copy(q);

                const dx = keys.d - keys.a; const dy = keys.s - keys.w;
                if (dx !== 0 || dy !== 0) {
                    const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const moveDir = fwd.multiplyScalar(-dy).add(rgt.multiplyScalar(dx)).normalize();
                    const moveStep = moveDir.clone().multiplyScalar(speed * dt);

                    const stepHeight = 0.6; // 등반 가능한 최대 높이 (계단 등)

                    // X축 이동 및 Step Climbing
                    let nextPosX = position.clone();
                    nextPosX.x += moveStep.x;
                    if (!checkCollision(nextPosX)) {
                        position.x = nextPosX.x;
                    } else {
                        // 장애물 발견 시 위쪽 공간 체크
                        let stepUpPos = nextPosX.clone();
                        stepUpPos.y += stepHeight;
                        if (!checkCollision(stepUpPos)) {
                            position.x = nextPosX.x;
                            position.y += 0.1; // 살짝 들어올려줌 (부드러운 등반)
                        }
                    }

                    // Z축 이동 및 Step Climbing
                    let nextPosZ = position.clone();
                    nextPosZ.z += moveStep.z;
                    if (!checkCollision(nextPosZ)) {
                        position.z = nextPosZ.z;
                    } else {
                        // 장애물 발견 시 위쪽 공간 체크
                        let stepUpPos = nextPosZ.clone();
                        stepUpPos.y += stepHeight;
                        if (!checkCollision(stepUpPos)) {
                            position.z = nextPosZ.z;
                            position.y += 0.1; // 살짝 들어올려줌
                        }
                    }

                    if (!isAiming) {
                        if (isGrounded && !keys.shift && !keys.ctrl) {
                            SoundGen.playStep();
                        }

                        if (keys.shift || keys.ctrl) {
                            // [User Request] Remove bobbing while sneaking or crouching
                            swayOffset.x = 0;
                            swayOffset.y = 0;
                        } else {
                            const bobFreq = 8;
                            const bobAmp = 0.02;
                            swayOffset.y = Math.sin(time * 0.001 * bobFreq) * bobAmp;
                            swayOffset.x = Math.cos(time * 0.001 * (bobFreq / 2)) * bobAmp;
                        }
                    } else {
                        // [FIX] Smoothly reset sway when aiming while moving (fixes pistol crosshair wobble)
                        swayOffset.x = THREE.MathUtils.lerp(swayOffset.x, 0, 15 * dt);
                        swayOffset.y = THREE.MathUtils.lerp(swayOffset.y, 0, 15 * dt);
                    }
                } else {
                    playerVelocity.set(0, 0, 0);
                    // [User Request] Idle sway animation when standing still (all weapons)
                    // Stop sway when aiming
                    if (!isAiming) {
                        const swayFreqX = 1.2; const swayFreqY = 0.9;
                        const swayAmpX = 0.015; const swayAmpY = 0.012;
                        swayOffset.x = Math.sin(time * 0.001 * swayFreqX) * swayAmpX;
                        swayOffset.y = Math.sin(time * 0.001 * swayFreqY) * swayAmpY;
                    } else {
                        // Reset sway smoothly when aiming
                        swayOffset.x = THREE.MathUtils.lerp(swayOffset.x, 0, 10 * dt);
                        swayOffset.y = THREE.MathUtils.lerp(swayOffset.y, 0, 10 * dt);
                    }
                }

                lastPlayerPosition.copy(position);
            }


            // --- Visual Updates (Runs even during countdown) ---
            const isSniperAiming = isAiming && w.type === 'SNIPER';


            if (isSniperAiming) {

                weaponContainer.visible = false;
                elScope.style.display = 'block';
                if (isMobile) {
                    elCrosshair.style.display = 'block';
                } else {
                    elCrosshair.style.display = 'none';
                }

                // PC vs Mobile Scope Style Logic
                // PC/Mobile Common Scope Style (User Request: Mobile should look like PC)
                elScope.style.background = 'radial-gradient(circle, transparent 20%, rgba(0, 0, 0, 0.7) 21%, rgba(0, 0, 0, 0.9) 100%)';
            } else {
                weaponContainer.visible = true;
                elScope.style.display = 'none';

                // Sniper Scope - Show circular scope only for SNIPER when aiming
                const sniperScope = document.getElementById('sniper-scope');
                if (sniperScope) {
                    if (isAiming && w.type === 'SNIPER' && !isMobile) {
                        sniperScope.style.display = 'block';
                    } else {
                        sniperScope.style.display = 'none';
                    }
                }

                // Crosshair Logic
                if (isMobile) {
                    // 모바일: 항상 조준선 표시 (사용자 요청)
                    elCrosshair.style.display = 'block';
                    elCrosshair.style.opacity = 0.7; // 상시 표시는 약간 투명하게
                } else if (w.type === 'PISTOL' || (!isAiming && w.type !== 'KNIFE')) {
                    // PC: 권총이거나 비조준 상태(칼 제외)일 때 표시
                    // Mobile PISTOL update: Aiming hidden crosshair logic same as PC now?
                    // Actually, if mobile pistol behaves like rifle now (ADS available), hide crosshair when aiming
                    if (isMobile && w.type === 'PISTOL' && isAiming) {
                        elCrosshair.style.display = 'none';
                    } else {
                        elCrosshair.style.display = 'block';
                        elCrosshair.style.opacity = 1;
                    }
                } else {
                    elCrosshair.style.display = 'none';
                }
            }

            // Hide/Show front sight based on aiming
            if (weaponModel) {
                weaponModel.traverse((child) => {
                    if (child.userData && child.userData.isSight) {
                        // 모바일에서 권총 강제 조준 제거 - 사용자 요청 (평상시에는 들고 있는 모습)
                        const shouldAim = isAiming;
                        child.visible = shouldAim;
                    }
                });
            }

            let targetPos = w.posHip; let targetFov = 70;
            // [User Request] Rotation Interpolation
            let targetRot = w.rotHip || new THREE.Vector3(0, 0, 0);

            if (isAiming) {
                if (w.type === 'SNIPER') targetFov = w.fovAds;
                else if (w.type !== 'KNIFE') {
                    targetPos = w.posAds;
                    targetFov = w.fovAds;
                    targetRot = w.rotAds || new THREE.Vector3(0, 0, 0);
                }
                else targetPos = w.posAds;
            }

            currentPos.lerp(targetPos, 15 * dt);
            currentRot.lerp(targetRot, 15 * dt); // Interpolate rotation

            // [User Request] Dynamic Arm Scaling for all weapons (except Knife/Grenade)
            if (w.type !== 'KNIFE' && w.type !== 'GRENADE') {
                const lArm = weaponModel.getObjectByName('LeftArmGroup');
                const rArm = weaponModel.getObjectByName('RightArmGroup');

                // [MOD] Weapon-specific scaling: Pistol is thinner than others
                let idleScale = 2.5;
                let adsScale = 0.8;

                if (w.type === 'PISTOL') {
                    idleScale = 1.6;
                    adsScale = 0.6;
                }

                const targetArmScale = isAiming ? adsScale : idleScale;
                if (lArm) {
                    let currentTargetScale = new THREE.Vector3(targetArmScale, targetArmScale, targetArmScale);

                    // [MOD] Special compensation for Rifle ADS Reload to hide gaps/separation
                    if (w.type === 'RIFLE' && isAiming && isReloading) {
                        // Make it slightly thicker (X, Z) and longer (Y) - Adjusted down from (1.2, 2.2, 1.2)
                        currentTargetScale.set(0.9, 1.5, 0.9);
                    }

                    const sx = THREE.MathUtils.lerp(lArm.scale.x, currentTargetScale.x, 15 * dt);
                    const sy = THREE.MathUtils.lerp(lArm.scale.y, currentTargetScale.y, 15 * dt);
                    const sz = THREE.MathUtils.lerp(lArm.scale.z, currentTargetScale.z, 15 * dt);
                    lArm.scale.set(sx, sy, sz);
                }
                if (rArm) {
                    const s = THREE.MathUtils.lerp(rArm.scale.x, targetArmScale, 15 * dt);
                    rArm.scale.set(s, s, s);
                }
            }

            if (window.rifleModel && w.type === 'RIFLE' && w.glbHip && w.glbAds) {
                const tPos = isAiming ? w.glbAds.pos : w.glbHip.pos;
                const tRot = isAiming ? w.glbAds.rot : w.glbHip.rot;
                const tScale = isAiming ? w.glbAds.scale : w.glbHip.scale;

                window.rifleModel.position.lerp(tPos, 15 * dt);
                // Manually lerp rotation euler
                window.rifleModel.rotation.x += (tRot.x - window.rifleModel.rotation.x) * 15 * dt;
                window.rifleModel.rotation.y += (tRot.y - window.rifleModel.rotation.y) * 15 * dt;
                window.rifleModel.rotation.z += (tRot.z - window.rifleModel.rotation.z) * 15 * dt;

                window.rifleModel.scale.lerp(tScale, 15 * dt);

                // [User Request] Dynamic Left Arm Lerping for Rifle
                const lArm = weaponModel.getObjectByName('LeftArmGroup');
                if (lArm && w.lArmHip && w.lArmAds) {
                    const aPos = isAiming ? w.lArmAds.pos : w.lArmHip.pos;
                    const aRot = isAiming ? w.lArmAds.rot : w.lArmHip.rot;
                    lArm.position.lerp(aPos, 15 * dt);
                    lArm.rotation.x += (aRot.x - lArm.rotation.x) * 15 * dt;
                    lArm.rotation.y += (aRot.y - lArm.rotation.y) * 15 * dt;
                    lArm.rotation.z += (aRot.z - lArm.rotation.z) * 15 * dt;
                }
            }

            if (window.pistolModel && w.type === 'PISTOL' && w.glbHip && w.glbAds) {
                const tPos = isAiming ? w.glbAds.pos : w.glbHip.pos;
                const tRot = isAiming ? w.glbAds.rot : w.glbHip.rot;
                const tScale = isAiming ? w.glbAds.scale : w.glbHip.scale;

                window.pistolModel.position.lerp(tPos, 15 * dt);
                window.pistolModel.rotation.x += (tRot.x - window.pistolModel.rotation.x) * 15 * dt;
                window.pistolModel.rotation.y += (tRot.y - window.pistolModel.rotation.y) * 15 * dt;
                window.pistolModel.rotation.z += (tRot.z - window.pistolModel.rotation.z) * 15 * dt;
                window.pistolModel.scale.lerp(tScale, 15 * dt);
            }

            // [User Request] ADS-Aware Muzzle Flash Lerping
            if (muzzleFlash && w.muzzleHip && w.muzzleAds) {
                const tMuzzlePos = isAiming ? w.muzzleAds : w.muzzleHip;
                muzzleFlash.position.lerp(tMuzzlePos, 15 * dt);
            }

            if (window.sniperModel && w.type === 'SNIPER' && w.glbHip && w.glbAds) {
                const tPos = isAiming ? w.glbAds.pos : w.glbHip.pos;
                const tRot = isAiming ? w.glbAds.rot : w.glbHip.rot;
                const tScale = isAiming ? w.glbAds.scale : w.glbHip.scale;

                // [DEBUG] Disable interpolation to allow debug panel to work
                // window.sniperModel.position.lerp(tPos, 15 * dt);
                // window.sniperModel.rotation.x += (tRot.x - window.sniperModel.rotation.x) * 15 * dt;
                // window.sniperModel.rotation.y += (tRot.y - window.sniperModel.rotation.y) * 15 * dt;
                // window.sniperModel.rotation.z += (tRot.z - window.sniperModel.rotation.z) * 15 * dt;
                // window.sniperModel.scale.lerp(tScale, 15 * dt);
            }

            camera.fov += (targetFov - camera.fov) * 15 * dt;
            camera.updateProjectionMatrix();

            // 화면 흔들림 효과 적용 (피격 감각)
            if (hitShake.intensity > 0) {
                hitShake.x = (Math.random() - 0.5) * hitShake.intensity;
                hitShake.y = (Math.random() - 0.5) * hitShake.intensity;
                hitShake.intensity *= 0.85; // 점진적으로 감소
                if (hitShake.intensity < 0.01) {
                    hitShake.intensity = 0;
                    hitShake.x = 0;
                    hitShake.y = 0;
                }
            }

            camera.position.copy(position);
            camera.position.x += hitShake.x;
            camera.position.y += hitShake.y;

            // [FIX] weaponContainer가 camera의 자식인지 확인하여 위치 업데이트 방식 결정
            if (weaponContainer.parent === camera) {
                // 카메라의 자식일 경우: 로컬 오프셋만 설정 (카메라를 자동으로 따라감)
                weaponContainer.position.set(
                    currentPos.x + hitShake.x + swayOffset.x,
                    currentPos.y + hitShake.y + swayOffset.y,
                    currentPos.z
                );
                // [User Request] Apply interpolated rotation to weapon container
                weaponContainer.rotation.set(currentRot.x, currentRot.y, currentRot.z);
            } else {
                // scene의 자식일 경우: 월드 좌표 직접 업데이트 (기존 로직)
                weaponContainer.position.copy(position);
                weaponContainer.position.x += hitShake.x;
                weaponContainer.position.y += hitShake.y;
                weaponContainer.quaternion.copy(camera.quaternion);
                weaponContainer.translateX(currentPos.x + swayOffset.x);
                weaponContainer.translateY(currentPos.y + swayOffset.y);
                weaponContainer.translateZ(currentPos.z);
            }

            const recoilAccelX = -RECOIL_SPRING * recoil.x - RECOIL_DAMPING * recoilVel.x;
            recoilVel.x += recoilAccelX * dt;
            recoil.x += recoilVel.x * dt;
            recoil.x = THREE.MathUtils.clamp(recoil.x, -RECOIL_MAX, RECOIL_MAX);

            const recoilAccelZ = -RECOIL_SPRING * recoil.z - RECOIL_DAMPING * recoilVel.z;
            recoilVel.z += recoilAccelZ * dt;
            recoil.z += recoilVel.z * dt;
            recoil.z = THREE.MathUtils.clamp(recoil.z, -RECOIL_POS_MAX, RECOIL_POS_MAX);


            // 나이프일 때만 특별한 위치/회전 처리
            if (w.type === 'KNIFE') {
                // Arms Stability: Reset weaponModel (container) to idle pose
                weaponModel.rotation.set(0, 0, 0);
                weaponModel.position.set(0.35, -0.15, -0.3); // [MOD]

                if (window.knifeSwing > 0) {
                    // [FIX] Independent Right Arm Swing (Left arm stays still)

                    // 1. Reset Internal Parts to Default
                    if (window.knifeModel) {
                        window.knifeModel.position.set(0, -0.2, -0.5);
                        window.knifeModel.rotation.set(0.1, 1.8, -0.2); // [MOD] Updated Idle Rotation
                    }
                    if (window.knifeRightArm) {
                        window.knifeRightArm.position.set(0.12, -0.2, -0.15); // [MOD] Sync with Shorter Handle
                        window.knifeRightArm.rotation.set(0, -0.15, 0.05);
                    }

                    const swingT = 1 - (window.knifeSwing / window.KNIFE_SWING_DURATION);

                    // weaponModel STAYS INITIAL (Fix for Left Arm moving)
                    weaponModel.position.set(0.35, -0.15, -0.3);
                    weaponModel.rotation.set(0, 0, 0);

                    // Variables for Right Arm & Knife LOCAL transforms
                    let ax = 0.12, ay = -0.2, az = -0.15;
                    let arx = 0, ary = -0.15, arz = 0.05;

                    // Variables for LEFT Arm
                    let lx = -1.63, ly = -0.14, lz = -0.11;
                    let lrx = 0.56, lry = -0.56, lrz = -1.98;

                    let kx = 0, ky = -0.2, kz = -0.5;
                    let krx = 0.1, kry = 1.18, krz = -0.1; // [MOD] Start from new idle rotation (approx)

                    // ===== CONFIGURABLE SWING PARAMETERS =====
                    // Adjust these via console: window.KNIFE_SWING_CONFIG
                    if (!window.KNIFE_SWING_CONFIG) {
                        window.KNIFE_SWING_CONFIG = {
                            // Phase 1 End (Wind-up) - Knife position/rotation
                            p1_kx: -0.2, p1_ky: 0.0, p1_kz: -0.35,
                            p1_krx: 1.57, p1_kry: 1.57, p1_krz: 0.0,
                            // Phase 2 End (Slash) - Knife position/rotation
                            p2_kx: 0.4, p2_ky: -0.1, p2_kz: -0.5,
                            p2_krx: 1.5, p2_kry: -0.5, p2_krz: 0.3,
                            // Debug: freeze at specific swingT value (0-1), set to -1 to disable
                            freezeAt: -1
                        };
                        console.log('[Knife Swing] Config loaded. Adjust via window.KNIFE_SWING_CONFIG');
                    }
                    const cfg = window.KNIFE_SWING_CONFIG;

                    // Debug freeze mode
                    if (cfg.freezeAt >= 0 && cfg.freezeAt <= 1) {
                        swingT = cfg.freezeAt;
                    }

                    // New idle values from user's settings
                    const idleX = 0.01, idleY = 0.00, idleZ = -0.29;
                    const idleRX = 2.16, idleRY = -0.06, idleRZ = 2.08;

                    if (swingT < 0.12) {
                        // Phase 1: Wind Up (0% - 12%) - Pull blade to center/left
                        const t = swingT / 0.12;
                        const et = 1 - (1 - t) * (1 - t); // Quad Out

                        // Right Arm wind up - pull toward center
                        ax = THREE.MathUtils.lerp(0.12, 0.0, et);
                        ay = THREE.MathUtils.lerp(-0.2, -0.15, et);
                        az = THREE.MathUtils.lerp(-0.15, -0.35, et); // Extend arm forward
                        arx = THREE.MathUtils.lerp(0, 0.1, et);
                        ary = THREE.MathUtils.lerp(-0.15, 0.3, et);
                        arz = THREE.MathUtils.lerp(0.05, -0.05, et);

                        // Knife wind up - uses config values
                        kx = THREE.MathUtils.lerp(idleX, cfg.p1_kx, et);
                        ky = THREE.MathUtils.lerp(idleY, cfg.p1_ky, et);
                        kz = THREE.MathUtils.lerp(idleZ, cfg.p1_kz, et);
                        krx = THREE.MathUtils.lerp(idleRX, cfg.p1_krx, et);
                        kry = THREE.MathUtils.lerp(idleRY, cfg.p1_kry, et);
                        krz = THREE.MathUtils.lerp(idleRZ, cfg.p1_krz, et);
                    } else if (swingT < 0.45) {
                        // Phase 2: Outward Slash (12% - 45%)
                        const t = (swingT - 0.12) / 0.33;
                        const et = 1 - Math.pow(1 - t, 3); // Cubic Out

                        // Right Arm outward slash - reduced X movement, extended Z
                        ax = THREE.MathUtils.lerp(0.0, 0.25, et);  // Reduced from 0.5 to 0.25
                        ay = THREE.MathUtils.lerp(-0.15, -0.2, et);
                        az = THREE.MathUtils.lerp(-0.35, -0.55, et); // Extended arm forward more
                        arx = THREE.MathUtils.lerp(0.1, -0.05, et);
                        ary = THREE.MathUtils.lerp(0.3, -0.8, et);  // Reduced rotation
                        arz = THREE.MathUtils.lerp(-0.05, 0.15, et);

                        // Left Arm reaction
                        lx = THREE.MathUtils.lerp(-1.63, -1.8, et);
                        lry = THREE.MathUtils.lerp(-0.56, -0.7, et);

                        // Knife slash - uses config values
                        kx = THREE.MathUtils.lerp(cfg.p1_kx, cfg.p2_kx, et);
                        ky = THREE.MathUtils.lerp(cfg.p1_ky, cfg.p2_ky, et);
                        kz = THREE.MathUtils.lerp(cfg.p1_kz, cfg.p2_kz, et);
                        krx = THREE.MathUtils.lerp(cfg.p1_krx, cfg.p2_krx, et);
                        kry = THREE.MathUtils.lerp(cfg.p1_kry, cfg.p2_kry, et);
                        krz = THREE.MathUtils.lerp(cfg.p1_krz, cfg.p2_krz, et);
                    } else {
                        // Phase 3: Recovery (45% - 100%)
                        const t = (swingT - 0.45) / 0.55;
                        const et = t * t; // Quad In

                        // Right Arm recovery - from new values
                        ax = THREE.MathUtils.lerp(0.25, 0.02, et);
                        ay = THREE.MathUtils.lerp(-0.2, 0.02, et);
                        az = THREE.MathUtils.lerp(-0.55, -0.15, et); // Return from extended position
                        arx = THREE.MathUtils.lerp(-0.05, 0, et);
                        ary = THREE.MathUtils.lerp(-0.8, 0.36, et);
                        arz = THREE.MathUtils.lerp(0.15, 0.05, et);

                        // Left Arm recovery
                        lx = THREE.MathUtils.lerp(-1.8, -1.63, et);
                        lry = THREE.MathUtils.lerp(-0.7, -0.56, et);

                        // Knife recovery - from config p2 to idle
                        kx = THREE.MathUtils.lerp(cfg.p2_kx, idleX, et);
                        ky = THREE.MathUtils.lerp(cfg.p2_ky, idleY, et);
                        kz = THREE.MathUtils.lerp(cfg.p2_kz, idleZ, et);
                        krx = THREE.MathUtils.lerp(cfg.p2_krx, idleRX, et);
                        kry = THREE.MathUtils.lerp(cfg.p2_kry, idleRY, et);
                        krz = THREE.MathUtils.lerp(cfg.p2_krz, idleRZ, et);
                    }

                    // Apply to Right Arm
                    const rArm = weaponModel.getObjectByName('RightArmGroup');
                    if (rArm) {
                        rArm.position.set(ax, ay, az);
                        rArm.rotation.set(arx, ary, arz);
                    }
                    // Apply to Left Arm
                    const lArm = weaponModel.getObjectByName('LeftArmGroup');
                    if (lArm) {
                        lArm.position.set(lx, ly, lz);
                        lArm.rotation.set(lrx, lry, lrz);
                    }
                    // Apply to Knife
                    if (window.knifeModel) {
                        window.knifeModel.position.set(kx, ky, kz);
                        window.knifeModel.rotation.set(krx, kry, krz);
                    }

                } else if (window.knifeModel) {
                    // [FIX] Use WEAPONS data instead of hardcoded values for debug panel support
                    const knifeWeapon = WEAPONS.find(weapon => weapon.type === 'KNIFE');
                    if (knifeWeapon && knifeWeapon.glbHip) {
                        window.knifeModel.position.copy(knifeWeapon.glbHip.pos);
                        window.knifeModel.rotation.set(knifeWeapon.glbHip.rot.x, knifeWeapon.glbHip.rot.y, knifeWeapon.glbHip.rot.z);
                        window.knifeModel.scale.copy(knifeWeapon.glbHip.scale);
                    }
                    const rArm = weaponModel.getObjectByName('RightArmGroup');
                    if (rArm && knifeWeapon && knifeWeapon.rArmHip) {
                        rArm.position.copy(knifeWeapon.rArmHip.pos);
                        rArm.rotation.set(knifeWeapon.rArmHip.rot.x, knifeWeapon.rArmHip.rot.y, knifeWeapon.rArmHip.rot.z);
                    }
                    const lArm = weaponModel.getObjectByName('LeftArmGroup');
                    if (lArm && knifeWeapon && knifeWeapon.lArmHip) {
                        lArm.position.copy(knifeWeapon.lArmHip.pos);
                        lArm.rotation.set(knifeWeapon.lArmHip.rot.x, knifeWeapon.lArmHip.rot.y, knifeWeapon.lArmHip.rot.z);
                    }
                }
            } else {

                // 다른 무기들은 원래대로 (recoil만 적용)
                const recoilScale = (isAiming && w.type === 'RIFLE') ? 0.35 : 1;
                weaponModel.position.y = THREE.MathUtils.lerp(weaponModel.position.y, 0, 10 * dt);
                const reloadRot = (isReloading && isAiming && w.type === 'RIFLE') ? 0.1 : (isReloading ? 0.5 : 0);
                weaponModel.rotation.x = recoil.x * recoilScale + reloadRot;
                weaponModel.position.z = recoil.z * recoilScale;
                // 재장전 제스처 중이 아닐 때만 rotation.z 초기화
                if (!sniperReloadGesture) {
                    weaponModel.rotation.z = 0;
                }
            }
            elVignette.style.opacity = (isAiming && w.type !== 'KNIFE') ? 0.5 : 0;

            if (window.knifeSwing > 0) {
                window.knifeSwing = Math.max(window.knifeSwing - dt, 0);
            }


            updateShells(dt);

            updateParticles(dt);
            updateSparks(dt);
            updateSmoke(dt);
            updateGrenades(dt); // Grenade Physics
            if (!isPaused) {
                updateHealthPills(dt);
                updateGrenadeDrops(dt);
            }
            // 모드별 업데이트
            checkLowHealth(); // [FIX] Restore missing Low Health Check

            if (gameMode === 'single') {
                updateEnemies(dt);
            } else if (gameMode === 'multi') {
                // [FIX] Update Remote Players: Name Tag Visibility Only (No LookAt override)
                otherPlayers.forEach(p => {
                    // Calculate distance to local player for name tag visibility
                    const dist = p.position.distanceTo(camera.position);
                    if (p.userData.nameSprite) {
                        // Only show name if within 50 meters
                        p.userData.nameSprite.visible = (dist < 50);
                    }
                });

                // 자신의 상태 서버 전송 (초당 약 30~60회 렌더링마다 전송하면 부하가 생길 수 있으므로 최적화 가능)
                if (socket && socket.connected && !isDead) {
                    socket.emit('playerMove', {
                        position: { x: position.x, y: position.y, z: position.z },
                        rotation: { x: rotation.x, y: rotation.y }
                    });
                }
            }

            // 물리 엔진 업데이트
            if (usePhysics && physicsWorld) {
                updatePhysics(dt);
            }

            if (!isPaused) {
                const camAccelX = -CAM_RECOIL_SPRING * cameraRecoil.x - CAM_RECOIL_DAMPING * cameraRecoilVel.x;
                cameraRecoilVel.x += camAccelX * dt;
                cameraRecoil.x += cameraRecoilVel.x * dt;
                cameraRecoil.x = THREE.MathUtils.clamp(cameraRecoil.x, -CAM_RECOIL_MAX, CAM_RECOIL_MAX);

                const camAccelY = -CAM_RECOIL_SPRING * cameraRecoil.y - CAM_RECOIL_DAMPING * cameraRecoilVel.y;
                cameraRecoilVel.y += camAccelY * dt;
                cameraRecoil.y += cameraRecoilVel.y * dt;
                cameraRecoil.y = THREE.MathUtils.clamp(cameraRecoil.y, -CAM_RECOIL_MAX, CAM_RECOIL_MAX);

                const deltaX = cameraRecoil.x - cameraRecoilApplied.x;
                const deltaY = cameraRecoil.y - cameraRecoilApplied.y;
                // [User Request] Remove vertical camera recoil (no muzzle climb) - recoil stays on weapon only
                // camera.rotation.x += deltaX; // DISABLED: No vertical camera movement
                camera.rotation.y += deltaY;
                cameraRecoilApplied.x = cameraRecoil.x;
                cameraRecoilApplied.y = cameraRecoil.y;

                // Update sun light to follow player for consistent shadows
                if (window.sunLight) {
                    window.sunLight.position.set(position.x + 50, position.y + 120, position.z + 50);
                    window.sunLight.target.position.set(position.x, position.y, position.z);
                    window.sunLight.target.updateMatrixWorld();
                }

                // 렌더링
                renderer.render(scene, camera);
            }  // 후처리 효과 적용 (렌더링 후)
            if (usePostProcessing && postProcessingEnabled) {
                applyPostProcessing();
            }
        }


        function checkLowHealth() {
            const overlay = document.getElementById('low-health-overlay');
            if (!overlay) return;

            // Clear any inline opacity that might block the animation
            if (overlay.style.opacity !== "") overlay.style.opacity = "";

            // Only show if alive and playing
            if (isDead || !isGameStarted || isSpectating) {
                overlay.classList.remove('active');
                return;
            }

            // HP <= 20% -> Show pulsing red overlay
            if (playerHP <= 20 && playerHP > 0) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        // 모바일 주소창 숨기기 - 페이지 로드 후 자동 스크롤
        window.addEventListener('load', function () {
            // iOS Safari와 Android 크롬에서 주소창 숨기기
            setTimeout(function () {
                window.scrollTo(0, 1);
            }, 100);

            // 터치 시작 시에도 스크롤 (주소창 자동 숨김)
            document.body.addEventListener('touchstart', function () {
                window.scrollTo(0, 1);
            }, { once: true });
        });

        // 화면 방향 변경 시에도 주소창 숨기기
        window.addEventListener('orientationchange', function () {
            setTimeout(function () {
                window.scrollTo(0, 1);
            }, 100);
        });

        // Auto-fullscreen on mobile (immediate on load)
        if (isMobile) {
            // Try fullscreen on first user interaction
            const triggerFullscreen = () => {
                enterFullscreen();
            };
            addSafeListener(document, triggerFullscreen);
        }
        // --- EMERGENCY AMMO FIX SCRIPT ---
        // This script runs at the very end to enforce weapon stats regardless of prior definitions.
        (function () {
            setTimeout(() => {
                console.log("Applying Weapon Ammo Fixes Forcefully...");
                if (typeof WEAPONS !== 'undefined') {
                    // Pistol (ID 1)
                    const pistol = WEAPONS.find(w => w.name.includes("PISTOL"));
                    if (pistol) {
                        pistol.maxAmmo = 10;
                        pistol.ammo = 10;
                        // pistol.name = "TACTICAL PISTOL (10)"; // Removed debug name
                        console.log("Fixed Pistol Ammo: 10");
                    }
                    // Sniper (ID 2)
                    const sniper = WEAPONS.find(w => w.name.includes("SNIPER"));
                    if (sniper) {
                        sniper.maxAmmo = 4;
                        sniper.ammo = 4;
                        // sniper.name = "TAC-50 SNIPER (4)"; // Removed debug name
                        console.log("Fixed Sniper Ammo: 4");
                    }
                    // Rifle (ID 3 - Auto)
                    const rifle = WEAPONS.find(w => w.name.includes("RIFLE") || w.type === 'RIFLE');
                    if (rifle) {
                        // [User Request] Slower fire rate (Refined: 0.15 -> 0.12)
                        rifle.fireRate = 0.12; // Adjusted to be slightly faster
                        console.log("Fixed Rifle Fire Rate: 0.12");
                    }
                    // Grenade (ID 4)
                    const grenade = WEAPONS.find(w => w.type === 'GRENADE');
                    if (grenade) {
                        grenade.maxAmmo = 3;
                        grenade.ammo = 3;
                        // grenade.name = "GRENADE (3)"; // Removed debug name
                    }
                    if (typeof updateUI === 'function') updateUI();
                }
            }, 500); // Slight delay to ensure everything loaded
        })();

        // --- FORCE PC WEAPON ICON STYLE (JS INJECTION) ---
        // CSS 우선순위 문제를 해결하기 위해 JS로 스타일을 직접 주입합니다.
        // --- FORCE UI STYLE BASED ON DEVICE TYPE (JS INJECTION) ---
        (function () {
            const style = document.createElement('style');
            style.id = 'dynamic-ui-style';
            document.head.appendChild(style);

            function checkGameActive() {
                // Primary check: body.game-active class (set by startGame())
                if (document.body.classList.contains('game-active')) return true;

                const modeSelection = document.getElementById('mode-selection');
                // If mode selection is visible (not none), game is NOT active
                if (modeSelection && getComputedStyle(modeSelection).display !== 'none') return false;

                // Also check room menu and name setup just in case
                const roomMenu = document.getElementById('room-menu');
                if (roomMenu && getComputedStyle(roomMenu).display !== 'none') return false;

                const nameSetup = document.getElementById('name-setup');
                if (nameSetup && getComputedStyle(nameSetup).display !== 'none') return false;

                const roomWaiting = document.getElementById('room-waiting');
                if (roomWaiting && getComputedStyle(roomWaiting).display !== 'none') return false;

                return true;
            }

            function updateDynamicUI() {
                const hasMatchMedia = typeof window.matchMedia === 'function';
                const hasCoarsePointer = hasMatchMedia && window.matchMedia('(pointer: coarse)').matches;
                const hasFinePointer = hasMatchMedia && window.matchMedia('(pointer: fine)').matches;
                const uaMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                let mobileCheck = (typeof isMobile !== 'undefined' && isMobile) || uaMobile || hasCoarsePointer;

                if (hasFinePointer && !uaMobile && !hasCoarsePointer) {
                    mobileCheck = false;
                }

                const isLandscape = window.innerWidth > window.innerHeight;
                const isGameActive = checkGameActive();

                let css = '';

                // === 0. GLOBAL FORCE HIDE (If Game Not Active) ===
                if (!isGameActive) {
                    css += `
                        .hud-container, 
                        .mobile-controls, 
                        #joystick-zone, 
                        .vitals-panel, 
                        .weapon-panel, 
                        #weapon-selector-vertical,
                        #weapon-list-left,
                        #chat-toggle-btn,
                        #chat-container,
                        #light-toggle-btn,
                        #controls {
                            display: none !important;
                        }
                    `;
                }

                if (mobileCheck) {
                    // === MOBILE FORCE STYLES ===
                    console.log('Mobile UI: Active=' + isGameActive + ', Landscape=' + isLandscape);

                    // 1. Always hide some PC elements on mobile
                    css += `
                        #weapon-inventory, #controls-guide, #weapon-label {
                            display: none !important;
                        }
                        /* Remove background from joystick zone */
                        #joystick-zone {
                            background: none !important;
                            border: none !important;
                            box-shadow: none !important;
                        }
                    `;

                    // 2. Mobile Controls Force Visible (ONLY IF GAME ACTIVE)
                    if (isGameActive) {
                        css += `
                            #joystick-zone, 
                            #fire-btn-zone, 
                            #jump-btn, 
                            #reload-btn, 
                            #crouch-btn,
                            .mobile-controls,
                            #chat-toggle-btn {
                                display: block !important;
                                visibility: visible !important;
                                opacity: 0.8 !important;
                                pointer-events: auto !important;
                                touch-action: none;
                                z-index: 9999 !important;
                            }
                            #controls {
                                display: flex !important;
                            }
                        `;
                    }

                    // 3. Mobile Landscape Specific Adjustments
                    if (isLandscape) {
                        css += `
                            /* [User Request] Force Vertical Selector in Mobile Landscape */
                            #weapon-selector-vertical {
                                display: ${isGameActive ? 'flex' : 'none'} !important;
                                flex-direction: column;
                                top: 50% !important; 
                                left: 20px !important;
                                transform: translateY(-50%) !important;
                                z-index: 10000 !important;
                                gap: 10px !important;
                            }
                            
                            /* [User Request] Increase Weapon Icon Size (2x) */
                            #weapon-selector-vertical .weapon-select-btn {
                                width: 50px !important; /* 25px -> 50px */
                                height: 50px !important; /* 25px -> 50px */
                                font-size: 20px !important; /* 10px -> 20px */
                            }

                            /* Hide PC Weapon List (Left) in Mobile Landscape */
                            #weapon-list-left {
                                display: none !important;
                            }
                            /* Ensure children are visible */
                            #weapon-list-left .weapon-item {
                                pointer-events: auto !important;
                            }
                            
                            /* Adjust Vitals and Buttons positions */
                            #joystick-zone {
                                bottom: 40px !important; 
                                left: 80px !important; /* Moved right */
                            }
                            .vitals-panel { 
                                left: 200px !important; /* Adjusted for joystick move */
                                bottom: 20px !important;
                            }
                            
                            /* Hide chat in single player mode (Mobile Landscape) */
                            body.single-player #chat-container,
                            body.single-player #chat-toggle-btn {
                                display: none !important;
                            }

                            /* Chat Container Hidden by Default on Mobile */
                            #chat-container {
                                display: none !important; /* Toggled via button */
                                bottom: 40px !important; 
                                left: 90px !important; /* Clears weapon selector */
                                width: 350px !important;
                            }
                            
                            /* Chat Toggle Button */
                            #chat-toggle-btn {
                                display: ${isGameActive ? 'flex' : 'none'} !important;
                                position: fixed;
                                left: 90px; /* Aligned with chat container */
                                top: 20px; /* Top left area */
                                width: 50px;
                                height: 50px;
                                border-radius: 50%;
                                background: rgba(0,0,0,0.6);
                                border: 2px solid rgba(255,255,255,0.3);
                                color: white;
                                font-size: 24px;
                                z-index: 101;
                                justify-content: center;
                                align-items: center;
                                cursor: pointer;
                            }
                         `;
                    } else {
                        // Portrait: Use Vertical Selector
                        if (isGameActive) {
                            css += `
                                #weapon-selector-vertical {
                                    display: flex !important;
                                    top: 50% !important;
                                    transform: translateY(-50%);
                                    left: 20px;
                                    z-index: 10000 !important;
                                }
                                #weapon-list-left {
                                    display: none !important;
                                }
                            `;
                        }
                    }
                } else {
                    // === PC FORCE STYLES (Only if NOT mobile) ===
                    css += `
                        #weapon-list-left {
                            display: ${isGameActive ? 'flex' : 'none'} !important;
                            opacity: 1 !important;
                            transform: scale(1); /* Reset scale */
                        }
                        .hud-container {
                            display: ${isGameActive ? 'block' : 'none'} !important;
                            opacity: 1 !important;
                        }
                        #chat-container {
                            display: ${isGameActive ? 'flex' : 'none'} !important;
                        }
                        /* Hide chat in single player mode (PC) */
                        body.single-player #chat-container {
                            display: none !important;
                        }
                        /* Hide Mobile Controls on PC */
                        #joystick-zone, 
                        .mobile-controls,
                        .weapon-select-btn,
                        #chat-toggle-btn {
                            display: none !important;
                        }
                    `;
                }

                style.innerHTML = css;

                // Sync chat container inline style as well if needed
                if (isGameActive && !mobileCheck) {
                    const chatContainer = document.getElementById('chat-container');
                    if (chatContainer) chatContainer.style.display = 'flex';
                }
            }

            // Expose for forcing update
            window.refreshUI = updateDynamicUI;

            // Init and Listen
            updateDynamicUI();
            window.addEventListener('resize', updateDynamicUI);
            window.addEventListener('orientationchange', () => setTimeout(updateDynamicUI, 100));

            // Observer to detect Game Start (Visibility change of Mode Selection)
            const observer = new MutationObserver(() => updateDynamicUI());
            const targets = ['mode-selection', 'room-menu', 'name-setup', 'room-waiting'];
            targets.forEach(id => {
                const el = document.getElementById(id);
                if (el) observer.observe(el, { attributes: true, attributeFilter: ['style', 'class'] });
            });
            // Also observe body for game-active class changes
            observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
        })();
    </script>
    <script>
        // [FIX] Chat Input Logic: Prevent weapon switching and handle Enter key control
        window.addEventListener('keydown', (e) => {
            const chatInput = document.getElementById('chat-input');
            const isChatFocused = (document.activeElement === chatInput);

            if (isChatFocused) {
                // Prevent number keys from switching weapons
                if (['1', '2', '3', '4'].includes(e.key)) {
                    e.stopPropagation();
                    return;
                }

                // Enter to close chat and resume (Blur & Lock)
                if (e.key === 'Enter') {
                    // Slight delay to ensure any existing "send" logic fires first if it relies on Enter
                    setTimeout(() => {
                        chatInput.blur();
                        if (!window.isMobile && document.body.requestPointerLock) {
                            document.body.requestPointerLock();
                        }
                    }, 10);
                }
            } else if (e.key === 'Enter') {
                // If chat is NOT focused and Enter is pressed, focus it
                e.preventDefault();
                chatInput.focus();
            }
        }, true); // Capture phase to handling before game logic
    </script>

    <button id="chat-toggle-btn">💬</button>

    <script>
        // Chat Toggle Logic for Mobile
        document.addEventListener('DOMContentLoaded', () => {
            const chatToggleBtn = document.getElementById('chat-toggle-btn');
            const chatContainer = document.getElementById('chat-container');
            const chatInput = document.getElementById('chat-input');

            if (chatToggleBtn && chatContainer) {
                chatToggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const isHidden = getComputedStyle(chatContainer).display === 'none';
                    if (isHidden) {
                        chatContainer.style.setProperty('display', 'flex', 'important');
                        // Optional: Auto-focus input if user wants to type immediately
                        // chatInput.focus(); 
                    } else {
                        chatContainer.style.setProperty('display', 'none', 'important');
                        chatInput.blur();
                    }
                });

                // Hide chat when touching outside (optional, but good for UX)
                document.addEventListener('touchstart', (e) => {
                    if (window.innerWidth < 1024 && // Only on mobile logic
                        chatContainer.style.display === 'flex' &&
                        !chatContainer.contains(e.target) &&
                        !chatToggleBtn.contains(e.target)) {
                        chatContainer.style.setProperty('display', 'none', 'important');
                        if (chatInput) chatInput.blur();
                    }
                });
            }
        });
    </script>
    <div id="low-health-overlay"></div>
</body>

</html>