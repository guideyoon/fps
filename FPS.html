<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <!-- PWA / Standalone ëª¨ë“œ ì„¤ì • - ì£¼ì†Œì°½ ìˆ¨ê¸°ê¸° -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">

    <title>FPS Multiplayer - Room System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* ëª¨ë°”ì¼ ê°€ë¡œ ëª¨ë“œ ëŒ€ì‘ */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* ëª¨ë°”ì¼ ê°€ë¡œ ëª¨ë“œ ìµœì í™” */
        @media (orientation: landscape) and (max-height: 500px) {

            html,
            body {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            transition: opacity 0.1s;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 2px black;
        }

        #crosshair::before {
            width: 16px;
            height: 1.5px;
        }

        #crosshair::after {
            width: 1.5px;
            height: 16px;
        }

        #crosshair.enemy-detected::before,
        #crosshair.enemy-detected::after {
            background: #ff0000;
            box-shadow: 0 0 4px red;
        }

        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%) rotate(45deg);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s, filter 0.1s;
            z-index: 10;
        }

        #hit-marker::before,
        #hit-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: #ff3333;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px red, 0 0 12px rgba(255, 0, 0, 0.6);
        }

        #hit-marker::before {
            width: 28px;
            height: 4px;
        }

        #hit-marker::after {
            width: 4px;
            height: 28px;
        }

        #scope-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 20;
            /* PUBG ìŠ¤íƒ€ì¼ - ì£¼ë³€ë„ ë³´ì´ë„ë¡ ë°˜íˆ¬ëª… ì²˜ë¦¬ */
            background: radial-gradient(circle, transparent 20%, rgba(0, 0, 0, 0.7) 21%, rgba(0, 0, 0, 0.85) 100%);
            /* Pointer events none to allow clicks if needed, though usually aiming blocks interactions */
            pointer-events: none;
        }

        #scope-line-h {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateY(-50%);
        }

        #scope-line-v {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            transform: translateX(-50%);
        }

        #scope-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, black 150%);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 5;
            pointer-events: none;
        }

        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 6;
            pointer-events: none;
        }

        #headshot-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            color: #ff0000;
            font-size: 40px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 2px 2px 0 #000;
            opacity: 0;
            transition: transform 0.1s, opacity 0.1s;
            z-index: 15;
            pointer-events: none;
        }

        #headshot-msg.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }

        #ammo-info {
            position: absolute;
            bottom: 25px;
            right: 25px;
            color: white;
            font-size: 24px;
            font-weight: 900;
            font-style: italic;
            text-shadow: 1px 1px 2px #000;
            letter-spacing: 1px;
            text-align: right;
            pointer-events: none;
        }

        #weapon-label {
            font-size: 18px;
            color: #fbbc05;
            display: block;
            margin-bottom: 5px;
        }

        #ammo-val {
            display: block;
        }

        .no-ammo {
            color: #ff3333;
            animation: shake 0.2s;
        }

        @keyframes shake {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        #hp-container {
            position: absolute;
            bottom: 25px;
            left: 50px;
            /* HP text space */
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: visible;
            /* Allow text outside */
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: #4caf50;
            transition: width 0.2s, background-color 0.2s;
            border-radius: 2px;
        }

        #hp-text {
            position: absolute;
            left: -35px;
            /* Left of the bar */
            bottom: -3px;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: red;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 60px;
            font-weight: 900;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99;
            font-size: 40px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        #mode-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-size: 28px;
            font-weight: 900;
            cursor: default;
            pointer-events: auto;
        }

        #mode-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .mode-btn {
            margin: 20px;
            padding: 20px 60px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.5);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 8px;
            min-width: 250px;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }

        .mode-btn:active {
            transform: scale(0.98);
        }

        /* Room System UI Common Styles */
        #name-setup,
        #room-menu,
        #create-room-modal,
        #room-waiting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 201;
            font-size: 18px;
            pointer-events: auto;
        }

        #create-room-modal {
            background: rgba(0, 0, 0, 0.7);
            z-index: 202;
        }

        .modal-content {
            background: #222;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 400px;
        }

        h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #4CAF50;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .input-group {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        input[type="text"],
        select {
            padding: 12px 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 5px;
            width: 300px;
            text-align: center;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            background: #4CAF50;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin: 10px;
            font-weight: bold;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        button.cancel {
            background: #f44336;
        }

        button.cancel:hover {
            background: #d32f2f;
        }

        /* Room Menu Specifics */
        .menu-actions {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        #room-list-container {
            width: 60%;
            height: 400px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow-y: auto;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .room-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .room-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .room-info h3 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #fff;
        }

        .room-info p {
            margin: 0;
            font-size: 14px;
            color: #aaa;
        }

        .room-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-badge.waiting {
            background: #2196F3;
        }

        .status-badge.playing {
            background: #FF9800;
        }

        .status-badge.full {
            background: #f44336;
        }

        /* Chat System */
        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        #chat-messages {
            height: 200px;
            overflow-y: auto;
            padding-right: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #chat-messages::-webkit-scrollbar {
            width: 5px;
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .chat-msg {
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-msg .sender {
            font-weight: bold;
            color: #4CAF50;
            margin-right: 5px;
        }

        .chat-msg.system {
            color: #ffeb3b;
            font-style: italic;
        }

        .chat-input-area {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            width: auto;
        }

        #btn-send-chat {
            padding: 8px 15px;
            border-radius: 20px;
            margin: 0;
            background: #2196F3;
        }

        #room-waiting {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 202;
            font-size: 24px;
            pointer-events: auto;
        }

        #room-waiting h2 {
            font-size: 36px;
            margin-bottom: 30px;
        }

        #players-list {
            margin: 30px;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }

        #countdown {
            font-size: 72px;
            color: #ff3333;
            text-shadow: 0 0 20px rgba(255, 51, 51, 0.8);
            margin: 30px;
        }

        #restart-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.9);
            border: 3px solid #444;
            cursor: pointer;
            z-index: 2000;
            /* Ensure visibility */
            pointer-events: auto;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #stats-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: flex;
            gap: 30px;
            z-index: 10;
        }

        #play-time,
        #kill-count {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #controls-guide {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            line-height: 1.6;
            text-shadow: 1px 1px 1px black;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }

        .key {
            color: #fbbc05;
            font-weight: bold;
        }

        /* PC ê°ë„ ì¡°ì • UI */
        #sensitivity-control {
            position: absolute;
            top: 120px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            pointer-events: auto;
        }

        #sensitivity-control label {
            color: white;
            font-size: 14px;
            margin-right: 10px;
        }

        #sensitivity-slider {
            width: 150px;
            margin-right: 10px;
        }

        #sensitivity-value {
            color: #fbbc05;
            font-weight: bold;
            font-size: 14px;
            min-width: 40px;
            display: inline-block;
        }

        /* ì¡°ëª… í† ê¸€ ë²„íŠ¼ */
        #light-toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: none;
            /* Hide by default, show only during gameplay */
            align-items: center;
            justify-content: center;
            color: #ffaa00;
            font-size: 24px;
            cursor: pointer;
            z-index: 1000;
            user-select: none;
            transition: background 0.2s, border-color 0.2s;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        #light-toggle-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
        }

        #light-toggle-btn.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
            color: #ffcc44;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }

        /* Death Overlay & Killcam UI */
        #death-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
            pointer-events: none;
        }

        #respawn-timer {
            font-size: 96px;
            font-weight: bold;
            color: #ff3333;
            text-shadow: 0 0 30px rgba(255, 51, 51, 0.9), 0 0 60px rgba(255, 51, 51, 0.5);
            margin-bottom: 30px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        #killed-by-label {
            font-size: 28px;
            color: #ffffff;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }

        #killer-name {
            font-size: 48px;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
        }

        /* Sniper Scope Overlay */
        #sniper-scope {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center,
                    transparent 0%,
                    transparent 24%,
                    rgba(0, 0, 0, 0.5) 26%,
                    rgba(0, 0, 0, 0.75) 100%);
            display: none;
            z-index: 100;
            pointer-events: none;
        }

        #scope-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(600px, 80vh);
            height: min(600px, 80vh);
            border: 15px solid #111;
            border-radius: 50%;
            box-shadow:
                inset 0 0 60px rgba(0, 0, 0, 0.9),
                inset 0 0 20px rgba(0, 0, 0, 0.6),
                0 0 30px rgba(0, 0, 0, 0.8);
        }

        .scope-crosshair-h,
        .scope-crosshair-v {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        .scope-crosshair-h {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .scope-crosshair-v {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        .scope-center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 50, 50, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 50, 50, 0.8);
        }

        /* Scope tick marks */
        .scope-tick {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }

        .scope-tick-h {
            height: 1px;
            width: 10px;
            top: 50%;
            transform: translateY(-50%);
        }

        .scope-tick-v {
            width: 1px;
            height: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ */
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            pointer-events: none;
        }

        #touch-left,
        #touch-right {
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        /* ëª¨ë°”ì¼ ë²„íŠ¼ */
        .mobile-btn {
            position: absolute;
            width: 35px;
            /* 40px -> 35px (ì¶”ê°€ ì¶•ì†Œ) */
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            /* 16px -> 14px */
            font-weight: bold;
            pointer-events: auto;
            z-index: 30;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        /* --- 1. Joystick --- */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 100px;
            /* 120px -> 100px */
            height: 100px;
            z-index: 50;
            /* background: rgba(255, 0, 0, 0.2); Debug */
        }

        #joystick-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            /* 50px -> 40px */
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* --- 2. Vertical Weapon Selector (Left) --- */
        #weapon-selector-vertical {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            /* Mobile only */
            flex-direction: column;
            gap: 15px;
            z-index: 50;
        }

        .weapon-select-btn {
            width: 35px;
            /* 40px -> 35px */
            height: 35px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            /* 18px -> 16px */
        }

        .weapon-select-btn.active {
            background: rgba(255, 170, 0, 0.6);
            border-color: #ffaa00;
        }

        /* ë¬´ê¸° êµì²´ ë²„íŠ¼ (ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€, ë¯¸ë””ì–´ ì¿¼ë¦¬ì—ì„œ ì²˜ë¦¬) */
        #btn-weapon1,
        #btn-weapon2,
        #btn-weapon3,
        #btn-weapon4 {
            display: none !important;
        }

        /* í¬ëŸ°ì»¤ ìŠ¤íƒ€ì¼ í´ëŸ¬ìŠ¤í„° ë°°ì¹˜ */
        #btn-shoot {
            bottom: 80px;
            right: 80px;
            width: 55px;
            /* 80px -> 55px */
            height: 55px;
            background: rgba(255, 255, 255, 0.2);
            font-size: 24px;
            /* 32px -> 24px */
            border-width: 3px;
        }

        #btn-aim {
            bottom: 180px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-jump {
            bottom: 110px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-reload {
            bottom: 20px;
            right: 140px;
            width: 60px;
            height: 60px;
            font-size: 24px;
        }

        #btn-weapon-cycle {
            bottom: 20px;
            right: 220px;
            width: 60px;
            height: 60px;
            font-size: 24px;
            background: rgba(251, 188, 5, 0.3);
            border-color: #fbbc05;
        }

        /* ëª¨ë°”ì¼ UI ì¡°ì • */
        @media (max-width: 768px) {

            /* 1. HUD í•˜ë‹¨ ì´ë™ ë° ì¶•ì†Œ - ëª¨ë°”ì¼ ì „ìš© ì˜¤ë²„ë¼ì´ë“œ */
            #ammo-info {
                bottom: 20px;
                left: auto;
                /* ê¸°ì¡´ ì¤‘ì•™ ì •ë ¬ í•´ì œ */
                right: 90px;
                /* ì˜¤ë¥¸ìª½ ë²„íŠ¼ í”¼í•´ì„œ ë°°ì¹˜ */
                font-size: 14px;
                /* ë” ì‘ê²Œ */
                text-align: right;
                transform: none;
            }

            #ammo-val {
                font-size: 18px;
            }

            #weapon-label {
                display: none;
            }

            /* ê³µê°„ ì ˆì•½ */

            #hp-container {
                width: 120px;
                /* 150px -> 120px */
                height: 8px;
                /* 10px -> 8px */
                bottom: 22px;
                left: 45px;
                /* 60px -> 45px, closer to left */
                /* HP í…ìŠ¤íŠ¸ ê³µê°„ í™•ë³´ */
                transform: none;
                /* ì¤‘ì•™ ì •ë ¬ í•´ì œ */
                background: rgba(0, 0, 0, 0.6);
            }

            #hp-text {
                display: block;
                /* í…ìŠ¤íŠ¸ í‘œì‹œ */
                font-size: 12px;
                /* 14px -> 12px */
                left: -28px;
                /* -30px -> -28px */
                bottom: -3px;
                /* -4px -> -3px */
            }

            /* ë²„íŠ¼ ìœ„ì¹˜ ìƒí–¥ ì¡°ì • (í™”ë©´ í•˜ë‹¨ ê²¹ì¹¨ ë°©ì§€ - íƒ„ì•½ í‘œì‹œì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì¶”ê°€ ìƒí–¥) */
            .mobile-btn {
                bottom: 150px;
                /* 110px -> 150px (ì¶”ê°€ ìƒí–¥) */
                /* ê¸°ë³¸ê°’ ìƒí–¥ */
            }

            #btn-shoot {
                bottom: 170px;
                /* 130px -> 170px */
                right: 40px;
                width: 45px;
                /* 50px -> 45px */
                /* 70px -> 50px */
                height: 45px;
            }

            #btn-jump {
                bottom: 230px;
                /* 190px -> 230px */
                right: 20px;
            }

            #btn-reload {
                bottom: 290px;
                /* 250px -> 290px */
                right: 20px;
            }

            #btn-aim {
                bottom: 110px;
                /* 70px -> 110px */
                right: 100px;
            }

            #joystick-zone {
                bottom: 150px;
                /* 110px -> 150px */
                /* ì¡°ì´ìŠ¤í‹±ë„ ìƒí–¥ */
                left: 40px;
            }

            #weapon-selector-vertical {
                top: 45%;
                left: 20px;
            }

            #controls-guide {
                display: none;
                /* ëª¨ë°”ì¼ì—ì„œ ì¡°ì‘ ì„¤ëª… ìˆ¨ê¹€ */
            }

            .mobile-btn {
                display: flex;
            }

            /* ìƒë‹¨ ìŠ¤íƒ¯ ì •ë³´ ìµœì í™” */
            #stats-info {
                top: 5px;
                gap: 10px;
                font-size: 12px;
            }

            #play-time,
            #kill-count {
                padding: 2px 8px;
                background: rgba(0, 0, 0, 0.3);
                border: none;
            }

            .mobile-btn {
                display: flex;
            }

            /* ê¸°ì¡´ ë¬´ê¸° ë²„íŠ¼ ë° ì‚¬ì´í´ ë²„íŠ¼ ìˆ¨ê¹€ (ìƒˆë¡œìš´ ìˆ˜ì§ ì„ íƒê¸°ë¡œ ëŒ€ì²´) */
            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4,
            #btn-weapon-cycle {
                display: none !important;
            }

            /* ë¬´ê¸° ì„ íƒê¸° í‘œì‹œ */
            #weapon-selector-vertical {
                display: flex;
            }

            /* ì¡°ì´ìŠ¤í‹± í‘œì‹œ */
            #joystick-zone {
                display: block;
            }
        }

        /* ê°€ë¡œ ëª¨ë“œ */
        @media (orientation: landscape) and (max-width: 1024px) {
            .mobile-btn {
                display: flex !important;
                width: 50px;
                height: 50px;
                font-size: 16px;
            }

            #btn-jump {
                bottom: 15px;
                right: 15px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-reload {
                bottom: 15px;
                right: 75px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-aim {
                bottom: 15px;
                right: 135px;
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                width: 45px;
                height: 45px;
                font-size: 16px;
                top: 10px;
            }

            #ammo-info {
                bottom: 70px;
                right: 15px;
                font-size: 20px;
            }

            #hp-container {
                width: 180px;
                height: 12px;
                bottom: 70px;
                left: 15px;
            }

            #hp-text {
                bottom: 85px;
                left: 15px;
                font-size: 12px;
            }
        }

        /* ì„¸ë¡œ ëª¨ë“œ */
        @media (orientation: portrait) and (max-width: 768px) {
            #btn-jump {
                bottom: 15px;
                right: 15px;
            }

            #btn-reload {
                bottom: 15px;
                right: 75px;
            }

            #btn-aim {
                bottom: 15px;
                right: 135px;
            }

            #btn-weapon1,
            #btn-weapon2,
            #btn-weapon3,
            #btn-weapon4 {
                top: 8px;
            }

            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
        }

        @media (max-width: 768px) {
            #light-toggle-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
                font-size: 22px;
            }
        }

        @media (hover: hover) and (pointer: fine) {

            #controls,
            .mobile-btn {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="game-container"></div>
    <div id="vignette"></div>
    <div id="damage-overlay"></div>
    <div id="scope-overlay">
        <div id="scope-line-h"></div>
        <div id="scope-line-v"></div>
        <div id="scope-dot"></div>
    </div>
    <div id="headshot-msg">HEADSHOT!</div>
    <div id="hit-marker"></div>

    <div id="game-over">
        YOU DIED
        <button id="restart-btn">TRY AGAIN</button>
    </div>

    <div id="pause-overlay">
        PAUSED
    </div>

    <!-- ëª¨ë“œ ì„ íƒ í™”ë©´ -->
    <div id="mode-selection">
        <h1>ê²Œì„ ëª¨ë“œ ì„ íƒ</h1>
        <button class="mode-btn" id="btn-single-player">í˜¼ìí•˜ê¸°</button>
        <button class="mode-btn" id="btn-multi-player">í•¨ê»˜í•˜ê¸°</button>
    </div>

    <!-- 1. ì´ë¦„ ì„¤ì • í™”ë©´ -->
    <div id="name-setup" style="display: none;">
        <h2><i class="fas fa-user-tag"></i> í”Œë ˆì´ì–´ ì„¤ì •</h2>
        <div class="input-group">
            <input type="text" id="player-name-input" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
        </div>
        <button id="btn-confirm-name"><i class="fas fa-check"></i> í™•ì¸</button>
        <button class="cancel" id="btn-back-to-mode">ì·¨ì†Œ</button>
    </div>

    <!-- 2. ë°© ëª©ë¡/ë©”ë‰´ í™”ë©´ -->
    <div id="room-menu" style="display: none;">
        <h2><i class="fas fa-list"></i> ë©€í‹°í”Œë ˆì´ ë¡œë¹„</h2>
        <div class="menu-actions">
            <button id="btn-show-create-room"><i class="fas fa-plus-circle"></i> ë°© ë§Œë“¤ê¸°</button>
            <button id="btn-refresh-rooms"><i class="fas fa-sync-alt"></i> ëª©ë¡ ê°±ì‹ </button>
        </div>
        <div id="room-list-container">
            <!-- ë°© ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë¨ -->
            <div class="no-rooms-message">ìƒì„±ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</div>
        </div>
        <button class="cancel" id="btn-back-to-name">ë’¤ë¡œê°€ê¸°</button>
    </div>

    <!-- 3. ë°© ìƒì„± ëª¨ë‹¬ -->
    <div id="create-room-modal" style="display: none;">
        <div class="modal-content">
            <h2><i class="fas fa-door-open"></i> ë°© ë§Œë“¤ê¸°</h2>
            <div class="input-group">
                <label>ë°© ì´ë¦„</label>
                <input type="text" id="new-room-name" placeholder="ë°© ì œëª© ì…ë ¥">
            </div>
            <div class="input-group">
                <label>ìµœëŒ€ ì¸ì›</label>
                <select id="new-room-max">
                    <option value="2">2ëª…</option>
                    <option value="4" selected>4ëª…</option>
                    <option value="8">8ëª…</option>
                </select>
            </div>
            <div class="input-group">
                <label>ë§µ ì„ íƒ</label>
                <select id="new-room-map">
                    <option value="factory" selected>ì°½ê³  (Factory)</option>
                    <option value="hotel">í˜¸í…” (Hotel)</option>
                    <!-- í–¥í›„ ë§µ ì¶”ê°€ ì˜ˆì‹œ -->
                    <!-- <option value="urban">ë„ì‹œ (Urban)</option> -->
                    <!-- <option value="desert">ì‚¬ë§‰ (Desert)</option> -->
                </select>
            </div>
            <div class="modal-actions">
                <button id="btn-create-confirm">ìƒì„±</button>
                <button class="cancel" id="btn-create-cancel">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>

    <!-- Game Start Countdown Overlay -->
    <div id="countdown"
        style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,0.8), 0 0 40px rgba(255,255,255,0.5); font-weight: bold; z-index: 9999; pointer-events: none;">
    </div>

    <!-- 4. ëŒ€ê¸°ì‹¤ í™”ë©´ -->
    <div id="room-waiting" style="display: none;">
        <h2 id="room-title">ë°© ì´ë¦„</h2>
        <p id="room-info" style="color: #aaa; margin-bottom: 20px;"><i class="fas fa-users"></i> <span
                id="player-count">0/0</span></p>

        <div id="players-list"></div>

        <div class="host-controls" style="display: none;">
            <button id="btn-start-game" class="start-btn"><i class="fas fa-play"></i> ê²Œì„ ì‹œì‘</button>
        </div>

        <button class="cancel" id="btn-leave-room"><i class="fas fa-sign-out-alt"></i> ë‚˜ê°€ê¸°</button>
    </div>

    <!-- ì¸ê²Œì„ ì±„íŒ… -->
    <div id="chat-container" style="display: none;">
        <div id="chat-messages"></div>
        <div class="chat-input-area">
            <input type="text" id="chat-input" placeholder="ë©”ì‹œì§€ ì…ë ¥ (Enter)" autocomplete="off">
            <button id="btn-send-chat"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="ammo-info">
            <span id="weapon-label">ASSAULT RIFLE</span>
            <span id="ammo-val">30 / 120</span>
        </div>

        <div id="hp-text">HP</div>
        <div id="hp-container">
            <div id="hp-bar"></div>
        </div>

        <div id="stats-info">
            <div id="play-time">Time: 00:00</div>
            <div id="kill-count">Kills: 0</div>
        </div>

        <div id="controls-guide">
            <span class="key">1</span>ì†Œì´ <span class="key">2</span>ê¶Œì´ <span class="key">3</span>ì €ê²© <span
                class="key">4</span>ì¹¼<br>
            <span class="key">WASD</span> ì´ë™ <br>
            <span class="key">Space</span> ì í”„ / <span class="key">Shift</span> ë‹¬ë¦¬ê¸° <br>
            <span class="key">R</span> ì¬ì¥ì „ <br>
            <span class="key">Click</span> ë°œì‚¬/ì¡°ì¤€
        </div>

        <!-- PC ê°ë„ ì¡°ì • UI -->
        <div id="sensitivity-control" style="display: none;">
            <label for="sensitivity-slider">ë§ˆìš°ìŠ¤ ê°ë„:</label>
            <input type="range" id="sensitivity-slider" min="0.0005" max="0.01" step="0.0005" value="0.002">
            <span id="sensitivity-value">1.0</span>
        </div>
    </div>

    <!-- ì¡°ëª… í† ê¸€ ë²„íŠ¼ -->
    <button id="light-toggle-btn" class="light-toggle-btn" title="ì¡°ëª… ì¼œê¸°/ë„ê¸°">ğŸ’¡</button>

    <div id="controls">
        <div id="touch-left"></div>
        <div id="touch-right"></div>
    </div>

    <!-- ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ -->
    <button class="mobile-btn" id="btn-weapon1">1</button>
    <!-- ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ (Krunker ìŠ¤íƒ€ì¼ í´ëŸ¬ìŠ¤í„°) -->
    <div id="joystick-zone">
        <div id="joystick-bg"></div>
        <div id="joystick-handle"></div>
    </div>

    <!-- ìˆ˜ì§ ë¬´ê¸° ì„ íƒê¸° (ì™¼ìª½ ê°€ìš´ë°) -->
    <div id="weapon-selector-vertical">
        <div class="weapon-select-btn" data-idx="0"><i class="fas fa-person-rifle"></i></div>
        <!-- Rifle: improved icon (fa-person-rifle shows rifle clearly) -->
        <div class="weapon-select-btn" data-idx="1"><i class="fas fa-gun"></i></div>
        <!-- Pistol: changed to fa-gun (simpler pistol icon) -->
        <div class="weapon-select-btn" data-idx="2"><i class="fas fa-crosshairs"></i></div> <!-- Sniper -->
        <div class="weapon-select-btn" data-idx="3"><i class="fas fa-gavel"></i></div> <!-- Knife -->
    </div>

    <button class="mobile-btn" id="btn-shoot"><i class="fas fa-crosshairs"></i></button>
    <button class="mobile-btn" id="btn-aim"><i class="fas fa-eye"></i></button>
    <button class="mobile-btn" id="btn-jump"><i class="fas fa-chevron-up"></i></button>
    <button class="mobile-btn" id="btn-reload"><i class="fas fa-redo"></i></button>

    <!-- Death Overlay (Multiplayer) -->
    <div id="death-overlay">
        <div id="respawn-timer">10</div>
        <div id="killed-by-label">Killed by</div>
        <div id="killer-name">Unknown</div>
        <button id="manual-respawn-btn"
            style="display: none; margin-top: 20px; padding: 10px 20px; font-size: 24px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">RESPAWN
            NOW</button>
    </div>

    <!-- Sniper Scope Overlay -->
    <div id="sniper-scope">
        <div id="scope-circle">
            <div class="scope-crosshair-h"></div>
            <div class="scope-crosshair-v"></div>
            <div class="scope-center-dot"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        console.log('=== FPS.html VERSION: 2026-01-06-2217 ==='); // VERSION CHECK
        let camera, scene, renderer;
        let postProcessingCanvas, postProcessingCtx; // Global declaration
        let postProcessingEnabled = false;

        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
            ('ontouchstart' in window) ||
            (navigator.maxTouchPoints > 0) ||
            (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

        let ceilingLight = null;
        let lastTime = performance.now();

        // í™•ì¥ ê¸°ëŠ¥ ë³€ìˆ˜
        let gltfLoader, textureLoader;
        let composer; // í›„ì²˜ë¦¬ ì»´í¬ì €
        let physicsWorld; // ë¬¼ë¦¬ ì—”ì§„ ì„¸ê³„
        let usePhysics = true; // ë¬¼ë¦¬ ì—”ì§„ ì‚¬ìš© ì—¬ë¶€ (í™œì„±í™”)
        let usePostProcessing = true; // í›„ì²˜ë¦¬ íš¨ê³¼ ì‚¬ìš© ì—¬ë¶€ (í™œì„±í™”)

        // ê°ë„ ì„¤ì • (ê¸°ë³¸ê°’)
        let SENSITIVITY_MOUSE = 0.002;
        let SENSITIVITY_ADS = 0.0005;

        // localStorageì—ì„œ ê°ë„ ë¡œë“œ
        const savedSensitivity = localStorage.getItem('mouseSensitivity');
        if (savedSensitivity) {
            const sensitivity = parseFloat(savedSensitivity);
            if (!isNaN(sensitivity) && sensitivity > 0) {
                SENSITIVITY_MOUSE = sensitivity;
                SENSITIVITY_ADS = sensitivity * 0.25; // ADSëŠ” ì¼ë°˜ ê°ë„ì˜ 25%
            }
        }

        // Player State
        let position = new THREE.Vector3(0, 1.7, 5);
        let rotation = { x: 0, y: 0 };
        let velocityY = 0;
        let isGrounded = false;
        let playerHP = 100;
        let isDead = false;
        let isPaused = false;
        let gameMode = null; // 'single' or 'multi'
        let currentMap = 'factory'; // ì„ íƒëœ ë§µ (ê¸°ë³¸ê°’: factory)
        let isRoomHost = false;
        let maxPlayers = 4;
        let currentPlayers = 1;
        let playersList = [];
        let countdownTimer = null;

        // Multiplayer Socket
        let socket = null;
        let myId = null;
        let otherPlayersMap = {}; // id -> mesh
        let roomPlayersState = {}; // Global player data
        const PLAYER_RADIUS = 0.4;

        // Spectator/Killcam System
        let isSpectating = false;
        let spectatingPlayerId = null;

        // Footsteps
        let moveDistance = 0;
        const STEP_INTERVAL = 2.5;

        // === ì „ì²´í™”ë©´ í•¨ìˆ˜ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ëŒ€ì‘) ===
        function enterFullscreen() {
            const elem = document.documentElement;

            // ì´ë¯¸ ì „ì²´í™”ë©´ì´ë©´ ë¬´ì‹œ
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
                return;
            }

            // í¬ë¡œìŠ¤ ë¸Œë¼ìš°ì € ì „ì²´í™”ë©´ ìš”ì²­
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => {
                    console.log('Fullscreen request failed:', err);
                });
            } else if (elem.webkitRequestFullscreen) { // iOS Safari
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
            }
        }

        // === ì „ì—­ ë³€ìˆ˜ ===
        const keys = { w: 0, a: 0, s: 0, d: 0, shift: false, ctrl: false, space: false };

        // --- Weapon System ---
        const WEAPONS = [
            {
                id: 0, name: "ASSAULT RIFLE",
                type: 'RIFLE', maxAmmo: 30, ammo: 30, automatic: true,
                posHip: new THREE.Vector3(0.2, -0.25, -0.45),
                // ADS ìœ„ì¹˜: Y=-0.062ë¡œ ì •ë ¬ ìœ ì§€, í´ë¦¬í•‘ ë°©ì§€ë¥¼ ìœ„í•´ Z=-0.35ë¡œ ê±°ë¦¬ ì¡°ì •
                posAds: new THREE.Vector3(0, -0.062, -0.35),
                fovAds: 20, fireRate: 0.08, recoil: 0.06, damage: 30
            },
            {
                id: 1, name: "TACTICAL PISTOL",
                type: 'PISTOL', maxAmmo: 12, ammo: 12, automatic: false,
                posHip: new THREE.Vector3(0.15, -0.2, -0.35),
                // ìˆ˜ì •: ADS ì¢Œí‘œ ì •ë°€ ë³´ì • (ê°€ëŠ ì ë†’ì´ì™€ ì¼ì¹˜)
                posAds: new THREE.Vector3(0, -0.0482, -0.35),
                fovAds: 35, fireRate: 0.15, recoil: 0.1, damage: 20
            },
            {
                id: 2, name: "TAC-50 SNIPER",
                type: 'SNIPER', maxAmmo: 5, ammo: 5, automatic: false,
                posHip: new THREE.Vector3(0.2, -0.3, -0.5),
                posAds: new THREE.Vector3(0, -0.06, -0.15),
                fovAds: 8, fireRate: 2.0, recoil: 0.4, damage: 100
            },
            {
                id: 3, name: "KARAMBIT",
                type: 'KNIFE', maxAmmo: 0, ammo: 0, automatic: true,
                posHip: new THREE.Vector3(0.25, -0.25, -0.5),
                posAds: new THREE.Vector3(0.25, -0.25, -0.45),
                fovAds: 65, fireRate: 0.4, recoil: 0, damage: 15
            }
        ];
        let curWeaponIdx = 0;

        let weaponContainer, weaponModel;
        let currentPos = WEAPONS[0].posHip.clone();

        let isAiming = false;
        let isFiring = false;
        let hasFiredSemi = false;
        let isReloading = false;
        let knifeSwing = 0;
        let hasClickedEmpty = false;
        let sniperReloadGesture = false; // PC ëª¨ë“œ ì €ê²©ì´ ì¬ì¥ì „ ì œìŠ¤ì²˜ í”Œë˜ê·¸

        let fireCooldown = 0;

        let recoil = { x: 0, z: 0 };
        let muzzleFlash;
        let hitShake = { x: 0, y: 0, intensity: 0 }; // í”¼ê²© ì‹œ í™”ë©´ í”ë“¤ë¦¼

        let shells = [];
        let shellGeo, shellMat;
        let bloodParticles = [];
        let decals = [];
        let healthPills = [];
        const matHealthPill = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.2, metalness: 0.8, emissive: 0xff00ff, emissiveIntensity: 0.5 });

        let enemies = [];
        const ZOMBIE_SPEED = 2.5;
        const ZOMBIE_DMG = 10;
        const ATTACK_RANGE = 2.5;
        const ENEMY_RADIUS = 0.4;

        const MAX_ENEMIES = 20;
        const SPAWN_INTERVAL = 2.0;
        let spawnTimer = 0;

        // ë©€í‹°í”Œë ˆì´ì–´ í”Œë ˆì´ì–´ ë°°ì—´
        let otherPlayers = [];

        // í”Œë ˆì´ì–´ ëª¨ë¸ìš© ì¬ì§ˆ (ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ êµ¬ë¶„)
        let matPlayerBody = new THREE.MeshStandardMaterial({ color: 0x4a90e2, roughness: 0.4, metalness: 0.6, emissive: 0x1a3052, emissiveIntensity: 0.6 });
        let matPlayerSkin = new THREE.MeshStandardMaterial({ color: 0xf4a460, roughness: 0.7, emissive: 0x543410, emissiveIntensity: 0.4 });

        // ê²Œì„ í†µê³„
        let gameStartTime = 0;
        let killCount = 0;
        let playTime = 0;

        let colliders = [];

        // UI - init() í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì´ˆê¸°í™”
        let elAmmoVal, elWeaponLabel, elCrosshair, elVignette, elScope;
        let elHpBar, elHpText, elDamage, elPlayTime, elKillCount;
        let elGameOver, elPauseOverlay, elHeadshot, elHitMarker;

        // Materials
        const matBody = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4, metalness: 0.6 });
        const matParts = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.8 });
        const matSilver = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2, metalness: 0.9 });
        const matSkin = new THREE.MeshStandardMaterial({ color: 0xcbb093, roughness: 0.7 });
        const matSleeve = new THREE.MeshStandardMaterial({ color: 0x1c1f1c, roughness: 1.0 });
        const matGlove = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.9 });
        const matSight = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const matBlade = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, metalness: 1.0 });
        const matHandle = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
        const matLens = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.1, metalness: 0.9 });
        const matDecal = new THREE.MeshBasicMaterial({ color: 0x000000, polygonOffset: true, polygonOffsetFactor: -1 });

        const matZombieSkin = new THREE.MeshStandardMaterial({ color: 0x5e7052, roughness: 0.8 });
        const matZombieClothes = new THREE.MeshStandardMaterial({ color: 0x4a3b2a, roughness: 0.9 });
        let matHpBg = new THREE.MeshBasicMaterial({ color: 0x000000 });
        let matHpFg = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        const SoundGen = {
            ctx: null,
            audioBuffers: {}, // ë¡œë“œëœ ì˜¤ë””ì˜¤ íŒŒì¼ ìºì‹œ
            masterVolume: 1.0, // ë§ˆìŠ¤í„° ë³¼ë¥¨ (0.0 ~ 1.0)
            reloadVolume: 0.8, // ì¬ì¥ì „ ë³¼ë¥¨ (0.0 ~ 1.0)
            init: function () {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                } catch (e) {
                    console.warn('AudioContext initialization failed:', e);
                }
            },
            // ì™¸ë¶€ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ í•¨ìˆ˜
            loadAudioFile: function (url, name) {
                if (!this.ensureContext()) {
                    console.warn('AudioContext not available');
                    return Promise.reject('AudioContext not available');
                }

                // ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ìºì‹œì—ì„œ ë°˜í™˜
                if (this.audioBuffers[name]) {
                    return Promise.resolve(this.audioBuffers[name]);
                }

                return fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        return this.ctx.decodeAudioData(arrayBuffer);
                    })
                    .then(audioBuffer => {
                        this.audioBuffers[name] = audioBuffer;
                        console.log(`Audio file loaded: ${name}`);
                        return audioBuffer;
                    })
                    .catch(error => {
                        console.error(`Failed to load audio file ${url}:`, error);
                        throw error;
                    });
            },
            // ë¡œë“œëœ ì˜¤ë””ì˜¤ íŒŒì¼ ì¬ìƒ í•¨ìˆ˜
            playAudioFile: function (name, volume = 1.0, loop = false) {
                if (!this.ensureContext()) return;

                const audioBuffer = this.audioBuffers[name];
                if (!audioBuffer) {
                    console.warn(`Audio file not loaded: ${name}. Use loadAudioFile() first.`);
                    return;
                }

                try {
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();

                    source.buffer = audioBuffer;
                    source.loop = loop;
                    // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì ìš©
                    gainNode.gain.value = volume * this.masterVolume;

                    source.connect(gainNode);
                    gainNode.connect(this.ctx.destination);

                    source.start(0);

                    return source; // ì¬ìƒ ì¤‘ì§€ ë“±ì„ ìœ„í•´ ë°˜í™˜
                } catch (e) {
                    console.error(`Failed to play audio file ${name}:`, e);
                }
            },
            ensureContext: function () {
                if (!this.ctx) {
                    this.init();
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.warn('AudioContext resume failed:', e));
                }
                return !!this.ctx;
            },
            playShoot: function (type) {
                if (!this.ensureContext()) return;

                // ì €ê²©ì´ì€ ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (type === 'SNIPER' && this.audioBuffers['rifle']) {
                    this.playAudioFile('rifle', 0.25); // ë³¼ë¥¨ 25%
                    return;
                }

                // ê¶Œì´ì€ ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (type === 'PISTOL' && this.audioBuffers['gunshot']) {
                    this.playAudioFile('gunshot', 0.8);
                    return;
                }

                // ê¸°ì¡´ ì†Œë¦¬ ìƒì„± (í´ë°±)
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                filter.type = 'lowpass';
                if (type === 'SNIPER') {
                    filter.frequency.value = 600;
                    gain.gain.setValueAtTime(1.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);
                } else if (type === 'RIFLE') {
                    filter.frequency.value = 1000;
                    gain.gain.setValueAtTime(1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                } else {
                    filter.frequency.value = 1500;
                    gain.gain.setValueAtTime(0.8, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                }

                noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                noise.start();
            },
            playDryFire: function () {
                if (!this.ensureContext()) return;

                // ë¹ˆ ê²©ë°œ ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (this.audioBuffers['empty']) {
                    this.playAudioFile('empty', 0.8);
                } else {
                    // ê¸°ì¡´ ì†Œë¦¬ ìƒì„± (í´ë°±)
                    const t = this.ctx.currentTime;

                    // ê¸°ê³„ìŒì˜ í‹±í‹± ê°™ì€ ì² ì œ ì†Œë¦¬
                    try {
                        // ì²« ë²ˆì§¸ í‹± - ì§§ê³  ë‚ ì¹´ë¡œìš´ ì†Œë¦¬
                        const osc1 = this.ctx.createOscillator();
                        const gain1 = this.ctx.createGain();
                        osc1.type = 'square'; // ê¸°ê³„ìŒ ëŠë‚Œ
                        osc1.frequency.setValueAtTime(1200, t);
                        osc1.frequency.exponentialRampToValueAtTime(800, t + 0.02);
                        gain1.gain.setValueAtTime(0.2, t);
                        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.03);
                        osc1.connect(gain1);
                        gain1.connect(this.ctx.destination);
                        osc1.start(t);
                        osc1.stop(t + 0.03);

                        // ë‘ ë²ˆì§¸ í‹± - ì•½ê°„ ì§€ì—°ëœ ë©”íƒˆë¦­ ì†Œë¦¬
                        const osc2 = this.ctx.createOscillator();
                        const gain2 = this.ctx.createGain();
                        osc2.type = 'sawtooth'; // ì² ì œ ëŠë‚Œ
                        osc2.frequency.setValueAtTime(1500, t + 0.01);
                        osc2.frequency.exponentialRampToValueAtTime(600, t + 0.04);
                        gain2.gain.setValueAtTime(0.15, t + 0.01);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc2.connect(gain2);
                        gain2.connect(this.ctx.destination);
                        osc2.start(t + 0.01);
                        osc2.stop(t + 0.05);

                        // ë©”íƒˆë¦­ ê³µëª… íš¨ê³¼
                        const osc3 = this.ctx.createOscillator();
                        const gain3 = this.ctx.createGain();
                        osc3.type = 'sine';
                        osc3.frequency.setValueAtTime(2000, t);
                        osc3.frequency.exponentialRampToValueAtTime(1000, t + 0.04);
                        gain3.gain.setValueAtTime(0.1, t);
                        gain3.gain.exponentialRampToValueAtTime(0.01, t + 0.04);
                        osc3.connect(gain3);
                        gain3.connect(this.ctx.destination);
                        osc3.start(t);
                        osc3.stop(t + 0.04);
                    } catch (e) {
                        console.warn('Dry fire sound error:', e);
                    }
                }
            },
            playBoltAction: function () {
                if (!this.ensureContext()) return;

                // ì €ê²©ì´ ë³¼íŠ¸ ì•¡ì…˜ ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš© (c-rifle.mp3), ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (this.audioBuffers['c-rifle']) {
                    this.playAudioFile('c-rifle', 0.8);
                } else {
                    // ê¸°ì¡´ ì†Œë¦¬ ìƒì„± (í´ë°±)
                    const t = this.ctx.currentTime;
                    const osc1 = this.ctx.createOscillator();
                    const gain1 = this.ctx.createGain();
                    osc1.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(150, t);
                    gain1.gain.setValueAtTime(0.2, t);
                    gain1.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc1.connect(gain1); gain1.connect(this.ctx.destination);
                    osc1.start(t); osc1.stop(t + 0.1);

                    const osc2 = this.ctx.createOscillator();
                    const gain2 = this.ctx.createGain();
                    osc2.type = 'square';
                    osc2.frequency.setValueAtTime(200, t + 0.15);
                    gain2.gain.setValueAtTime(0.2, t + 0.15);
                    gain2.gain.linearRampToValueAtTime(0, t + 0.25);
                    osc2.connect(gain2); gain2.connect(this.ctx.destination);
                    osc2.start(t + 0.15); osc2.stop(t + 0.25);
                }
            },
            playZombieAttack: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.1);
            },
            playKnife: function () {
                if (!this.ensureContext()) return;

                // ë‚˜ì´í”„ íœ˜ë‘ë¥´ê¸° ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (this.audioBuffers['sword']) {
                    this.playAudioFile('sword', 0.8);
                } else {
                    // ê¸°ì¡´ ì†Œë¦¬ ìƒì„± (í´ë°±)
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.exponentialRampToValueAtTime(100, t + 0.2);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.2);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.2);
                }
            },
            playJump: function (land) {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(land ? 0.2 : 0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playStep: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                noise.start();
            },
            playReload: function () {
                if (!this.ensureContext()) return;

                // ì˜¤ë””ì˜¤ íŒŒì¼ì´ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ì†Œë¦¬ ìƒì„±
                if (this.audioBuffers['reload']) {
                    this.playAudioFile('reload', this.reloadVolume);
                } else {
                    // ê¸°ì¡´ ì†Œë¦¬ ìƒì„± (í´ë°±)
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(); osc.stop(t + 0.1);
                }
            },
            playHeadshot: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;

                // ê¹¨ì§€ëŠ” ì†Œë¦¬ - ë…¸ì´ì¦ˆ ê¸°ë°˜
                const bufferSize = this.ctx.sampleRate * 0.15;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // ê¹¨ì§€ëŠ” ëŠë‚Œì˜ ë…¸ì´ì¦ˆ ìƒì„±
                for (let i = 0; i < bufferSize; i++) {
                    const progress = i / bufferSize;
                    // ê¹¨ì§€ëŠ” ì†Œë¦¬: ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ + ê¸‰ê²©í•œ ê°ì‡ 
                    const noise = (Math.random() * 2 - 1) * (1 - progress * 0.8);
                    // ê³ ì£¼íŒŒ ê°•ì¡°
                    const highFreq = Math.sin(progress * Math.PI * 20) * 0.3;
                    data[i] = noise * (1 - progress) + highFreq * (1 - progress);
                }

                const noiseSource = this.ctx.createBufferSource();
                noiseSource.buffer = buffer;

                // ê³ ì—­ í•„í„°ë¡œ ê¹¨ì§€ëŠ” ëŠë‚Œ ê°•ì¡°
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(2000, t);
                filter.frequency.exponentialRampToValueAtTime(800, t + 0.15);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

                noiseSource.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noiseSource.start(t);
                noiseSource.stop(t + 0.15);

                // ì¶”ê°€ ê¹¨ì§€ëŠ” ì†Œë¦¬ ë ˆì´ì–´
                const osc = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(3000, t);
                osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain2);
                gain2.connect(this.ctx.destination);
                osc.start(t);
                osc.stop(t + 0.1);
            },
            playHit: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                // í”¼ê²© ì‚¬ìš´ë“œ - ì§§ê³  ë‚ ì¹´ë¡œìš´ ì†Œë¦¬ (ë³¼ë¥¨ ì•½ê°„ ê°ì†Œ)
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'square';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(400, t + 0.05);
                gain1.gain.setValueAtTime(0.12, t); // 0.2 -> 0.12 (ë³¼ë¥¨ ê°ì†Œ)
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.08);

                // ì¶”ê°€ íƒ€ê²©ìŒ (ë³¼ë¥¨ ì•½ê°„ ê°ì†Œ)
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(200, t);
                osc2.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain2.gain.setValueAtTime(0.09, t); // 0.15 -> 0.09 (ë³¼ë¥¨ ê°ì†Œ)
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.1);
            },
            playSwitch: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                // Mechanical Clank
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.linearRampToValueAtTime(50, t + 0.15);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },
            playHealthPill: function () {
                if (!this.ensureContext()) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
                gain1.gain.setValueAtTime(0.3, t);
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc1.connect(gain1); gain1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.3);

                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(600, t);
                osc2.frequency.exponentialRampToValueAtTime(400, t + 0.2);
                gain2.gain.setValueAtTime(0.2, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.25);
                osc2.connect(gain2); gain2.connect(this.ctx.destination);
                osc2.start(); osc2.stop(t + 0.25);
            }
        };

        // ============================================
        // ë³¼ë¥¨ ì¡°ì ˆ ë°©ë²•:
        // ============================================
        // 
        // 1. ì¬ì¥ì „ ë³¼ë¥¨ ì¡°ì ˆ:
        SoundGen.reloadVolume = 0.3; // 0.0 (ë¬´ìŒ) ~ 1.0 (ìµœëŒ€)
        //
        // 2. ë§ˆìŠ¤í„° ë³¼ë¥¨ ì¡°ì ˆ (ëª¨ë“  ì˜¤ë””ì˜¤ íŒŒì¼ì— ì ìš©):
        //    SoundGen.masterVolume = 0.7; // 0.0 (ë¬´ìŒ) ~ 1.0 (ìµœëŒ€)
        //
        // 3. ë¸Œë¼ìš°ì € ì½˜ì†”ì—ì„œ ì‹¤ì‹œê°„ ì¡°ì ˆ:
        //    ê°œë°œì ë„êµ¬(F12) > Console íƒ­ì—ì„œ:
        //    SoundGen.reloadVolume = 0.3; // ì¬ì¥ì „ ì†Œë¦¬ë§Œ ì‘ê²Œ
        //    SoundGen.masterVolume = 0.5; // ëª¨ë“  ì†Œë¦¬ ì‘ê²Œ
        //
        // ============================================
        // ì™¸ë¶€ ì˜¤ë””ì˜¤ íŒŒì¼ ì‚¬ìš© ì˜ˆì‹œ:
        // ============================================
        // 
        // 1. ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ (ê²Œì„ ì‹œì‘ ì‹œ ë˜ëŠ” í•„ìš”í•  ë•Œ):
        // SoundGen.loadAudioFile('sounds/shoot.mp3', 'shootSound')
        //     .then(() => console.log('Sound loaded!'))
        //     .catch(err => console.error('Failed to load sound:', err));
        //
        // 2. ë¡œë“œëœ ì˜¤ë””ì˜¤ íŒŒì¼ ì¬ìƒ:
        // SoundGen.playAudioFile('shootSound', 0.8); // ë³¼ë¥¨ 0.8ë¡œ ì¬ìƒ
        //
        // 3. ì—¬ëŸ¬ ì˜¤ë””ì˜¤ íŒŒì¼ ë™ì‹œ ë¡œë“œ:
        // Promise.all([
        //     SoundGen.loadAudioFile('sounds/shoot.mp3', 'shoot'),
        //     SoundGen.loadAudioFile('sounds/reload.mp3', 'reload'),
        //     SoundGen.loadAudioFile('sounds/hit.mp3', 'hit')
        // ]).then(() => console.log('All sounds loaded!'));
        //
        // 4. ê¸°ì¡´ í•¨ìˆ˜ë¥¼ ì˜¤ë””ì˜¤ íŒŒì¼ë¡œ ëŒ€ì²´í•˜ë ¤ë©´:
        // playShoot: function(type) {
        //     // ê¸°ì¡´ ì½”ë“œ ëŒ€ì‹ :
        //     SoundGen.playAudioFile('shootSound', 1.0);
        // }

        // ì„±ëŠ¥ ìµœì í™”: ë¦¬ì†ŒìŠ¤ ë¡œë”© ì™„ë£Œ í›„ ì´ˆê¸°í™”
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            // ì´ë¯¸ ë¡œë“œ ì™„ë£Œë˜ì—ˆìœ¼ë©´ ë°”ë¡œ í˜¸ì¶œ
            init();
        }

        function init() {
            // UI References
            const modeSelection = document.getElementById('mode-selection');
            const nameSetup = document.getElementById('name-setup');
            const roomMenu = document.getElementById('room-menu');
            const createRoomModal = document.getElementById('create-room-modal');
            const roomWaiting = document.getElementById('room-waiting');
            const chatContainer = document.getElementById('chat-container');

            // 1. Mode Selection
            modeSelection.style.display = 'flex';

            document.getElementById('btn-single-player').addEventListener('click', () => {
                gameMode = 'single';
                modeSelection.style.display = 'none';
                startGame();
            });

            document.getElementById('btn-multi-player').addEventListener('click', () => {
                modeSelection.style.display = 'none';
                nameSetup.style.display = 'flex';
                document.getElementById('player-name-input').focus();
            });

            // 2. Name Setup
            document.getElementById('btn-back-to-mode').addEventListener('click', () => {
                nameSetup.style.display = 'none';
                modeSelection.style.display = 'flex';
            });

            document.getElementById('btn-confirm-name').addEventListener('click', () => {
                const name = document.getElementById('player-name-input').value.trim() || 'Player';
                const serverAddr = 'https://murphy-highs-cradle-acting.trycloudflare.com';

                gameMode = 'multi';
                nameSetup.style.display = 'none';
                roomMenu.style.display = 'flex'; // Show Lobby

                // Connect to Server Lobby
                if (!socket || !socket.connected) {
                    initMultiplayer(serverAddr, name);
                } else {
                    socket.emit('setIdentity', { name: name });
                }
            });

            // 3. Room Menu (Lobby)
            document.getElementById('btn-back-to-name').addEventListener('click', () => {
                roomMenu.style.display = 'none';
                nameSetup.style.display = 'flex';
                // Optional: Disconnect socket?
            });

            document.getElementById('btn-show-create-room').addEventListener('click', () => {
                createRoomModal.style.display = 'flex';
                document.getElementById('new-room-name').focus();
            });

            document.getElementById('btn-refresh-rooms').addEventListener('click', () => {
                // Server sends updates automatically, but could request manual refresh if needed
                if (socket) socket.emit('setIdentity', { name: socket.userData ? socket.userData.name : 'Player' });
            });

            // 4. Create Room Modal
            document.getElementById('btn-create-cancel').addEventListener('click', () => {
                createRoomModal.style.display = 'none';
            });

            document.getElementById('btn-create-confirm').addEventListener('click', () => {
                const roomName = document.getElementById('new-room-name').value || 'ìƒˆ ë°©';
                const maxPlayers = document.getElementById('new-room-max').value;
                const mapName = document.getElementById('new-room-map').value; // ë§µ ì •ë³´ ê°€ì ¸ì˜¤ê¸°

                if (socket && socket.connected) {
                    socket.emit('createRoom', {
                        name: roomName,
                        maxPlayers: maxPlayers,
                        map: mapName // ë§µ ì •ë³´ ì „ì†¡
                    });
                    createRoomModal.style.display = 'none';
                    // Expected to receive 'roomJoined' event
                }
            });

            // 5. Room Waiting
            document.getElementById('btn-leave-room').addEventListener('click', () => {
                if (socket && socket.connected) {
                    socket.emit('leaveRoom');
                }
                roomWaiting.style.display = 'none';
                chatContainer.style.display = 'none';
                roomMenu.style.display = 'flex';
            });

            document.getElementById('btn-start-game').addEventListener('click', () => {
                if (socket && socket.connected) {
                    socket.emit('requestStart');
                }
            });

            // Chat Input
            const chatInput = document.getElementById('chat-input');
            const sendChat = () => {
                const msg = chatInput.value.trim();
                if (msg && socket && socket.connected) {
                    socket.emit('chatMessage', { message: msg });
                    chatInput.value = '';
                }
            };
            document.getElementById('btn-send-chat').addEventListener('click', sendChat);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChat();
            });

            // Global Join Function
            window.joinRoom = function (roomId) {
                if (socket && socket.connected) {
                    socket.emit('joinRoom', roomId);
                }
            };
        }

        function initMultiplayer(addr, name) {
            try {
                // http:// í”„ë¡œí† ì½œ ê°•ì œ
                const connectionUrl = addr.startsWith('http') ? addr : `http://${addr}`;
                socket = io(connectionUrl, {
                    reconnectionAttempts: 5,
                    timeout: 10000
                });

                socket.on('connect', () => {
                    console.log('Connected to server');
                    myId = socket.id; // Assign myId on connection
                    console.log('myId set to:', myId);
                    // Send Identity
                    socket.emit('setIdentity', { name: name });
                    document.getElementById('room-waiting').querySelector('h2').innerText = 'ì—°ê²°ë¨';
                });

                socket.on('connect_error', (error) => {
                    console.error('Connection Error:', error);
                    alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨: ' + error.message);
                });

                // --- Room System Events ---

                socket.on('roomListUpdated', (rooms) => {
                    const roomListContainer = document.getElementById('room-list-container');
                    roomListContainer.innerHTML = '';

                    if (rooms.length === 0) {
                        roomListContainer.innerHTML = '<div class="no-rooms-message">ìƒì„±ëœ ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                        return;
                    }

                    rooms.forEach(room => {
                        const roomEl = document.createElement('div');
                        roomEl.className = 'room-item';
                        const statusClass = room.status === 'playing' ? 'playing' : (room.currentPlayers >= room.maxPlayers ? 'full' : 'waiting');
                        const statusText = room.status === 'playing' ? 'ê²Œì„ ì¤‘' : (room.currentPlayers >= room.maxPlayers ? 'ë§Œì›' : 'ëŒ€ê¸° ì¤‘');

                        roomEl.innerHTML = `
                            <div class="room-info">
                                <h3>${room.name}</h3>
                                <p>${room.currentPlayers}/${room.maxPlayers}ëª…</p>
                            </div>
                            <div class="room-status">
                                <span class="status-badge ${statusClass}">${statusText}</span>
                                <button onclick="joinRoom('${room.id}')" ${statusClass !== 'waiting' ? 'disabled' : ''}>ì°¸ì—¬</button>
                            </div>
                        `;
                        roomListContainer.appendChild(roomEl);
                    });
                });



                socket.on('roomJoined', (data) => {
                    // Update UI to Waiting Room
                    document.getElementById('room-menu').style.display = 'none';
                    document.getElementById('room-waiting').style.display = 'flex';
                    document.getElementById('chat-container').style.display = 'flex';

                    document.getElementById('room-title').innerText = data.roomName;

                    // Save map info
                    currentMap = data.map || 'factory';
                    console.log('Room map:', currentMap);

                    // Save own spawn position from server
                    const myData = data.players[myId];
                    if (myData && myData.position) {
                        position = new THREE.Vector3(
                            myData.position.x,
                            myData.position.y,
                            myData.position.z
                        );
                        console.log('Spawn position set from server:', position);
                    }

                    // Clear existing if scene exists
                    if (window.scene) {
                        Object.values(otherPlayersMap).forEach(mesh => scene.remove(mesh));
                    }
                    otherPlayersMap = {};
                    roomPlayersState = data.players; // Cache players

                    updateRoomPlayers(roomPlayersState);

                    // Update start button based on player count
                    updateStartButtonState(data.isHost);
                });

                socket.on('playerJoined', (player) => {
                    roomPlayersState[player.id] = player;
                    updateRoomPlayers(roomPlayersState);
                    addChatMessage('System', `${player.name}ë‹˜ì´ ì…ì¥í–ˆìŠµë‹ˆë‹¤.`, true);

                    // Update start button when player joins
                    const isHost = myId && roomPlayersState[myId];
                    if (isHost) updateStartButtonState(true);
                });

                socket.on('playerLeft', (playerId) => {
                    if (roomPlayersState[playerId]) {
                        addChatMessage('System', `${roomPlayersState[playerId].name}ë‹˜ì´ í‡´ì¥í–ˆìŠµë‹ˆë‹¤.`, true);
                        delete roomPlayersState[playerId];
                    }
                    updateRoomPlayers(roomPlayersState); // Refresh UI

                    // Update start button when player leaves
                    const isHost = myId && roomPlayersState[myId];
                    if (isHost) updateStartButtonState(true);

                    const mesh = otherPlayersMap[playerId];
                    if (mesh) {
                        if (window.scene) scene.remove(mesh);
                        delete otherPlayersMap[playerId];
                    }
                });

                socket.on('gameStart', (data) => {
                    console.log('Game Start Event Received with data:', data); // DEBUG

                    // ì„œë²„ì—ì„œ ë°›ì€ ë§µ ì •ë³´ë¡œ ì„¤ì •
                    if (data && data.map) {
                        currentMap = data.map;
                        console.log('Map set to:', currentMap);
                    }

                    document.getElementById('room-waiting').style.display = 'none';
                    document.getElementById('chat-container').style.bottom = '20px';

                    // Use spawn position from server (already set in roomJoined event)
                    // Only initialize if position is completely unset
                    if (!position) {
                        console.warn('Position not set! Using fallback (0, 1.7, 0)');
                        position = new THREE.Vector3(0, 1.7, 0);
                    }

                    camera.position.copy(position);
                    console.log('Game started at position:', position);

                    // Actual mesh creation is handled in startGame() -> createRemotePlayer
                    // This ensures scene is initialized first.

                    try {
                        console.log('About to call startCountdown...'); // DEBUG
                        startCountdown();
                        console.log('startCountdown finished (or started async)'); // DEBUG
                    } catch (e) {
                        console.error('ERROR in startCountdown:', e);
                    }
                });



                socket.on('hostChanged', (hostId) => {
                    const startBtn = document.getElementById('btn-start-game');
                    startBtn.parentElement.style.display = (hostId === myId) ? 'block' : 'none';
                    addChatMessage('System', 'ë°©ì¥ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.', true);
                });

                socket.on('currentPlayers', (players) => {
                    // Legacy support if server still sends this... but server doesn't anymore.
                });

                // Chat
                socket.on('chatMessage', (data) => {
                    addChatMessage(data.sender, data.message);
                });

                // --- Game Events ---

                socket.on('playerMoved', (p) => {
                    // Game hasn't started yet
                    if (!window.scene) return;

                    // Update roomPlayersState for spectator camera
                    if (roomPlayersState[p.id]) {
                        roomPlayersState[p.id].position = p.position;
                        roomPlayersState[p.id].rotation = p.rotation;
                    }

                    const mesh = otherPlayersMap[p.id];
                    if (mesh) {
                        // Keep player on ground (y=0), only use x and z from server
                        mesh.position.set(p.position.x, 0, p.position.z);
                        mesh.rotation.y = p.rotation.y;
                    } else {
                        // If player exists but no mesh (e.g. joined mid-game), create it
                        if (p.id !== myId) createRemotePlayer(p);
                    }
                });

                socket.on('playerActioned', (data) => {
                    if (!window.scene) return;

                    const mesh = otherPlayersMap[data.id];
                    if (mesh) {
                        if (data.action === 'shoot') {
                            SoundGen.playShoot(WEAPONS[data.weaponIdx].type);

                            // Visual shoot effect - Muzzle flash
                            const muzzleFlash = new THREE.Mesh(
                                new THREE.SphereGeometry(0.15, 8, 8),
                                new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9 })
                            );
                            // Position flash at weapon tip (front of player)
                            muzzleFlash.position.set(
                                mesh.position.x + Math.sin(mesh.rotation.y) * 0.5,
                                1.0,
                                mesh.position.z + Math.cos(mesh.rotation.y) * 0.5
                            );
                            scene.add(muzzleFlash);

                            // Remove flash after brief moment
                            setTimeout(() => {
                                scene.remove(muzzleFlash);
                            }, 100);

                            // Weapon recoil animation (find weapon child and animate)
                            const weapon = mesh.children.find(child => child.geometry && child.geometry.type === 'BoxGeometry' && child.material.color.getHex() === 0x222222);
                            if (weapon) {
                                const originalZ = weapon.position.z;
                                weapon.position.z -= 0.1; // Move back
                                setTimeout(() => {
                                    weapon.position.z = originalZ; // Return to original
                                }, 100);
                            }

                            // Upper body and arms recoil animation
                            mesh.children.forEach(child => {
                                // Find arms by geometry type (CylinderGeometry with specific size)
                                if (child.geometry && child.geometry.type === 'CylinderGeometry' &&
                                    child.material.color && child.material.color.getHex() === 0xf4a460) {
                                    // This is an arm
                                    const originalRotX = child.rotation.x;
                                    const originalPosZ = child.position.z;

                                    // Pull back and lift slightly
                                    child.rotation.x = originalRotX - 0.15;
                                    child.position.z = originalPosZ - 0.05;

                                    setTimeout(() => {
                                        child.rotation.x = originalRotX;
                                        child.position.z = originalPosZ;
                                    }, 100);
                                }

                                // Find body (CylinderGeometry with blue color)
                                if (child.geometry && child.geometry.type === 'CylinderGeometry' &&
                                    child.material.color && child.material.color.getHex() === 0x4a90e2 &&
                                    child.position.y > 1.0) { // Body is higher than legs
                                    // This is the body
                                    const originalRotX = child.rotation.x;

                                    // Tilt back slightly
                                    child.rotation.x = originalRotX - 0.08;

                                    setTimeout(() => {
                                        child.rotation.x = originalRotX;
                                    }, 100);
                                }
                            });
                        }
                    }
                });

                socket.on('playerDamaged', (data) => {
                    if (data.id === myId) {
                        playerHP = data.hp;

                        // HP UI ì—…ë°ì´íŠ¸
                        elHpBar.style.width = playerHP + '%';
                        elHpText.innerText = "HP: " + playerHP;

                        // HPì— ë”°ë¼ ìƒ‰ìƒ ë³€ê²½
                        if (playerHP > 50) {
                            elHpBar.style.background = "#4caf50"; // ë…¹ìƒ‰
                        } else if (playerHP > 20) {
                            elHpBar.style.background = "#ff9800"; // ì£¼í™©ìƒ‰
                        } else {
                            elHpBar.style.background = "#f44336"; // ë¹¨ê°„ìƒ‰
                        }

                        // í”¼ê²© íš¨ê³¼
                        elDamage.style.opacity = 0.5;
                        setTimeout(() => elDamage.style.opacity = 0, 200);
                        hitShake.intensity = 0.1;
                        SoundGen.playHit();
                    } else {
                        const mesh = otherPlayersMap[data.id];
                        if (mesh) {
                            mesh.userData.hp = data.hp;
                            if (mesh.userData.hpBar) mesh.userData.hpBar.scale.x = Math.max(0, mesh.userData.hp / 100);
                        }
                    }
                });

                socket.on('playerDied', (data) => {
                    if (data.id === myId) {
                        console.log('=== YOU DIED ===');
                        console.log('Killed by:', data.killerName, '(ID:', data.killerId, ')');
                        console.log('Current otherPlayersMap:', Object.keys(otherPlayersMap));
                        console.log('Current roomPlayersState:', Object.keys(roomPlayersState));

                        playerHP = 0;
                        isDead = true;
                        isSpectating = true;
                        spectatingPlayerId = data.killerId;

                        console.log('Set spectatingPlayerId to:', spectatingPlayerId);

                        // Hide normal game UI
                        elGameOver.style.display = 'none';
                        elDamage.style.opacity = 0.8;
                        elDamage.style.background = 'radial-gradient(circle, rgba(0,0,0,0.9) 30%, rgba(255,0,0,0.6) 100%)';

                        // Show death overlay with killer info
                        const deathOverlay = document.getElementById('death-overlay');
                        const respawnTimerEl = document.getElementById('respawn-timer');
                        const killerNameEl = document.getElementById('killer-name');

                        deathOverlay.style.display = 'flex';
                        const manualRespawnBtn = document.getElementById('manual-respawn-btn');
                        if (manualRespawnBtn) manualRespawnBtn.style.display = 'none';

                        killerNameEl.innerText = data.killerName || 'Unknown';

                        // 10-second countdown
                        let countdown = 10;
                        respawnTimerEl.innerText = countdown;

                        const countdownInterval = setInterval(() => {
                            countdown--;
                            respawnTimerEl.innerText = countdown;
                            console.log('Respawn countdown:', countdown, 'seconds remaining');
                            if (countdown <= 0) {
                                clearInterval(countdownInterval);
                                console.log('=== COUNTDOWN COMPLETE ===');

                                // Enable manual respawn button on the overlay as well
                                const respawnBtn = document.getElementById('manual-respawn-btn');
                                if (respawnBtn) {
                                    respawnBtn.style.display = 'block';
                                    respawnBtn.onclick = () => {
                                        if (socket && socket.connected) {
                                            console.log('Manual respawn requested');
                                            socket.emit('requestRespawn');
                                        }
                                    };
                                }

                                // Auto-Request respawn
                                if (socket && socket.connected) {
                                    console.log('Socket connected, sending requestRespawn...');
                                    socket.emit('requestRespawn');
                                } else {
                                    console.error('ERROR: Socket not connected! Cannot request respawn.');
                                    alert('ì„œë²„ì™€ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.');
                                }
                            }
                        }, 1000);
                    } else {
                        const mesh = otherPlayersMap[data.id];
                        if (mesh) {
                            // Death animation - Falling and fading out
                            let fallProgress = 0;
                            const fallDuration = 1000; // 1 second
                            const fallInterval = 16; // ~60fps
                            const fallSteps = fallDuration / fallInterval;

                            const originalRotation = { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z };
                            const originalScale = { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z };

                            const deathAnimation = setInterval(() => {
                                fallProgress++;
                                const progress = fallProgress / fallSteps;

                                // Rotate forward (falling motion)
                                mesh.rotation.x = originalRotation.x + (Math.PI / 2) * progress;

                                // Move down slightly
                                mesh.position.y = -0.5 * progress;

                                // Fade out all children (make transparent)
                                mesh.traverse((child) => {
                                    if (child.material) {
                                        if (!child.userData.originalOpacity) {
                                            child.userData.originalOpacity = child.material.opacity !== undefined ? child.material.opacity : 1;
                                        }
                                        child.material.transparent = true;
                                        child.material.opacity = child.userData.originalOpacity * (1 - progress);
                                    }
                                });

                                // Shrink slightly
                                const scale = 1 - (0.3 * progress);
                                mesh.scale.set(originalScale.x * scale, originalScale.y * scale, originalScale.z * scale);

                                if (fallProgress >= fallSteps) {
                                    clearInterval(deathAnimation);
                                    // Remove from scene after animation
                                    scene.remove(mesh);
                                    delete otherPlayersMap[data.id];
                                }
                            }, fallInterval);
                        }
                    }
                });

                socket.on('playerRespawned', (data) => {
                    console.log('Respawn:', data);
                    if (data.id === myId) {
                        playerHP = 100;
                        isDead = false;
                        isSpectating = false;
                        spectatingPlayerId = null;

                        // HP UI ì—…ë°ì´íŠ¸
                        elHpBar.style.width = '100%';
                        elHpText.innerText = 'HP: 100';
                        elHpBar.style.background = '#4caf50'; // ë…¹ìƒ‰

                        // Update BOTH position variable and camera
                        position.set(data.position.x, data.position.y, data.position.z);
                        camera.position.copy(position);

                        // Hide death overlay
                        document.getElementById('death-overlay').style.display = 'none';
                        elGameOver.style.display = 'none';
                        elDamage.style.opacity = 0;
                    } else {
                        // Remote player respawned - completely recreate to avoid transparent material bug
                        if (otherPlayersMap[data.id]) {
                            // Remove old mesh (might be transparent from death animation)
                            scene.remove(otherPlayersMap[data.id]);
                            delete otherPlayersMap[data.id];
                        }
                        // Create fresh player mesh
                        createRemotePlayer(data);
                    }
                });

                // Helpers
                function updateRoomPlayers(playersMap) {
                    const list = document.getElementById('players-list');
                    list.innerHTML = '';
                    document.getElementById('player-count').innerText = `${Object.keys(playersMap).length}/4`;

                    Object.values(playersMap).forEach(p => {
                        const el = document.createElement('div');
                        el.style.fontSize = '20px';
                        el.style.margin = '10px';
                        el.innerText = p.name;
                        list.appendChild(el);

                        // Also populate global or local list for 3D creation later
                        if (p.id !== myId && !otherPlayersMap[p.id]) {
                            // We don't create 3D model in lobby, but we can when game starts.
                            // For now, let's just create it on game start.
                        }
                    });
                }

                function addChatMessage(sender, msg, isSystem) {
                    const chatMessages = document.getElementById('chat-messages');
                    const msgEl = document.createElement('div');
                    msgEl.className = 'chat-msg' + (isSystem ? ' system' : '');
                    msgEl.innerHTML = `<span class="sender">${sender}:</span> ${msg}`;
                    chatMessages.appendChild(msgEl);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }

                function updateStartButtonState(isHost) {
                    const startBtn = document.getElementById('btn-start-game');
                    if (!startBtn || !startBtn.parentElement) return;

                    const playerCount = Object.keys(roomPlayersState).length;

                    if (isHost) {
                        startBtn.parentElement.style.display = 'block';
                        if (playerCount >= 2) {
                            startBtn.disabled = false;
                            startBtn.style.opacity = '1';
                            startBtn.style.cursor = 'pointer';
                            startBtn.title = '';
                        } else {
                            startBtn.disabled = true;
                            startBtn.style.opacity = '0.5';
                            startBtn.style.cursor = 'not-allowed';
                            startBtn.title = 'ìµœì†Œ 2ëª…ì˜ í”Œë ˆì´ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤';
                        }
                    } else {
                        startBtn.parentElement.style.display = 'none';
                    }
                }

            } catch (e) {
                console.error('Socket init error:', e);
            }
        }

        function createRemotePlayer(p) {
            console.log('createRemotePlayer called for:', p); // DEBUG

            // Create materials inside function to avoid scope issues
            const matPlayerBody = new THREE.MeshStandardMaterial({
                color: 0x4a90e2,
                roughness: 0.4,
                metalness: 0.6,
                emissive: 0x1a3052,
                emissiveIntensity: 0.6
            });

            const matPlayerSkin = new THREE.MeshStandardMaterial({
                color: 0xf4a460,
                roughness: 0.7,
                emissive: 0x543410,
                emissiveIntensity: 0.4
            });

            const matHpBg = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const matHpFg = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            const group = new THREE.Group();

            // More realistic player model with rounded shapes
            // IMPORTANT: All Y positions are relative to group, which is placed at y=0 (ground level)
            // Legs start at y=0 (feet on ground), body/head/arms positioned accordingly

            // Legs (feet at y=0, extending upward)
            const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.7, 8);
            const leftLeg = new THREE.Mesh(legGeo, matPlayerBody);
            leftLeg.position.set(-0.15, 0.35, 0); // Center at 0.35 so bottom is at 0
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, matPlayerBody);
            rightLeg.position.set(0.15, 0.35, 0);
            group.add(rightLeg);

            // Body - starts at top of legs
            const bodyGeo = new THREE.CylinderGeometry(0.25, 0.25, 1.0, 12);
            const body = new THREE.Mesh(bodyGeo, matPlayerBody);
            body.position.y = 1.2; // Legs end at 0.7, body center at 1.2
            group.add(body);

            // Shoulders (rounded)
            const shoulderGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const leftShoulder = new THREE.Mesh(shoulderGeo, matPlayerBody);
            leftShoulder.position.set(-0.3, 1.6, 0);
            group.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, matPlayerBody);
            rightShoulder.position.set(0.3, 1.6, 0);
            group.add(rightShoulder);

            // Head - Sphere for more realistic look
            const headGeo = new THREE.SphereGeometry(0.22, 12, 12);
            const head = new THREE.Mesh(headGeo, matPlayerSkin);
            head.position.y = 2.0; // Eye level ~2.0 from ground
            head.name = 'head';
            group.add(head);
            group.userData.head = head;

            // Arms with weapon
            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8);
            const leftArm = new THREE.Mesh(armGeo, matPlayerSkin);
            leftArm.position.set(-0.35, 1.4, 0.2); // Adjusted for new body height
            leftArm.rotation.z = 0.3; // Angled to hold weapon
            leftArm.rotation.x = -0.5;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeo, matPlayerSkin);
            rightArm.position.set(0.35, 1.4, 0.2); // Adjusted for new body height
            rightArm.rotation.z = -0.3; // Angled to hold weapon
            rightArm.rotation.x = -0.5;
            group.add(rightArm);

            // Simple weapon model (rifle-like)
            const weaponGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
            const matWeapon = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 });
            const weapon = new THREE.Mesh(weaponGeo, matWeapon);
            weapon.position.set(0.15, 1.3, 0.4); // Adjusted for new body height
            weapon.rotation.x = -0.3;
            group.add(weapon); // Add weapon to group

            // Directional indicator - Helmet/Visor on front of head
            const visorGeo = new THREE.BoxGeometry(0.18, 0.08, 0.05);
            const matVisor = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.2 });
            const visor = new THREE.Mesh(visorGeo, matVisor);
            visor.position.set(0, 2.05, 0.15); // Front of head (adjusted for new height)
            group.add(visor);

            // Face marker - small colored cube to show front clearly
            const faceMarkerGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);
            const matFaceMarker = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
            const faceMarker = new THREE.Mesh(faceMarkerGeo, matFaceMarker);
            faceMarker.position.set(0, 1.9, 0.2); // Lower front of head (adjusted for new height)
            group.add(faceMarker);


            // HP Bar (slightly higher to account for new model)
            const hpBg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.1), matHpBg);
            hpBg.position.y = 2.3; // Above head
            hpBg.visible = false; // Hide HP bar in multiplayer
            group.add(hpBg);
            const hpFg = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.1), matHpFg);
            hpFg.position.y = 2.3; // Above head
            hpFg.position.z = 0.01;
            hpFg.visible = false; // Hide HP bar in multiplayer
            group.add(hpFg);

            group.userData.hp = p.hp || 100;
            group.userData.maxHp = 100;
            group.userData.hpBar = hpFg;
            group.userData.playerId = p.id;

            // Ensure scene exists before adding
            if (window.scene) {
                console.log('Adding player mesh to scene:', p.id, 'at position:', p.position); // DEBUG
                // Position on ground (y = 0 is floor level)
                group.position.set(p.position.x, 0, p.position.z);
                console.log('Player actual position in scene:', group.position); // DEBUG
                console.log('Camera position:', camera.position); // DEBUG
                scene.add(group);
                otherPlayersMap[p.id] = group;
                if (typeof otherPlayers !== 'undefined') otherPlayers.push(group);
                console.log('Player mesh added successfully. Total children in group:', group.children.length); // DEBUG
            } else {
                console.error('Window.scene is missing in createRemotePlayer!'); // DEBUG
            }
        }

        // ë°”ë¡œ ì‹œì‘í•˜ê¸° (Legacy code - Force Start handled by Host Controls now)
        const btnForceStart = document.getElementById('btn-force-start');
        if (btnForceStart) {
            btnForceStart.addEventListener('click', () => {
                if (socket && socket.connected) {
                    socket.emit('requestStart');
                }
            });
        }

        // ë°© ë‚˜ê°€ê¸°
        document.getElementById('btn-leave-room').addEventListener('click', () => {
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            roomWaiting.style.display = 'none';
            modeSelection.style.display = 'flex';
            gameMode = null;
            isRoomHost = false;
            currentPlayers = 1;
            playersList = [];
            document.getElementById('countdown').style.display = 'none';
        });

        // UI ìš”ì†Œ ì´ˆê¸°í™” (DOMì´ ë¡œë“œëœ í›„)
        elAmmoVal = document.getElementById('ammo-val');
        elWeaponLabel = document.getElementById('weapon-label');
        elCrosshair = document.getElementById('crosshair');
        elVignette = document.getElementById('vignette');
        elScope = document.getElementById('scope-overlay');
        elHpBar = document.getElementById('hp-bar');
        elHpText = document.getElementById('hp-text');
        elDamage = document.getElementById('damage-overlay');
        elPlayTime = document.getElementById('play-time');
        elKillCount = document.getElementById('kill-count');
        elGameOver = document.getElementById('game-over');
        elPauseOverlay = document.getElementById('pause-overlay');
        elHeadshot = document.getElementById('headshot-msg');
        elHitMarker = document.getElementById('hit-marker');

        // Restart button - Add mobile touch support
        const restartBtn = document.getElementById('restart-btn');
        if (restartBtn) {
            const restartGame = () => {
                location.reload();
            };
            restartBtn.addEventListener('click', restartGame);
            // Mobile touch support
            restartBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            restartBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                restartGame();
            });
        }

        scene = new THREE.Scene();

        // ë§µì— ë”°ë¼ ë‹¤ë¥¸ ë°°ê²½/ì•ˆê°œ ì„¤ì •
        // ì‹±ê¸€ í”Œë ˆì´ì–´ëŠ” í•­ìƒ factory ì¡°ëª…
        if (gameMode === 'multi' && currentMap === 'hotel') {
            // í˜¸í…”: ë°ì€ ë°°ê²½ (ë©€í‹° í”Œë ˆì´ì–´ë§Œ)
            const hotelBgColor = 0xf5f5f0;
            scene.background = new THREE.Color(hotelBgColor);
            scene.fog = new THREE.FogExp2(hotelBgColor, 0.01); // ì—°í•œ ì•ˆê°œ
        } else {
            // Factory: ë°ê²Œ ì¡°ì •ëœ ë°°ê²½ (ì‹±ê¸€ + ë©€í‹° factory)
            const fogColor = 0x2a3540; // ì–´ë‘ìš´ ì²­íšŒìƒ‰ -> ë°ì€ ì²­íšŒìƒ‰
            scene.background = new THREE.Color(fogColor);
            scene.fog = new THREE.FogExp2(fogColor, 0.02); // ì•ˆê°œ ë°€ë„ ê°ì†Œ
        }

        // ì´ˆê¸° ì¹´ë©”ë¼ ì„¤ì • (ëª¨ë°”ì¼ ê°€ë¡œ ëª¨ë“œ ëŒ€ì‘)
        let initAspect = window.innerWidth / window.innerHeight;
        if (window.visualViewport) {
            initAspect = window.visualViewport.width / window.visualViewport.height;
        }
        camera = new THREE.PerspectiveCamera(70, initAspect, 0.005, 1000);

        // ë§µì— ë”°ë¼ ë‹¤ë¥¸ ì¡°ëª… ì„¤ì •
        // ì‹±ê¸€ í”Œë ˆì´ì–´ëŠ” í•­ìƒ factory ì¡°ëª…
        if (gameMode === 'multi' && currentMap === 'hotel') {
            // í˜¸í…”: ë°ì€ ì¡°ëª… (ë©€í‹° í”Œë ˆì´ì–´ë§Œ)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // ë” ë°ê²Œ
            scene.add(ambientLight);

            // ì²œì¥ ì¡°ëª… ì—¬ëŸ¬ ê°œ
            const hotelLights = [
                { x: 0, z: -25 },
                { x: 0, z: 0 },
                { x: 0, z: 25 },
                { x: -20, z: 0 },
                { x: 20, z: 0 }
            ];

            hotelLights.forEach(pos => {
                const light = new THREE.PointLight(0xffffee, 1.5, 30);
                light.position.set(pos.x, 8, pos.z);
                light.castShadow = true;
                scene.add(light);
            });
        } else {
            // Factory: ë°ê²Œ ì¡°ì •ëœ ì¡°ëª… (ì‹±ê¸€ + ë©€í‹° factory)
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 0.4 -> 0.6ìœ¼ë¡œ ì¦ê°€
            scene.add(ambientLight);

            ceilingLight = new THREE.PointLight(0xffaa00, 0.8, 25);
            ceilingLight.position.set(0, 15, 0);
            ceilingLight.castShadow = true;
            ceilingLight.visible = false; // ì´ˆê¸°ì—ëŠ” êº¼ì ¸ìˆìŒ
            scene.add(ceilingLight);

            const blueLight = new THREE.DirectionalLight(0x4455ff, 0.7); // 0.5 -> 0.7ë¡œ ì¦ê°€
            blueLight.position.set(-10, 5, -10);
            scene.add(blueLight);
        }

        // í™•ì¥ ê¸°ëŠ¥ ì´ˆê¸°í™” (ë§µ ìƒì„± ì „ì— í…ìŠ¤ì²˜ ì‹œìŠ¤í…œì„ ë¨¼ì € ì´ˆê¸°í™”)
        try {
            initTextureSystem();
            initModelLoader();
            initPhysics();
        } catch (error) {
            console.warn('Some extension features failed to initialize:', error);
        }

        // ë§µ ì„ íƒì— ë”°ë¼ ë§µ ìƒì„± (ë©€í‹°ê°€ ì•„ë‹ˆë©´ factory ìƒì„±)
        if (gameMode !== 'multi') {
            createFactoryMap(); // ì‹±ê¸€ í”Œë ˆì´ì–´ ë˜ëŠ” ì´ˆê¸° ë¡œë“œ ì‹œ
        }
        // ë©€í‹°í”Œë ˆì´ì–´ëŠ” gameStart ì´ë²¤íŠ¸ì—ì„œ currentMap ì„¤ì • í›„ startGameì—ì„œ ë§µ ìƒì„±



        weaponContainer = new THREE.Group();
        scene.add(weaponContainer);
        weaponModel = new THREE.Group();
        weaponContainer.add(weaponModel);

        shellGeo = new THREE.CylinderGeometry(0.005, 0.005, 0.025, 6);
        shellGeo.rotateX(Math.PI / 2);
        shellMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.3 });

        buildWeapon(0);
        updateUI();

        // ê²Œì„ ì‹œì‘ ì‹œê°„ ì„¤ì •
        gameStartTime = performance.now();
        killCount = 0;
        playTime = 0;
        if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
        if (elKillCount) elKillCount.innerText = "Kills: 0";

        // ì  ìƒì„±ì€ startGame()ì—ì„œ ì²˜ë¦¬

        // ì„±ëŠ¥ ìµœì í™”: ë Œë”ëŸ¬ ì„¤ì •
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance" // ê³ ì„±ëŠ¥ ëª¨ë“œ
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // ëª¨ë°”ì¼ ì„±ëŠ¥ ìµœì í™”: í”½ì…€ ë¹„ìœ¨ ì¡°ì •
        const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2);
        renderer.setPixelRatio(pixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = false; // ì„±ëŠ¥ í–¥ìƒ
        renderer.shadowMap.needsUpdate = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // í›„ì²˜ë¦¬ íš¨ê³¼ ì´ˆê¸°í™” (í™œì„±í™”)
        try {
            initPostProcessing();
        } catch (error) {
            console.warn('Post-processing initialization failed:', error);
            usePostProcessing = false;
        }

        // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ëŠ” init() ëë¶€ë¶„ì—ì„œ ë³„ë„ë¡œ ì²˜ë¦¬ (ì¤‘ë³µ ë°©ì§€)
        document.addEventListener('contextmenu', e => e.preventDefault());

        const loadAudioFiles = () => {
            if (!SoundGen.ctx) SoundGen.init();
            if (SoundGen.ctx.state === 'suspended') SoundGen.ctx.resume();

            // ì¬ì¥ì „ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('reload1.mp3', 'reload')
                .catch(err => console.warn('Failed to load reload sound:', err));

            // ì €ê²©ì´ ë°œì‚¬ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('rifle.mp3', 'rifle')
                .catch(err => console.warn('Failed to load rifle sound:', err));

            // ë‚˜ì´í”„ íœ˜ë‘ë¥´ê¸° ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('sword.mp3', 'sword')
                .catch(err => console.warn('Failed to load sword sound:', err));

            // ë‚˜ì´í”„ êµì²´ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('c-sword.mp3', 'c-sword')
                .catch(err => console.warn('Failed to load c-sword sound:', err));

            // ì†Œì´ êµì²´ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('c-sochong.mp3', 'c-sochong')
                .catch(err => console.warn('Failed to load c-sochong sound:', err));

            // ê¶Œì´ êµì²´ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('c-gun.mp3', 'c-gun')
                .catch(err => console.warn('Failed to load c-gun sound:', err));

            // ì €ê²©ì´ êµì²´ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('c-rifle.mp3', 'c-rifle')
                .catch(err => console.warn('Failed to load c-rifle sound:', err));

            // ë¹ˆ ê²©ë°œ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('empty.mp3', 'empty')
                .catch(err => console.warn('Failed to load empty sound:', err));

            // ê¶Œì´ ë°œì‚¬ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
            SoundGen.loadAudioFile('gunshot.mp3', 'gunshot')
                .catch(err => console.warn('Failed to load gunshot sound:', err));
        };

        // ë°ìŠ¤í¬í†±ê³¼ ëª¨ë°”ì¼ ëª¨ë‘ì—ì„œ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ
        document.body.addEventListener('mousedown', loadAudioFiles, { once: true });
        document.body.addEventListener('touchstart', loadAudioFiles, { once: true });

        document.getElementById('restart-btn').addEventListener('click', restartGame);

        // ì¡°ëª… í† ê¸€ ë²„íŠ¼ ì´ë²¤íŠ¸
        const lightToggleBtn = document.getElementById('light-toggle-btn');
        if (lightToggleBtn) {
            const toggleLight = () => {
                if (ceilingLight && ambientLight) {
                    ceilingLight.visible = !ceilingLight.visible;
                    if (ceilingLight.visible) {
                        // ì¡°ëª… ì¼¤ ë•Œ ë” ë°ê²Œ
                        ceilingLight.intensity = 2.5;
                        ambientLight.intensity = 0.7;
                    } else {
                        // ì¡°ëª… ëŒ ë•Œ ì›ë˜ëŒ€ë¡œ
                        ceilingLight.intensity = 2.0;
                        ambientLight.intensity = 0.4;
                    }
                    lightToggleBtn.classList.toggle('active', ceilingLight.visible);
                }
            };
            lightToggleBtn.addEventListener('click', toggleLight);
            lightToggleBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleLight();
            }, { passive: false });
        }

        // setupControlsì™€ animateëŠ” startGame()ì—ì„œ í˜¸ì¶œë¨

        // í™”ë©´ íšŒì „ ê°ì§€ ë° ë ˆì´ì•„ì›ƒ ì¡°ì •
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                onResize();
                // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìœ„ì¹˜ ì¬ì¡°ì • (í•„ìš”ì‹œ ì¶”ê°€)
            }, 300); // ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸°
        });

        // visualViewport ë³€ê²½ ê°ì§€ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ í‘œì‹œ/ìˆ¨ê¹€)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                onResize();
            });
            window.visualViewport.addEventListener('scroll', () => {
                // ìŠ¤í¬ë¡¤ ë°©ì§€
                window.scrollTo(0, 0);
            });
        }

        // ì¶”ê°€ ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ëŒ€ì‘)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                onResize();
            }, 100);
        });



        // --- ê²Œì„ ì¬ì‹œì‘ í•¨ìˆ˜ ---
        function restartGame() {
            console.log('restartGame() called');

            // ê²Œì„ ì˜¤ë²„ í™”ë©´ ìˆ¨ê¹€
            const elGameOver = document.getElementById('game-over');
            if (elGameOver) elGameOver.style.display = 'none';

            // ë°ìŠ¤ ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
            const deathOverlay = document.getElementById('death-overlay');
            if (deathOverlay) deathOverlay.style.display = 'none';

            // í”¼ê²© íš¨ê³¼ ì œê±°
            const elDamage = document.getElementById('damage-overlay');
            if (elDamage) elDamage.style.opacity = 0;

            // í”Œë ˆì´ì–´ ìƒíƒœ ì´ˆê¸°í™”
            isDead = false;
            playerHP = 100;

            // í˜¼ìí•˜ê¸° ëª¨ë“œ: ëª¨ë“œ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            if (gameMode === 'single') {
                // ëª¨ë“œ ì„ íƒ í™”ë©´ í‘œì‹œ
                const modeSelection = document.getElementById('mode-selection');
                if (modeSelection) modeSelection.style.display = 'flex';

                // ì  ì œê±°
                enemies.forEach(e => scene.remove(e));
                enemies = [];

                // ì²´ë ¥ íšŒë³µ ì•„ì´í…œ ì œê±°
                healthPills.forEach(pill => scene.remove(pill));
                healthPills = [];

                console.log('Returned to mode selection screen');
            }
            // ë©€í‹°í”Œë ˆì´ì–´ ëª¨ë“œ: ëŒ€ê¸°ì‹¤ë¡œ ëŒì•„ê°€ê¸°
            else if (gameMode === 'multi') {
                const roomWaiting = document.getElementById('room-waiting');
                if (roomWaiting) roomWaiting.style.display = 'flex';

                // ë¦¬ìŠ¤í° ìš”ì²­
                if (socket && socket.connected) {
                    socket.emit('requestRespawn');
                }
            }
        }

        // --- ê²Œì„ ì‹œì‘ ì¹´ìš´íŠ¸ë‹¤ìš´ ---
        function startCountdown() {
            console.log('startCountdown() called'); // DEBUG
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            let count = 5;
            countdownEl.innerText = count;

            const interval = setInterval(() => {
                count--;
                console.log('Countdown:', count); // DEBUG
                if (count > 0) {
                    countdownEl.innerText = count;
                } else if (count === 0) {
                    countdownEl.innerText = 'GO!';
                } else {
                    clearInterval(interval);
                    countdownEl.style.display = 'none';
                    console.log('Calling startGame()...'); // DEBUG
                    startGame();
                }
            }, 1000);
        }

        // --- ê²Œì„ ì‹œì‘ í•¨ìˆ˜ ---
        function startGame() {
            console.log('startGame() CALLED'); // DEBUG

            // ì „ì²´í™”ë©´ ìš”ì²­ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ìˆ¨ê¹€)
            enterFullscreen();

            // 0. ê²Œì„ í†µê³„ ì´ˆê¸°í™”
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
            if (elKillCount) elKillCount.innerText = "Kills: 0";

            // HP Bar Reset
            if (elHpBar) {
                elHpBar.style.width = '100%';
                elHpBar.style.background = '#4caf50'; // Reset color
                elHpText.innerText = "HP: 100";
            }

            // 1. ì—”ì§„ ì´ˆê¸°í™”
            initGame();

            // Show light toggle button during gameplay
            const lightToggleBtn = document.getElementById('light-toggle-btn');
            if (lightToggleBtn) {
                lightToggleBtn.style.display = 'flex';
            }

            // 1.5. ë©€í‹°í”Œë ˆì´ì–´ ë§µ ìƒì„± (currentMapì€ gameStart ì´ë²¤íŠ¸ì—ì„œ ì„¤ì •ë¨)
            if (gameMode === 'multi') {
                console.log('Creating map for multiplayer:', currentMap);
                if (currentMap === 'hotel') {
                    createHotelMap();
                } else {
                    createFactoryMap(); // ê¸°ë³¸ê°’
                }
            }

            // 2. ë£¸ì— ìˆëŠ” ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë©”ì‹œ ìƒì„±
            // (ê²Œì„ ì‹œì‘ ì‹œì ì— ë¡œë¹„ì— ìˆë˜ í”Œë ˆì´ì–´ë“¤ì„ 3D ì”¬ì— ì¶”ê°€)
            console.log('startGame: Creating meshes for remote players...', roomPlayersState);
            if (roomPlayersState && window.scene) {
                Object.values(roomPlayersState).forEach(p => {
                    if (p.id !== myId && !otherPlayersMap[p.id]) {
                        createRemotePlayer(p);
                    }
                });
            }

            // 2.5. í˜¼ìí•˜ê¸° ëª¨ë“œì¼ ë•Œ ì  ìƒì„±
            if (gameMode === 'single') {
                for (let i = 0; i < 6; i++) createEnemyAI();
            }

            // 3. ì»¨íŠ¸ë¡¤ ì„¤ì •
            setupControls();
            setupSensitivityControl();

            // 4. ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘
            if (typeof animate === 'function') {
                animate();
            } else {
                console.error('animate function not found!');
            }
        }

        // --- ì£¼ìš” ì´ˆê¸°í™” (3D/ì—”ì§„ ë“±) ---
        function initGame() {
            // ì´ë¯¸ ì´ˆê¸°í™”ë˜ì—ˆìœ¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            if (scene) {
                // Ensure window.scene is set even if scene already exists
                if (!window.scene) window.scene = scene;
                console.log("Game engine already initialized, skipping re-init");
                return;
            }

            console.log("Initializing Game Engine...");

            // 1) ì”¬ ìƒì„±
            scene = new THREE.Scene();
            window.scene = scene; // Expose globally for checks
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 150); // Extended fog for larger map

            // 2) ì¹´ë©”ë¼ ìƒì„± (FOV 75, í™”ë©´ë¹„, near 0.1, far 1000)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // 3) ì˜¤ë””ì˜¤ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ (SoundGenì—ì„œ ì‚¬ìš©)
            listener = new THREE.AudioListener();
            camera.add(listener);

            // 4) ë Œë”ëŸ¬ ìƒì„±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 5) ì¡°ëª… ì¶”ê°€
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 50, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 6) ë§µ ìƒì„± & 7) í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            // (ê¸°ì¡´ ì½”ë“œì— ì˜ì¡´í•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ê°„ë‹¨íˆ ìƒì„±)
            createMap();
            initPlayer();

            // í…ìŠ¤ì²˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ê¸°ì¡´ í•¨ìˆ˜ í˜¸ì¶œ)
            initTextureSystem();
            initDecalSystem();
            initParticles();

            // 9) ë§ˆìš°ìŠ¤ ë½ ì´ë²¤íŠ¸ ì—°ê²°
            document.addEventListener('pointerlockchange', () => {
                isPaused = !document.pointerLockElement;
                const menu = document.getElementById('menu');
                if (menu) menu.style.display = isPaused ? 'flex' : 'none';
            });

            window.addEventListener('resize', onResize, false);
        }

        function createMap() {
            // ë°”ë‹¥
            const floorGeo = new THREE.PlaneGeometry(100, 100);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // ë²½ (ì„ì‹œ)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            for (let i = 0; i < 10; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set((Math.random() - 0.5) * 40, 0.5, (Math.random() - 0.5) * 40);
                scene.add(box);
            }
        }

        function initPlayer() {
            camera.position.set(0, 1.6, 5);
            weaponContainer = new THREE.Group();
            camera.add(weaponContainer);
            scene.add(camera);

            // ë¬´ê¸° ëª¨ë¸ (ê°„ë‹¨)
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            weaponModel = new THREE.Mesh(geo, mat);
            weaponModel.position.set(0.2, -0.2, -0.4);
            weaponContainer.add(weaponModel);
        }

        function initDecalSystem() {
            // ë°ì¹¼ í—¬í¼ ì´ˆê¸°í™” (í•„ìš”ì‹œ)
        }

        function initParticles() {
            // íŒŒí‹°í´ ì´ˆê¸°í™” (ë°°ì—´ ìƒì„± ë“±)
            particles = [];
            shells = [];
            healthPills = [];
        }

        // --- í…ìŠ¤ì²˜ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ---
        function initTextureSystem() {

            // Canvasë¥¼ ì‚¬ìš©í•œ ê°„ë‹¨í•œ í…ìŠ¤ì²˜ ìƒì„±
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // ì½˜í¬ë¦¬íŠ¸ í…ìŠ¤ì²˜ íŒ¨í„´
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.3)`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
            }
            window.concreteTexture = new THREE.CanvasTexture(canvas);
            window.concreteTexture.wrapS = THREE.RepeatWrapping;
            window.concreteTexture.wrapT = THREE.RepeatWrapping;
            window.concreteTexture.repeat.set(4, 4);

            // ë©”íƒˆ í…ìŠ¤ì²˜ íŒ¨í„´
            const metalCanvas = document.createElement('canvas');
            metalCanvas.width = 256;
            metalCanvas.height = 256;
            const metalCtx = metalCanvas.getContext('2d');
            const gradient = metalCtx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#556677');
            gradient.addColorStop(0.5, '#778899');
            gradient.addColorStop(1, '#445566');
            metalCtx.fillStyle = gradient;
            metalCtx.fillRect(0, 0, 256, 256);
            window.metalTexture = new THREE.CanvasTexture(metalCanvas);
            window.metalTexture.wrapS = THREE.RepeatWrapping;
            window.metalTexture.wrapT = THREE.RepeatWrapping;
        }

        // --- 3D ëª¨ë¸ ë¡œë” ì´ˆê¸°í™” (GLTF íŒŒì¼ ë¡œë”©) ---
        function initModelLoader() {
            // GLTFLoaderëŠ” Three.js ì˜ˆì œ íŒŒì¼ì´ í•„ìš”í•˜ì§€ë§Œ,
            // ê¸°ë³¸ êµ¬ì¡°ì™€ ì‚¬ìš©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤.

            // ì‚¬ìš© ì˜ˆì œ:
            // 1. Three.js examples í´ë”ì—ì„œ GLTFLoader.js ë‹¤ìš´ë¡œë“œ
            // 2. ë¡œì»¬ íŒŒì¼ë¡œ ì¶”ê°€: script íƒœê·¸ë¡œ GLTFLoader.js í¬í•¨
            // 3. loadGLTFModel('model.gltf', (model) => { scene.add(model); });

            console.log('Model loader system ready (GLTFLoader.js file required)');
        }

        // --- 3D ëª¨ë¸ ë¡œë“œ í•¨ìˆ˜ ---
        function loadGLTFModel(url, callback, onError) {
            // GLTFLoader ì‚¬ìš© ì˜ˆì œ í•¨ìˆ˜
            // ì‹¤ì œ ì‚¬ìš©í•˜ë ¤ë©´ GLTFLoader.js íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤

            if (typeof THREE.GLTFLoader !== 'undefined') {
                if (!gltfLoader) {
                    gltfLoader = new THREE.GLTFLoader();
                }
                gltfLoader.load(
                    url,
                    (gltf) => {
                        callback(gltf.scene);
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading GLTF model:', error);
                        if (onError) onError(error);
                    }
                );
            } else {
                console.warn('GLTFLoader not available. Please include GLTFLoader.js');
                if (onError) onError(new Error('GLTFLoader not available'));
            }
        }

        // --- ì ˆì°¨ì  3D ëª¨ë¸ ìƒì„± í•¨ìˆ˜ (GLTF ì—†ì´ ì‚¬ìš© ê°€ëŠ¥) ---
        function createProceduralModel(type, options = {}) {
            // GLTF íŒŒì¼ ì—†ì´ ì ˆì°¨ì ìœ¼ë¡œ ëª¨ë¸ì„ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
            const group = new THREE.Group();

            switch (type) {
                case 'crate':
                    const size = options.size || 1;
                    const crateGeo = new THREE.BoxGeometry(size, size, size);
                    const crateMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x8B4513,
                        roughness: 0.8
                    });
                    const crate = new THREE.Mesh(crateGeo, crateMat);
                    group.add(crate);
                    break;

                case 'barrel':
                    const radius = options.radius || 0.5;
                    const height = options.height || 1;
                    const barrelGeo = new THREE.CylinderGeometry(radius, radius, height, 16);
                    const barrelMat = new THREE.MeshStandardMaterial({
                        color: options.color || 0x654321,
                        roughness: 0.7
                    });
                    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                    group.add(barrel);
                    break;
            }

            return group;
        }

        // --- ê°„ë‹¨í•œ ë¬¼ë¦¬ ì—”ì§„ êµ¬í˜„ (ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´) ---
        const physicsBodies = []; // ë¬¼ë¦¬ ë°”ë”” ë°°ì—´

        function initPhysics() {
            // ê°„ë‹¨í•œ ë¬¼ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            physicsWorld = {
                gravity: new THREE.Vector3(0, -9.82, 0),
                bodies: []
            };
            usePhysics = true;
            console.log('Simple physics system initialized');
        }

        // --- ë¬¼ë¦¬ ë°”ë”” ìƒì„± í•¨ìˆ˜ ---
        function createPhysicsBody(mesh, mass = 1, useGravity = true) {
            if (!usePhysics) return null;

            const body = {
                mesh: mesh,
                velocity: new THREE.Vector3(0, 0, 0),
                mass: mass,
                useGravity: useGravity,
                position: mesh.position.clone(),
                active: true
            };

            physicsWorld.bodies.push(body);
            return body;
        }

        // --- ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ---
        function updatePhysics(dt) {
            if (!usePhysics || !physicsWorld) return;

            for (let i = 0; i < physicsWorld.bodies.length; i++) {
                const body = physicsWorld.bodies[i];
                if (!body.active) continue;

                // ì¤‘ë ¥ ì ìš©
                if (body.useGravity && body.mass > 0) {
                    body.velocity.y += physicsWorld.gravity.y * dt;
                }

                // ì†ë„ë¡œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                body.position.x += body.velocity.x * dt;
                body.position.y += body.velocity.y * dt;
                body.position.z += body.velocity.z * dt;

                // ë©”ì‹œ ìœ„ì¹˜ ë™ê¸°í™”
                body.mesh.position.copy(body.position);

                // ë°”ë‹¥ ì¶©ëŒ (ê°„ë‹¨í•œ ì˜ˆì œ)
                if (body.position.y < 0.5) {
                    body.position.y = 0.5;
                    body.velocity.y = 0;
                }

                // ê³µê¸° ì €í•­
                body.velocity.multiplyScalar(0.98);
            }
        }

        // --- ê°„ë‹¨í•œ í›„ì²˜ë¦¬ íš¨ê³¼ êµ¬í˜„ (WebGL ì‰ì´ë” ì‚¬ìš©) ---
        // let postProcessingCanvas, postProcessingCtx; // Moved to global

        // let postProcessingEnabled = false; // Moved to global

        function initPostProcessing() {
            try {
                // Canvasë¥¼ ì‚¬ìš©í•œ ê°„ë‹¨í•œ í›„ì²˜ë¦¬ íš¨ê³¼
                postProcessingCanvas = document.createElement('canvas');
                postProcessingCanvas.width = window.innerWidth;
                postProcessingCanvas.height = window.innerHeight;
                postProcessingCtx = postProcessingCanvas.getContext('2d');

                // í›„ì²˜ë¦¬ íš¨ê³¼ ë³€ìˆ˜ (ê²Œì„ ë¶„ìœ„ê¸°ì— ë§ê²Œ ì¡°ì •)
                window.postProcessingEffects = {
                    brightness: 1.1,      // ì•½ê°„ ë°ê²Œ
                    contrast: 1.05,       // ì•½ê°„ ëŒ€ë¹„ ì¦ê°€
                    saturation: 1.1,     // ì•½ê°„ ì±„ë„ ì¦ê°€
                    vignette: 0.2        // ì•½í•œ ë¹„ë„¤íŒ… íš¨ê³¼
                };

                usePostProcessing = true;
                postProcessingEnabled = true;
                console.log('Post-processing system initialized with enhanced quality');
            } catch (error) {
                console.warn('Post-processing initialization failed:', error);
                usePostProcessing = false;
            }
        }

        // --- í›„ì²˜ë¦¬ íš¨ê³¼ ì ìš© í•¨ìˆ˜ ---
        function applyPostProcessing() {
            if (!usePostProcessing || !postProcessingEnabled) return;

            const effects = window.postProcessingEffects;
            if (!effects) return;

            // ì „ì²´ ì¥ë©´ì˜ ë°ê¸° ì¡°ì • (ë” ë¶€ë“œëŸ¬ìš´ íš¨ê³¼)
            scene.traverse((object) => {
                if (object.isMesh && object.material) {
                    // emissiveë¥¼ ì‚¬ìš©í•œ ê°„ì ‘ì ì¸ ë°ê¸° ì¡°ì •
                    if (object.material.emissive && effects.brightness !== 1.0) {
                        const baseEmissive = object.userData.baseEmissive || new THREE.Color(0x000000);
                        if (!object.userData.baseEmissive) {
                            object.userData.baseEmissive = object.material.emissive.clone();
                        }
                        object.material.emissive.copy(baseEmissive).multiplyScalar(effects.brightness * 0.1);
                    }
                }
            });
        }

        // --- Map with Collision ---
        function createFactoryMap() {
            colliders = []; // Init array

            // í…ìŠ¤ì²˜ ì ìš© (ì ˆì°¨ì  ìƒì„±ëœ í…ìŠ¤ì²˜ ì‚¬ìš©)
            const matConcrete = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                map: window.concreteTexture || null // í…ìŠ¤ì²˜ ì ìš© (ìˆëŠ” ê²½ìš°)
            });
            const matMetal = new THREE.MeshStandardMaterial({
                color: 0x556677,
                roughness: 0.4,
                metalness: 0.7,
                map: window.metalTexture || null // ë©”íƒˆ í…ìŠ¤ì²˜ ì ìš©
            });
            // Rust í…ìŠ¤ì²˜ ìƒì„±
            const rustCanvas = document.createElement('canvas');
            rustCanvas.width = 256;
            rustCanvas.height = 256;
            const rustCtx = rustCanvas.getContext('2d');
            rustCtx.fillStyle = '#885544';
            rustCtx.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 500; i++) {
                rustCtx.fillStyle = `rgba(${100 + Math.random() * 30}, ${60 + Math.random() * 20}, ${40 + Math.random() * 15}, 0.5)`;
                rustCtx.fillRect(Math.random() * 256, Math.random() * 256, 3, 3);
            }
            window.rustTexture = new THREE.CanvasTexture(rustCanvas);
            window.rustTexture.wrapS = THREE.RepeatWrapping;
            window.rustTexture.wrapT = THREE.RepeatWrapping;

            const matRust = new THREE.MeshStandardMaterial({
                color: 0x885544,
                roughness: 0.8,
                metalness: 0.2,
                map: window.rustTexture || null
            });
            const matWall = new THREE.MeshStandardMaterial({
                color: 0x20252a,
                roughness: 0.9,
                map: window.concreteTexture || null // ë²½ì—ë„ ì½˜í¬ë¦¬íŠ¸ í…ìŠ¤ì²˜ ì ìš©
            });

            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), matConcrete);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            function addBoxCollider(mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                colliders.push(box);
            }



            const wallGeo = new THREE.BoxGeometry(200, 20, 1);
            const createWall = (x, y, z, rotY) => {
                const w = new THREE.Mesh(wallGeo, matWall);
                w.position.set(x, y, z);
                if (rotY) w.rotation.y = rotY;
                scene.add(w);
                addBoxCollider(w);
            };
            // Walls at Â±100 for 200x200 map
            createWall(0, 10, -100, 0);
            createWall(0, 10, 100, 0);
            createWall(-100, 10, 0, Math.PI / 2);
            createWall(100, 10, 0, Math.PI / 2);

            // === DETAILED MAP STRUCTURES FOR 200x200 MAP ===

            // Cover Walls - Low walls for tactical cover
            const coverWallGeo = new THREE.BoxGeometry(6, 1.5, 0.3);
            const coverPositions = [
                { x: -30, z: -30 }, { x: 30, z: 30 }, { x: -30, z: 30 }, { x: 30, z: -30 },
                { x: -50, z: 0 }, { x: 50, z: 0 }, { x: 0, z: -50 }, { x: 0, z: 50 },
                { x: -40, z: -20 }, { x: 40, z: 20 }, { x: -20, z: 40 }, { x: 20, z: -40 }
            ];
            coverPositions.forEach((p, i) => {
                const wall = new THREE.Mesh(coverWallGeo, matConcrete);
                wall.position.set(p.x, 0.75, p.z);
                wall.rotation.y = (i % 2) * Math.PI / 2; // Alternate orientation
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                addBoxCollider(wall);
            });

            // Elevated Platforms - For height advantage
            const platformGeo = new THREE.BoxGeometry(8, 0.5, 8);
            const platformSupport = new THREE.BoxGeometry(0.5, 3, 0.5);
            const platforms = [
                { x: -60, z: -60, height: 3 },
                { x: 60, z: 60, height: 3 },
                { x: -60, z: 60, height: 4 },
                { x: 60, z: -60, height: 4 }
            ];
            platforms.forEach(p => {
                const platform = new THREE.Mesh(platformGeo, matMetal);
                platform.position.set(p.x, p.height, p.z);
                platform.castShadow = true;
                platform.receiveShadow = true;
                scene.add(platform);
                addBoxCollider(platform);

                // Support pillars
                for (let dx = -3; dx <= 3; dx += 6) {
                    for (let dz = -3; dz <= 3; dz += 6) {
                        const support = new THREE.Mesh(platformSupport, matMetal);
                        support.position.set(p.x + dx, p.height / 2, p.z + dz);
                        support.castShadow = true;
                        scene.add(support);
                    }
                }
            });

            // Large Crates - Scattered cover
            const largeCrateGeo = new THREE.BoxGeometry(3, 3, 3);
            const cratePositions = [
                { x: -45, z: -15 }, { x: 45, z: 15 }, { x: -15, z: 45 }, { x: 15, z: -45 },
                { x: -70, z: -30 }, { x: 70, z: 30 }, { x: -30, z: 70 }, { x: 30, z: -70 },
                { x: -55, z: 25 }, { x: 55, z: -25 }, { x: 25, z: 55 }, { x: -25, z: -55 }
            ];
            cratePositions.forEach(p => {
                const crate = new THREE.Mesh(largeCrateGeo, matRust);
                crate.position.set(p.x, 1.5, p.z);
                crate.castShadow = true;
                crate.receiveShadow = true;
                scene.add(crate);
                addBoxCollider(crate);
            });

            // Small Crates Clusters - Additional cover
            const smallCrateGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const smallCrateClusters = [
                { x: -35, z: -5 }, { x: 35, z: 5 }, { x: -5, z: 35 }, { x: 5, z: -35 },
                { x: -80, z: -50 }, { x: 80, z: 50 }, { x: -50, z: 80 }, { x: 50, z: -80 }
            ];
            smallCrateClusters.forEach(p => {
                for (let i = 0; i < 3; i++) {
                    const crate = new THREE.Mesh(smallCrateGeo, matRust);
                    const offsetX = (Math.random() - 0.5) * 4;
                    const offsetZ = (Math.random() - 0.5) * 4;
                    crate.position.set(p.x + offsetX, 0.75, p.z + offsetZ);
                    crate.rotation.y = Math.random() * Math.PI;
                    crate.castShadow = true;
                    crate.receiveShadow = true;
                    scene.add(crate);
                    addBoxCollider(crate);
                }
            });

            // Corridors - Narrow pathways
            const corridorWallGeo = new THREE.BoxGeometry(20, 3, 0.5);
            const corridors = [
                { x: -75, z: 0, vertical: false },
                { x: 75, z: 0, vertical: false },
                { x: 0, z: -75, vertical: true },
                { x: 0, z: 75, vertical: true }
            ];
            corridors.forEach(c => {
                const wall1 = new THREE.Mesh(corridorWallGeo, matWall);
                const wall2 = new THREE.Mesh(corridorWallGeo, matWall);
                if (c.vertical) {
                    wall1.position.set(c.x - 2, 1.5, c.z);
                    wall2.position.set(c.x + 2, 1.5, c.z);
                } else {
                    wall1.position.set(c.x, 1.5, c.z - 2);
                    wall2.position.set(c.x, 1.5, c.z + 2);
                    wall1.rotation.y = Math.PI / 2;
                    wall2.rotation.y = Math.PI / 2;
                }
                wall1.castShadow = true;
                wall2.castShadow = true;
                scene.add(wall1);
                scene.add(wall2);
                addBoxCollider(wall1);
                addBoxCollider(wall2);
            });

            // Central Structure - Multi-level focal point
            const centralBase = new THREE.Mesh(new THREE.BoxGeometry(15, 1, 15), matConcrete);
            centralBase.position.set(0, 0.5, 0);
            centralBase.receiveShadow = true;
            scene.add(centralBase);
            addBoxCollider(centralBase);

            // Ramps for central structure
            const rampGeo = new THREE.BoxGeometry(4, 0.2, 8);
            [-6, 6].forEach(offset => {
                const ramp = new THREE.Mesh(rampGeo, matMetal);
                ramp.position.set(offset, 1, 0);
                ramp.rotation.x = Math.PI / 12;
                scene.add(ramp);
            });

            // Keep existing pillars for vertical gameplay
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            for (let x = -20; x <= 20; x += 10) {
                for (let z = -20; z <= 20; z += 10) {
                    if (x === 0 && z === 0) continue;
                    const pillar = new THREE.Mesh(pillarGeo, matMetal);
                    pillar.position.set(x, 5, z);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    scene.add(pillar);
                    addBoxCollider(pillar);
                }
            }

            const beamGeo = new THREE.BoxGeometry(200, 0.5, 0.5);
            for (let z = -20; z <= 20; z += 5) {
                const beam = new THREE.Mesh(beamGeo, matMetal);
                beam.position.set(0, 9, z);
                scene.add(beam);
            }

            // Old barrels for decoration (non-collidable)
            const barrelGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8);
            const barrelPositions = [
                { x: -65, z: -45 }, { x: 65, z: 45 }, { x: -45, z: 65 }, { x: 45, z: -65 },
                { x: -85, z: -20 }, { x: 85, z: 20 }
            ];
            barrelPositions.forEach(p => {
                const barrel = new THREE.Mesh(barrelGeo, matRust);
                barrel.position.set(p.x, 0.6, p.z);
                barrel.castShadow = true;
                barrel.receiveShadow = true;
                scene.add(barrel);

                barrel.receiveShadow = true;
                scene.add(barrel);

                // ì›í†µí˜• ì¶©ëŒ ë°•ìŠ¤ (ê°„ë‹¨í•œ ë°•ìŠ¤ë¡œ ê·¼ì‚¬)
                const barrelCollider = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(p.x, 0.6, p.z),
                    new THREE.Vector3(1.2, 1.2, 1.2)
                );
                colliders.push(barrelCollider);
            });

            // === SHIPPING CONTAINERS - MAJOR COVER OBJECTS ===
            const containerGeo = new THREE.BoxGeometry(12, 2.6, 2.6); // Standard 40ft container proportions
            const matContainer1 = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.3 });
            const matContainer2 = new THREE.MeshStandardMaterial({ color: 0x2F4F4F, roughness: 0.8, metalness: 0.3 });
            const matContainer3 = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.8, metalness: 0.3 });

            const containerPlacements = [
                { x: -70, z: -70, rotation: 0, material: matContainer1 },
                { x: 70, z: 70, rotation: 0, material: matContainer2 },
                { x: -70, z: 70, rotation: Math.PI / 2, material: matContainer3 },
                { x: 70, z: -70, rotation: Math.PI / 2, material: matContainer1 },
                { x: -85, z: 0, rotation: 0, material: matContainer2 },
                { x: 85, z: 0, rotation: 0, material: matContainer3 },
                { x: 0, z: -85, rotation: Math.PI / 2, material: matContainer1 },
                { x: 0, z: 85, rotation: Math.PI / 2, material: matContainer2 },
                // Stacked containers
                { x: -40, z: -60, rotation: 0, material: matContainer3, height: 2.6 },
                { x: 40, z: 60, rotation: Math.PI / 2, material: matContainer1, height: 2.6 }
            ];

            containerPlacements.forEach(c => {
                const container = new THREE.Mesh(containerGeo, c.material);
                container.position.set(c.x, c.height || 1.3, c.z);
                container.rotation.y = c.rotation;
                container.castShadow = true;
                container.receiveShadow = true;
                scene.add(container);
                addBoxCollider(container);

                // Add container details (corrugated pattern simulation)
                const stripGeo = new THREE.BoxGeometry(12.1, 0.1, 0.1);
                for (let i = -1; i <= 1; i += 0.5) {
                    const strip = new THREE.Mesh(stripGeo, c.material);
                    strip.position.set(c.x, (c.height || 1.3) + i, c.z);
                    strip.rotation.y = c.rotation;
                    scene.add(strip);
                }
            });

            // === CONCRETE BARRIERS - WAIST-HIGH COVER ===
            const barrierGeo = new THREE.BoxGeometry(4, 1.2, 0.5);
            const matBarrier = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const barrierPositions = [
                { x: -55, z: -35 }, { x: 55, z: 35 }, { x: -35, z: 55 }, { x: 35, z: -55 },
                { x: -75, z: -15 }, { x: 75, z: 15 }, { x: -15, z: 75 }, { x: 15, z: -75 },
                { x: -45, z: -45 }, { x: 45, z: 45 }
            ];

            barrierPositions.forEach((p, i) => {
                const barrier = new THREE.Mesh(barrierGeo, matBarrier);
                barrier.position.set(p.x, 0.6, p.z);
                barrier.rotation.y = (i % 3) * Math.PI / 3; // Varied angles
                barrier.castShadow = true;
                barrier.receiveShadow = true;
                scene.add(barrier);
                addBoxCollider(barrier);
            });

            // === METAL FENCES - SECTIONAL BARRIERS ===
            const fenceGeo = new THREE.BoxGeometry(8, 2, 0.1);
            const matFence = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.6, metalness: 0.7 });
            const fenceSections = [
                { x: -90, z: -40, rotation: 0 },
                { x: 90, z: 40, rotation: 0 },
                { x: -40, z: -90, rotation: Math.PI / 2 },
                { x: 40, z: 90, rotation: Math.PI / 2 }
            ];

            fenceSections.forEach(f => {
                const fence = new THREE.Mesh(fenceGeo, matFence);
                fence.position.set(f.x, 1, f.z);
                fence.rotation.y = f.rotation;
                fence.castShadow = true;
                scene.add(fence);
                addBoxCollider(fence);
            });

            // === STORAGE TANKS - CYLINDRICAL COVER ===
            const tankGeo = new THREE.CylinderGeometry(2, 2, 4, 16);
            const matTank = new THREE.MeshStandardMaterial({ color: 0x4682B4, roughness: 0.5, metalness: 0.6 });
            const tankPositions = [
                { x: -50, z: -70 }, { x: 50, z: 70 }, { x: -70, z: 50 }, { x: 70, z: -50 }
            ];

            tankPositions.forEach(p => {
                const tank = new THREE.Mesh(tankGeo, matTank);
                tank.position.set(p.x, 2, p.z);
                tank.castShadow = true;
                tank.receiveShadow = true;
                scene.add(tank);
                addBoxCollider(tank);

                // Tank top/cap
                const capGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.2, 16);
                const cap = new THREE.Mesh(capGeo, matMetal);
                cap.position.set(p.x, 4.1, p.z);
                scene.add(cap);
            });

            // === SANDBAG WALLS - LOW TACTICAL COVER ===
            const sandbagGeo = new THREE.BoxGeometry(5, 1, 1.5);
            const matSandbag = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 1.0 });
            const sandbagWalls = [
                { x: -25, z: -65 }, { x: 25, z: 65 }, { x: -65, z: 25 }, { x: 65, z: -25 },
                { x: -35, z: -40 }, { x: 35, z: 40 }
            ];

            sandbagWalls.forEach((p, i) => {
                const wall = new THREE.Mesh(sandbagGeo, matSandbag);
                wall.position.set(p.x, 0.5, p.z);
                wall.rotation.y = (i % 2) * Math.PI / 2;
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                addBoxCollider(wall);
            });
        }

        // --- Hotel Map ---
        function createHotelMap() {
            colliders = []; // Init array

            // === í˜¸í…” ë§µ ì¬ì§ˆ ì •ì˜ ===

            // ë°ì€ ëŒ€ë¦¬ì„ ë°”ë‹¥
            const matFloor = new THREE.MeshStandardMaterial({
                color: 0xddc9b4, // í¬ë¦¼/ë² ì´ì§€ìƒ‰
                roughness: 0.3,
                metalness: 0.2
            });

            // í¬ë¦¼ìƒ‰ ë²½
            const matWall = new THREE.MeshStandardMaterial({
                color: 0xf5f5dc, // ë² ì´ì§€ìƒ‰
                roughness: 0.8
            });

            // ë‚˜ë¬´ ë¬¸
            const matDoor = new THREE.MeshStandardMaterial({
                color: 0x8b7355, // ë¸Œë¼ìš´
                roughness: 0.7
            });

            // ê¸ˆìƒ‰ ì•…ì„¼íŠ¸
            const matGold = new THREE.MeshStandardMaterial({
                color: 0xdaa520, // ê³¨ë“œ
                roughness: 0.2,
                metalness: 0.9
            });

            // ë¹¨ê°„ ì†ŒíŒŒ
            const matSofa = new THREE.MeshStandardMaterial({
                color: 0x8b0000, // ë‹¤í¬ ë ˆë“œ
                roughness: 0.7
            });

            // í°ìƒ‰ ì¹¨ëŒ€
            const matBed = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.6
            });

            // ì€ìƒ‰ ì—˜ë¦¬ë² ì´í„°
            const matElevator = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                roughness: 0.3,
                metalness: 0.8
            });

            // ë…¹ìƒ‰ ì‹ë¬¼
            const matPlant = new THREE.MeshStandardMaterial({
                color: 0x228b22,
                roughness: 0.9
            });

            // === ë°”ë‹¥ ===
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                matFloor
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // === ì™¸ë²½ (ê²½ê³„) ===
            function addBoxCollider(mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                colliders.push(box);
            }

            const wallGeo = new THREE.BoxGeometry(80, 10, 1);
            const createWall = (x, y, z, rotY) => {
                const w = new THREE.Mesh(wallGeo, matWall);
                w.position.set(x, y, z);
                if (rotY) w.rotation.y = rotY;
                w.castShadow = true;
                w.receiveShadow = true;
                scene.add(w);
                addBoxCollider(w);
            };

            createWall(0, 5, -40, 0);           // ë¶ìª½
            createWall(0, 5, 40, 0);            // ë‚¨ìª½
            createWall(-40, 5, 0, Math.PI / 2); // ì„œìª½
            createWall(40, 5, 0, Math.PI / 2);  // ë™ìª½

            // === ë¡œë¹„ (ì…êµ¬ ê·¼ì²˜) ===

            // ë¦¬ì…‰ì…˜ ë°ìŠ¤í¬
            const deskGeo = new THREE.BoxGeometry(8, 1.2, 2);
            const desk = new THREE.Mesh(deskGeo, matGold);
            desk.position.set(0, 0.6, -30);
            desk.castShadow = true;
            desk.receiveShadow = true;
            scene.add(desk);
            addBoxCollider(desk);

            // ë¡œë¹„ ì†ŒíŒŒë“¤ (ëŒ€ê¸° ê³µê°„)
            const sofaGeo = new THREE.BoxGeometry(3, 0.8, 1.5);

            const sofaPositions = [
                { x: -15, z: -25 },
                { x: -10, z: -25 },
                { x: 10, z: -25 },
                { x: 15, z: -25 }
            ];

            sofaPositions.forEach(pos => {
                const sofa = new THREE.Mesh(sofaGeo, matSofa);
                sofa.position.set(pos.x, 0.4, pos.z);
                sofa.castShadow = true;
                sofa.receiveShadow = true;
                scene.add(sofa);
                addBoxCollider(sofa);
            });

            // === ë³µë„ ===

            // ì¤‘ì•™ ë³µë„ ë²½
            const corridorWallGeo = new THREE.BoxGeometry(1, 4, 70);

            // ì™¼ìª½ ë³µë„ ë²½
            const leftWall = new THREE.Mesh(corridorWallGeo, matWall);
            leftWall.position.set(-15, 2, 5);
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            addBoxCollider(leftWall);

            // ì˜¤ë¥¸ìª½ ë³µë„ ë²½
            const rightWall = new THREE.Mesh(corridorWallGeo, matWall);
            rightWall.position.set(15, 2, 5);
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            addBoxCollider(rightWall);

            // === ê°ì‹¤ (ì–‘ìª½) ===

            const roomWallGeo = new THREE.BoxGeometry(12, 4, 1);
            const roomSpacing = 14;

            // ì™¼ìª½ ê°ì‹¤ë“¤
            for (let i = 0; i < 5; i++) {
                const z = -20 + i * roomSpacing;

                // ê°ì‹¤ ì•ë²½
                const frontWall = new THREE.Mesh(roomWallGeo, matWall);
                frontWall.position.set(-25, 2, z);
                frontWall.castShadow = true;
                frontWall.receiveShadow = true;
                scene.add(frontWall);
                addBoxCollider(frontWall);

                // ê°ì‹¤ ë¬¸
                const doorGeo = new THREE.BoxGeometry(2, 3, 0.2);
                const door = new THREE.Mesh(doorGeo, matDoor);
                door.position.set(-19, 1.5, z);
                door.castShadow = true;
                door.receiveShadow = true;
                scene.add(door);
                // ë¬¸ì€ ì¶©ëŒì²´ì— ì¶”ê°€í•˜ì§€ ì•ŠìŒ (í†µê³¼ ê°€ëŠ¥)

                // ê°ì‹¤ ì¹¨ëŒ€
                const bedGeo = new THREE.BoxGeometry(3, 0.6, 2);
                const bed = new THREE.Mesh(bedGeo, matBed);
                bed.position.set(-28, 0.3, z);
                bed.castShadow = true;
                bed.receiveShadow = true;
                scene.add(bed);
                addBoxCollider(bed);

                // ê°ì‹¤ ë’·ë²½ (ì¶”ê°€)
                const backWallGeo = new THREE.BoxGeometry(12, 4, 1);
                const backWall = new THREE.Mesh(backWallGeo, matWall);
                backWall.position.set(-31, 2, z);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                scene.add(backWall);
                addBoxCollider(backWall);
            }

            // ì˜¤ë¥¸ìª½ ê°ì‹¤ë“¤
            for (let i = 0; i < 5; i++) {
                const z = -20 + i * roomSpacing;

                // ê°ì‹¤ ì•ë²½
                const frontWall = new THREE.Mesh(roomWallGeo, matWall);
                frontWall.position.set(25, 2, z);
                frontWall.castShadow = true;
                frontWall.receiveShadow = true;
                scene.add(frontWall);
                addBoxCollider(frontWall);

                // ê°ì‹¤ ë¬¸
                const doorGeo = new THREE.BoxGeometry(2, 3, 0.2);
                const door = new THREE.Mesh(doorGeo, matDoor);
                door.position.set(19, 1.5, z);
                door.castShadow = true;
                door.receiveShadow = true;
                scene.add(door);

                // ê°ì‹¤ ì¹¨ëŒ€
                const bedGeo = new THREE.BoxGeometry(3, 0.6, 2);
                const bed = new THREE.Mesh(bedGeo, matBed);
                bed.position.set(28, 0.3, z);
                bed.castShadow = true;
                bed.receiveShadow = true;
                scene.add(bed);
                addBoxCollider(bed);

                // ê°ì‹¤ ë’·ë²½
                const backWallGeo = new THREE.BoxGeometry(12, 4, 1);
                const backWall = new THREE.Mesh(backWallGeo, matWall);
                backWall.position.set(31, 2, z);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                scene.add(backWall);
                addBoxCollider(backWall);
            }

            // === ì—˜ë¦¬ë² ì´í„° (ì¥ì‹ìš©) ===
            const elevatorGeo = new THREE.BoxGeometry(3, 5, 3);
            const elevator = new THREE.Mesh(elevatorGeo, matElevator);
            elevator.position.set(0, 2.5, 35);
            elevator.castShadow = true;
            elevator.receiveShadow = true;
            scene.add(elevator);
            addBoxCollider(elevator);

            // === í™”ë¶„ (ì¥ì‹) ===
            const plantGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.5, 8);

            const plantPositions = [
                { x: -8, z: -15 },
                { x: 8, z: -15 },
                { x: -8, z: 20 },
                { x: 8, z: 20 }
            ];

            plantPositions.forEach(pos => {
                const plant = new THREE.Mesh(plantGeo, matPlant);
                plant.position.set(pos.x, 0.75, pos.z);
                plant.castShadow = true;
                plant.receiveShadow = true;
                scene.add(plant);
                addBoxCollider(plant);
            });
        }


        // --- Weapon Building ---
        function buildWeapon(idx) {
            while (weaponModel.children.length > 0) weaponModel.remove(weaponModel.children[0]);

            const wData = WEAPONS[idx];
            if (wData.type === 'RIFLE') buildRifle();
            else if (wData.type === 'PISTOL') buildPistol();
            else if (wData.type === 'KNIFE') buildKnife();
            else if (wData.type === 'SNIPER') buildSniper();

            if (wData.type !== 'KNIFE') {
                const fGeo = new THREE.PlaneGeometry(0.5, 0.5);
                const fMat = new THREE.MeshBasicMaterial({ color: 0xffdd88, transparent: true, opacity: 0, side: THREE.DoubleSide });
                muzzleFlash = new THREE.Mesh(fGeo, fMat);
                muzzleFlash.visible = false;
                let zPos = -0.65;
                if (wData.type === 'PISTOL') zPos = -0.25;
                if (wData.type === 'SNIPER') zPos = -0.85;
                const yPos = (wData.type === 'PISTOL') ? 0.045 : 0.02;
                muzzleFlash.position.set(0, yPos, zPos);
                weaponModel.add(muzzleFlash);
            }
        }

        function buildRifle() {
            // ë¦¬ì‹œë²„ (ë³¸ì²´)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.06, 0.3), matBody);
            weaponModel.add(receiver);

            // ë°°ëŸ´ (ë” ìƒì„¸í•˜ê²Œ)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.4);
            weaponModel.add(barrel);

            // ë°°ëŸ´ ê°€ë“œ (Barrel Guard) - ë°°ëŸ´ ë³´í˜¸ëŒ€
            const barrelGuard = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.4, 16), matParts);
            barrelGuard.rotation.x = Math.PI / 2; barrelGuard.position.set(0, 0.015, -0.35);
            weaponModel.add(barrelGuard);

            // ê°€ìŠ¤ ë¸”ë¡ (Gas Block)
            const gasBlock = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.025, 0.03), matSilver);
            gasBlock.position.set(0, 0.015, -0.2);
            weaponModel.add(gasBlock);

            // íƒ„ì°½ (Magazine)
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.035, 0.18, 0.06), matParts);
            mag.rotation.x = 0.25; mag.position.set(0, -0.1, 0.05);
            weaponModel.add(mag);

            // íƒ„ì°½ í´ë¦½ ë””í…Œì¼
            const magClip = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.02, 0.07), matSilver);
            magClip.position.set(0, -0.18, 0.05);
            weaponModel.add(magClip);

            // ê°œë¨¸ë¦¬íŒ (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.2), matParts);
            stock.position.set(0, -0.02, 0.25);
            weaponModel.add(stock);

            // ê°œë¨¸ë¦¬íŒ íŒ¨ë“œ
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.042, 0.12, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.36);
            weaponModel.add(stockPad);

            // í•¸ë“œê°€ë“œ (Handguard)
            const hg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.06, 0.25), matParts);
            hg.position.set(0, 0.005, -0.28);
            weaponModel.add(hg);

            // í•¸ë“œê°€ë“œ ë¼ì¼ (Rail) - ìƒë‹¨
            const railTop = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.01, 0.2), matSilver);
            railTop.position.set(0, 0.04, -0.28);
            weaponModel.add(railTop);

            // íŠ¸ë¦¬ê±° ê°€ë“œ (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // íŠ¸ë¦¬ê±° (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.02), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // ë³¼íŠ¸ í•¸ë“¤ (Bolt Handle)
            const boltHandle = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.008, 0.03), matSilver);
            boltHandle.position.set(0.025, 0.03, 0.1);
            weaponModel.add(boltHandle);

            // ê°€ëŠ ì (Rear Sight) - ë” ìƒì„¸í•˜ê²Œ
            const rs = new THREE.Mesh(new THREE.TorusGeometry(0.012, 0.003, 8, 16), matParts);
            rs.position.set(0, 0.062, 0.14);
            weaponModel.add(rs);

            // ê°€ëŠ ì‡  (Front Sight) - ë¹¨ê°„ ì  (ë†’ì´ë¥¼ ê°€ëŠ ì êµ¬ë© ì¤‘ì‹¬ì¸ 0.062ë¡œ ì •ë°€ ì •ë ¬)
            const fs = new THREE.Mesh(new THREE.BoxGeometry(0.0025, 0.0025, 0.0025), matSight);
            fs.position.set(0, 0.062, -0.45);
            fs.userData.isSight = true;
            weaponModel.add(fs);

            // ê°€ëŠ ì‡  ê¸°ë‘¥
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.002, 0.015, 0.002), matParts);
            fsPost.position.set(0, 0.055, -0.45);
            weaponModel.add(fsPost);

            // ê°€ëŠ ì‡  ë² ì´ìŠ¤
            const fsBase = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.003, 0.008), matParts);
            fsBase.position.set(0, 0.048, -0.45);
            weaponModel.add(fsBase);

            createArm(-0.1, -0.15, -0.2, 0.5, 0.5, -0.2, false);
            createArm(0.12, -0.15, 0.22, 0.2, -0.2, 0.4, true);
        }

        function buildSniper() {
            // ë¦¬ì‹œë²„ (ë³¸ì²´)
            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.07, 0.4), matBody);
            weaponModel.add(receiver);

            // ë°°ëŸ´ (ë” ìƒì„¸í•˜ê²Œ)
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.8, 16), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.015, -0.6);
            weaponModel.add(barrel);

            // ë¨¸ì¦ ë¸Œë ˆì´í¬ (Muzzle Brake) - ë” ìƒì„¸í•˜ê²Œ
            const brake = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.015, 0.08, 16), matSilver);
            brake.rotation.x = Math.PI / 2; brake.position.set(0, 0.015, -1.0);
            weaponModel.add(brake);

            // ë¨¸ì¦ ë¸Œë ˆì´í¬ êµ¬ë©ë“¤
            for (let i = 0; i < 3; i++) {
                const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.003, 0.003, 0.1, 8), matBody);
                hole.rotation.x = Math.PI / 2;
                hole.rotation.z = (i - 1) * 0.3;
                hole.position.set(0, 0.015 + (i - 1) * 0.01, -1.0);
                weaponModel.add(hole);
            }

            // ìŠ¤ì½”í”„ ëª¸ì²´ (Scope Body)
            const scopeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.25, 16), matParts);
            scopeBody.rotation.x = Math.PI / 2; scopeBody.position.set(0, 0.075, 0);
            weaponModel.add(scopeBody);

            // ìŠ¤ì½”í”„ ë§ (Scope Rings)
            const scopeRing1 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing1.rotation.x = Math.PI / 2; scopeRing1.position.set(0, 0.075, -0.1);
            weaponModel.add(scopeRing1);
            const scopeRing2 = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), matSilver);
            scopeRing2.rotation.x = Math.PI / 2; scopeRing2.position.set(0, 0.075, 0.1);
            weaponModel.add(scopeRing2);

            // ìŠ¤ì½”í”„ ë Œì¦ˆ (ì „ë©´)
            const lensF = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 0.01, 16), matParts);
            lensF.rotation.x = Math.PI / 2; lensF.position.set(0, 0.075, -0.13);
            weaponModel.add(lensF);

            // ìŠ¤ì½”í”„ ìœ ë¦¬ (í›„ë©´)
            const glass = new THREE.Mesh(new THREE.CircleGeometry(0.02, 16), matLens);
            glass.position.set(0, 0.075, 0.13);
            weaponModel.add(glass);

            // ì¡°ì • ë…¸ë¸Œ (Adjustment Knobs)
            const knob1 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob1.rotation.x = Math.PI / 2; knob1.position.set(0.03, 0.075, 0);
            weaponModel.add(knob1);
            const knob2 = new THREE.Mesh(new THREE.CylinderGeometry(0.008, 0.008, 0.015, 8), matSilver);
            knob2.rotation.x = Math.PI / 2; knob2.position.set(-0.03, 0.075, 0);
            weaponModel.add(knob2);

            // ë³¼íŠ¸ (Bolt)
            const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.02), matSilver);
            bolt.position.set(0.04, 0.02, 0.1);
            weaponModel.add(bolt);

            // ë³¼íŠ¸ í•¸ë“¤
            const boltHandle = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.03, 8), matSilver);
            boltHandle.rotation.x = Math.PI / 2; boltHandle.position.set(0.06, 0.02, 0.1);
            weaponModel.add(boltHandle);

            // ê°œë¨¸ë¦¬íŒ (Stock)
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.12, 0.25), matParts);
            stock.position.set(0, -0.02, 0.3);
            weaponModel.add(stock);

            // ê°œë¨¸ë¦¬íŒ ì²´í¬ ë ˆìŠ¤íŠ¸
            const cheekRest = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.04, 0.15), matParts);
            cheekRest.position.set(0, 0.05, 0.25);
            weaponModel.add(cheekRest);

            // ê°œë¨¸ë¦¬íŒ íŒ¨ë“œ
            const stockPad = new THREE.Mesh(new THREE.BoxGeometry(0.047, 0.14, 0.03), matParts);
            stockPad.position.set(0, -0.02, 0.42);
            weaponModel.add(stockPad);

            // ë°”ì´í¬ë“œ (Bipod) - ë” ìƒì„¸í•˜ê²Œ
            const bipodBase = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.15), matParts);
            bipodBase.position.set(0, -0.05, -0.4);
            weaponModel.add(bipodBase);

            // ë°”ì´í¬ë“œ ë‹¤ë¦¬ë“¤
            const bipodLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg1.position.set(-0.015, -0.13, -0.4);
            bipodLeg1.rotation.z = 0.3;
            weaponModel.add(bipodLeg1);
            const bipodLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.005, 0.15, 0.005), matSilver);
            bipodLeg2.position.set(0.015, -0.13, -0.4);
            bipodLeg2.rotation.z = -0.3;
            weaponModel.add(bipodLeg2);

            // íŠ¸ë¦¬ê±° ê°€ë“œ
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.02, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // íŠ¸ë¦¬ê±°
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.02), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            createArm(-0.1, -0.15, -0.2, 0.5, 0.5, -0.2, false);
            createArm(0.12, -0.15, 0.25, 0.2, -0.2, 0.4, true);
        }

        function buildPistol() {
            // ìŠ¬ë¼ì´ë“œ (Slide) - ë” ìƒì„¸í•˜ê²Œ
            const slide = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.04, 0.18), matSilver);
            slide.position.y = 0.02;
            weaponModel.add(slide);

            // ìŠ¬ë¼ì´ë“œ ì„¸ë¦¬ë ˆì´ì…˜ (Serrations)
            for (let i = 0; i < 8; i++) {
                const serration = new THREE.Mesh(new THREE.BoxGeometry(0.001, 0.01, 0.02), matBody);
                serration.position.set(0, 0.02, 0.05 - i * 0.015);
                weaponModel.add(serration);
            }

            // ë°°ëŸ´
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.006, 0.15, 12), matBody);
            barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.02, -0.08);
            weaponModel.add(barrel);

            // í”„ë ˆì„ (Frame)
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.08, 0.12), matBody);
            frame.position.set(0, -0.02, 0.03);
            weaponModel.add(frame);

            // ê·¸ë¦½ (Grip) - ë” ìƒì„¸í•˜ê²Œ
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.028, 0.1, 0.05), matParts);
            grip.position.set(0, -0.04, 0.05); grip.rotation.x = 0.1;
            weaponModel.add(grip);

            // ê·¸ë¦½ í…ìŠ¤ì²˜ (íŒ¨í„´)
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    const gripDot = new THREE.Mesh(new THREE.CylinderGeometry(0.002, 0.002, 0.01, 8), matParts);
                    gripDot.rotation.x = Math.PI / 2;
                    gripDot.position.set((j - 0.5) * 0.015, -0.04 + i * 0.03, 0.05);
                    weaponModel.add(gripDot);
                }
            }

            // í•´ë¨¸ (Hammer)
            const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.015, 0.01), matSilver);
            hammer.position.set(0, 0.01, 0.1);
            hammer.rotation.x = 0.3;
            weaponModel.add(hammer);

            // íŠ¸ë¦¬ê±° ê°€ë“œ (Trigger Guard)
            const triggerGuard = new THREE.Mesh(new THREE.TorusGeometry(0.015, 0.003, 8, 16), matParts);
            triggerGuard.rotation.x = Math.PI / 2; triggerGuard.position.set(0, -0.05, 0.08);
            weaponModel.add(triggerGuard);

            // íŠ¸ë¦¬ê±° (Trigger)
            const trigger = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.012, 0.015), matParts);
            trigger.position.set(0, -0.06, 0.08);
            weaponModel.add(trigger);

            // ê°€ëŠ ì (Rear Sight) - ã„·ì í˜•íƒœ
            const rsBase = new THREE.Mesh(new THREE.BoxGeometry(0.022, 0.003, 0.008), matParts);
            rsBase.position.set(0, 0.048, 0.08);
            weaponModel.add(rsBase);
            // ì™¼ìª½ ê¸°ë‘¥
            const rsL = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsL.position.set(-0.01, 0.048, 0.08);
            weaponModel.add(rsL);
            // ì˜¤ë¥¸ìª½ ê¸°ë‘¥
            const rsR = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.015, 0.005), matParts);
            rsR.position.set(0.01, 0.048, 0.08);
            weaponModel.add(rsR);

            // ê°€ëŠ ì‡  (Front Sight) - ë¹¨ê°„ ì 
            const fsPost = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.012, 0.003), matParts);
            fsPost.position.set(0, 0.045, -0.09);
            weaponModel.add(fsPost);
            const fsDot = new THREE.Mesh(new THREE.BoxGeometry(0.003, 0.003, 0.001), matSight);
            fsDot.position.set(0, 0.0482, -0.09);
            fsDot.userData.isSight = true;
            weaponModel.add(fsDot);

            // íƒ„ì°½ (Magazine)
            const magazine = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.08, 0.04), matParts);
            magazine.position.set(0, -0.08, 0.05);
            weaponModel.add(magazine);

            // íƒ„ì°½ ë°”ë‹¥ í”Œë ˆì´íŠ¸
            const magPlate = new THREE.Mesh(new THREE.BoxGeometry(0.027, 0.01, 0.042), matSilver);
            magPlate.position.set(0, -0.12, 0.05);
            weaponModel.add(magPlate);

            const lArm = createArm(-0.05, -0.15, 0.1, 0.1, 0.8, -0.1, false);
            lArm.rotation.y = -0.1;
            const rArm = createArm(0.05, -0.15, 0.1, 0.1, -0.8, 0.1, true);
            rArm.rotation.y = 0.1;
        }

        function buildKnife() {
            const knifeGroup = new THREE.Group();

            // === í•¸ë“¤ (ê·¸ë¦½) - ë” í˜„ì‹¤ì ì´ê³  ì„¸ë°€í•˜ê²Œ ===
            const handleLength = 0.13;
            const handleWidth = 0.032;
            const handleHeight = 0.045;

            // í•¸ë“¤ ë©”ì¸ ë°”ë”” (íƒ€ì›í˜•ì— ê°€ê¹ê²Œ)
            const handleGeo = new THREE.BoxGeometry(handleWidth, handleHeight, handleLength);
            const handle = new THREE.Mesh(handleGeo, matHandle);
            handle.position.set(0, -0.02, handleLength / 2 - 0.01);
            knifeGroup.add(handle);

            // í•¸ë“¤ ê·¸ë¦½ í…ìŠ¤ì²˜ (ë” ë§ì€ ë””í…Œì¼, 6ê°œë¡œ ì¦ê°€)
            for (let i = 0; i < 6; i++) {
                const grip = new THREE.Mesh(
                    new THREE.BoxGeometry(handleWidth + 0.003, handleHeight * 0.6, 0.015),
                    matHandle
                );
                grip.position.set(0, -0.01, 0.005 + i * 0.02);
                knifeGroup.add(grip);
            }

            // í•¸ë“¤ ë¦¬ë²³ (3ê°œë¡œ ì¦ê°€, ë” í˜„ì‹¤ì ìœ¼ë¡œ)
            for (let i = 0; i < 3; i++) {
                const rivet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.004, 0.004, 0.012, 12),
                    matSilver
                );
                rivet.rotation.x = Math.PI / 2;
                rivet.position.set((i - 1) * 0.012, -0.02, 0.02 + i * 0.03);
                knifeGroup.add(rivet);
            }

            // í•¸ë“¤ ë ë¶€ë¶„ (Pommel) - ë” ì„¸ë°€í•˜ê²Œ
            const pommel = new THREE.Mesh(
                new THREE.CylinderGeometry(handleWidth * 0.8, handleWidth * 0.6, 0.015, 12),
                matSilver
            );
            pommel.rotation.x = Math.PI / 2;
            pommel.position.set(0, -0.02, handleLength - 0.005);
            knifeGroup.add(pommel);

            // === ê°€ë“œ (ì†ë³´í˜¸ëŒ€) - ë” í˜„ì‹¤ì ìœ¼ë¡œ ===
            const guardWidth = 0.04;
            const guard = new THREE.Mesh(
                new THREE.BoxGeometry(guardWidth, 0.012, 0.025),
                matSilver
            );
            guard.position.set(0, 0.005, 0);
            knifeGroup.add(guard);

            // ê°€ë“œ ëë¶€ë¶„ (ì–‘ìª½ìœ¼ë¡œ í™•ì¥)
            for (let side = -1; side <= 1; side += 2) {
                const guardTip = new THREE.Mesh(
                    new THREE.BoxGeometry(0.012, 0.012, 0.008),
                    matSilver
                );
                guardTip.position.set(side * (guardWidth / 2 + 0.006), 0.005, 0.012);
                knifeGroup.add(guardTip);
            }

            // === ì¹¼ë‚  ë³¸ì²´ - ë” í˜„ì‹¤ì ì´ê³  ë‚ ì¹´ë¡­ê²Œ ===
            const bladeLength = 0.22; // ë” ê¸¸ê²Œ
            const bladeWidth = 0.018; // ë” ë„“ê²Œ
            const bladeThickness = 0.004; // ë” ë‘ê»ê²Œ

            // ì¹¼ë‚  ë©”ì¸ ë°”ë”” (í…Œì´í¼ë§ëœ í˜•íƒœ)
            const bladeBody = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness, bladeWidth, bladeLength),
                matBlade
            );
            bladeBody.position.set(0, 0.025, -bladeLength / 2);
            knifeGroup.add(bladeBody);

            // ì¹¼ë‚  ë“± (Spine) - ë” ë¶€ë“œëŸ½ê³  í˜„ì‹¤ì ìœ¼ë¡œ
            const bladeSpine = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.6, bladeWidth * 0.25, bladeLength * 0.85),
                matBlade
            );
            bladeSpine.position.set(-bladeThickness * 0.2, 0.03, -bladeLength * 0.35);
            knifeGroup.add(bladeSpine);

            // ì¹¼ë‚  ë (Tip) - ë” ë‚ ì¹´ë¡­ê³  ë¾°ì¡±í•˜ê²Œ
            const bladeTip = new THREE.Mesh(
                new THREE.ConeGeometry(bladeWidth * 0.4, bladeLength * 0.25, 8),
                matBlade
            );
            bladeTip.rotation.x = Math.PI / 2;
            bladeTip.position.set(0, 0.025, -bladeLength);
            knifeGroup.add(bladeTip);

            // ì¹¼ë‚  ë‚  (Cutting Edge) - ë” ë‚ ì¹´ë¡­ê²Œ
            const bladeEdge = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.15, bladeWidth * 0.2, bladeLength * 0.98),
                matBlade
            );
            bladeEdge.position.set(bladeThickness * 0.125, 0.015, -bladeLength * 0.49);
            knifeGroup.add(bladeEdge);

            // ì¹¼ë‚  í™ˆ (Fuller/Blood Groove) - ë” ê¹Šê³  ëª…í™•í•˜ê²Œ
            const fuller = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.4, bladeWidth * 0.25, bladeLength * 0.65),
                matBlade
            );
            fuller.position.set(0, 0.025, -bladeLength * 0.45);
            fuller.material = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.3,
                metalness: 0.7
            });
            knifeGroup.add(fuller);

            // ì¹¼ë‚  ë² ì´ìŠ¤ (Ricasso) - ì¹¼ë‚ ê³¼ í•¸ë“¤ ì‚¬ì´ ë¶€ë¶„
            const ricasso = new THREE.Mesh(
                new THREE.BoxGeometry(bladeThickness * 0.9, bladeWidth * 0.9, bladeLength * 0.18),
                matBlade
            );
            ricasso.position.set(0, 0.025, -bladeLength * 0.09);
            knifeGroup.add(ricasso);

            // ì¹¼ë‚  ì¸¡ë©´ ë² ë²¨ (Bevel) - ë” í˜„ì‹¤ì ì¸ ë‚  í‘œí˜„
            for (let side = -1; side <= 1; side += 2) {
                const bevel = new THREE.Mesh(
                    new THREE.BoxGeometry(bladeThickness * 0.3, bladeWidth * 0.15, bladeLength * 0.9),
                    matBlade
                );
                bevel.position.set(side * bladeThickness * 0.35, 0.02, -bladeLength * 0.45);
                knifeGroup.add(bevel);
            }

            // === ë‚˜ì´í”„ ê°ë„ ì¡°ì • - ë” ìì—°ìŠ¤ëŸ½ê²Œ ===
            knifeGroup.rotation.y = Math.PI * 0.25; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ íšŒì „
            knifeGroup.rotation.z = -0.15; // ì†ëª© ê°ë„
            knifeGroup.rotation.x = 0.25; // ìœ„ë¡œ ê¸°ìš¸ì„

            // ë‚˜ì´í”„ í¬ê¸° ì¡°ì • - ë” í¬ê³  ëª…í™•í•˜ê²Œ
            knifeGroup.scale.set(2.0, 2.0, 2.0);

            const knifeHolder = new THREE.Group();
            knifeHolder.add(knifeGroup);
            // ë‚˜ì´í”„ ìœ„ì¹˜ ì¡°ì • - ë” ì˜ ë³´ì´ë„ë¡
            knifeHolder.position.set(0.3, -0.2, -0.35);
            weaponModel.add(knifeHolder);

            // === ì† ëª¨ë¸ - ë‚˜ì´í”„ë¥¼ ë” ìì—°ìŠ¤ëŸ½ê²Œ ì¥ë„ë¡ ===
            // ì˜¤ë¥¸ì† (ë‚˜ì´í”„ë¥¼ ì¥ëŠ” ì†) - ìœ„ì¹˜ì™€ ê°ë„ ê°œì„ 
            const rightArm = createArm(0.35, -0.2, -0.35, 0.08, -0.15, 0.2, false);
            rightArm.userData.isKnifeHand = true;

            // ì™¼ì† - ë‘ ì†ì„ í¬ê²Œ ë²Œë¦° ëª¨ìŠµ
            const leftArm = createArm(-0.4, -0.18, -0.25, 0.15, 0.4, -0.1, false);
            leftArm.userData.isLeftHand = true;
        }

        function createArm(x, y, z, rotX, rotY, rotZ, isTrigger) {
            const grp = new THREE.Group();
            const sleeve = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.06, 0.5, 12), matSleeve);
            sleeve.rotation.x = Math.PI / 2; sleeve.position.z = 0.25;
            grp.add(sleeve);
            const hand = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.08), matGlove);
            hand.position.z = -0.05;
            grp.add(hand);

            if (isTrigger) {
                const finger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.015, 0.05), matSkin);
                finger.position.set(0.01, 0.01, -0.1);
                grp.add(finger);
            } else {
                // ë‚˜ì´í”„ë¥¼ ì¥ëŠ” ì†ì¸ ê²½ìš° ì†ê°€ë½ì„ ë” ëª…í™•í•˜ê²Œ
                if (grp.userData && grp.userData.isKnifeHand) {
                    // ì† ë³¸ì²´ - ë‚˜ì´í”„ ì†ì¡ì´ë¥¼ ê°ì‹¸ëŠ” í˜•íƒœ
                    const handSize = 0.14;
                    const handMesh = new THREE.Mesh(
                        new THREE.BoxGeometry(handSize, 0.07, handSize * 0.8),
                        matGlove
                    );
                    handMesh.position.z = -0.04;
                    grp.add(handMesh);

                    // ë‚˜ì´í”„ë¥¼ ì¥ëŠ” ì†ê°€ë½ë“¤ - ë” ìì—°ìŠ¤ëŸ¬ìš´ ìœ„ì¹˜ì™€ ê°ë„
                    for (let i = 0; i < 4; i++) {
                        const finger = new THREE.Mesh(
                            new THREE.BoxGeometry(0.02, 0.02, 0.07),
                            matSkin
                        );
                        // ì†ê°€ë½ì´ ë‚˜ì´í”„ ì†ì¡ì´ë¥¼ ê°ì‹¸ëŠ” í˜•íƒœë¡œ ë°°ì¹˜
                        finger.position.set((i - 1.5) * 0.022, 0.025, -0.13);
                        finger.rotation.x = 0.1; // ì•½ê°„ êµ¬ë¶€ë¦° í˜•íƒœ
                        grp.add(finger);
                    }
                    // ì—„ì§€ - ë‚˜ì´í”„ ë°˜ëŒ€í¸ì— ìœ„ì¹˜
                    const thumb = new THREE.Mesh(
                        new THREE.BoxGeometry(0.018, 0.018, 0.06),
                        matSkin
                    );
                    thumb.position.set(0.06, 0.025, -0.1);
                    thumb.rotation.z = 0.4; // ë” êµ¬ë¶€ë¦° í˜•íƒœ
                    thumb.rotation.x = 0.2;
                    grp.add(thumb);
                } else if (grp.userData && grp.userData.isLeftHand) {
                    // ì™¼ì† (ë‚˜ì´í”„ë¥¼ ì¥ì§€ ì•Šì§€ë§Œ ë³´ì„)
                    const handSize = 0.1;
                    const handMesh = new THREE.Mesh(new THREE.BoxGeometry(handSize, 0.05, handSize), matGlove);
                    handMesh.position.z = -0.05;
                    grp.add(handMesh);

                    // ì™¼ì† ì†ê°€ë½ë“¤
                    for (let i = 0; i < 4; i++) {
                        const finger = new THREE.Mesh(new THREE.BoxGeometry(0.015, 0.015, 0.05), matSkin);
                        finger.position.set((i - 1.5) * 0.018, 0.015, -0.1);
                        grp.add(finger);
                    }
                    // ì™¼ì† ì—„ì§€
                    const thumb = new THREE.Mesh(new THREE.BoxGeometry(0.012, 0.012, 0.04), matSkin);
                    thumb.position.set(0.04, 0.015, -0.08);
                    thumb.rotation.z = -0.3;
                    grp.add(thumb);
                } else {
                    const fist = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.04, 0.04), matGlove);
                    fist.position.set(0, -0.02, -0.08);
                    grp.add(fist);
                }
            }

            grp.position.set(x, y, z);
            grp.rotation.set(rotX, rotY, rotZ);
            weaponModel.add(grp);
            return grp;
        }

        // --- Enemy AI & Parts ---
        function createEnemyAI() {
            const enemy = new THREE.Group();

            // FIX: Clone Materials to prevent shared color change
            const mClothes = matZombieClothes.clone();
            const mSkin = matZombieSkin.clone();

            // ëª¸í†µ (Body) - ë” ìƒì„¸í•˜ê²Œ
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.25), mClothes);
            body.position.y = 1.1; body.name = 'body'; enemy.add(body);

            // ê°€ìŠ´ ë¶€ë¶„ ë””í…Œì¼
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.3, 0.22), mClothes);
            chest.position.set(0, 1.25, 0.01);
            enemy.add(chest);

            // ì–´ê¹¨ (Shoulders)
            const lShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mClothes);
            lShoulder.position.set(-0.25, 1.4, 0);
            enemy.add(lShoulder);
            const rShoulder = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mClothes);
            rShoulder.position.set(0.25, 1.4, 0);
            enemy.add(rShoulder);

            // ë¨¸ë¦¬ (Head) - ë” ìƒì„¸í•˜ê²Œ
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.25), mSkin);
            head.position.y = 1.6; head.name = 'head'; enemy.add(head);

            // ë¨¸ë¦¬ í˜•íƒœ ê°œì„  (ì•½ê°„ êµ¬í˜•ìœ¼ë¡œ)
            const headShape = new THREE.Mesh(new THREE.SphereGeometry(0.13, 8, 8), mSkin);
            headShape.position.set(0, 1.6, 0);
            enemy.add(headShape);

            // ëˆˆ (Eyes) - ë¹¨ê°„ìƒ‰ìœ¼ë¡œ
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const lEye = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), eyeMat);
            lEye.position.set(-0.05, 1.62, 0.12);
            enemy.add(lEye);
            const rEye = new THREE.Mesh(new THREE.SphereGeometry(0.015, 6, 6), eyeMat);
            rEye.position.set(0.05, 1.62, 0.12);
            enemy.add(rEye);

            // ëª© (Neck)
            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.15, 8), mSkin);
            neck.rotation.z = Math.PI / 2;
            neck.position.set(0, 1.45, 0);
            enemy.add(neck);

            // ì˜¤ë¥¸íŒ” (Right Arm) - ë” ìƒì„¸í•˜ê²Œ
            const rUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8), mClothes);
            rUpperArm.rotation.z = Math.PI / 2;
            rUpperArm.position.set(0.3, 1.3, 0.2);
            rUpperArm.rotation.x = -1.2;
            rUpperArm.name = 'limb';
            enemy.add(rUpperArm);

            const rForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.25, 8), mClothes);
            rForearm.rotation.z = Math.PI / 2;
            rForearm.position.set(0.35, 1.15, 0.4);
            rForearm.rotation.x = -1.8;
            rForearm.name = 'limb';
            enemy.add(rForearm);
            enemy.userData.rArm = rForearm;

            // ì™¼íŒ” (Left Arm) - ë” ìƒì„¸í•˜ê²Œ
            const lUpperArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8), mClothes);
            lUpperArm.rotation.z = Math.PI / 2;
            lUpperArm.position.set(-0.3, 1.3, 0.2);
            lUpperArm.rotation.x = -1.2;
            lUpperArm.name = 'limb';
            enemy.add(lUpperArm);

            const lForearm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.25, 8), mClothes);
            lForearm.rotation.z = Math.PI / 2;
            lForearm.position.set(-0.35, 1.15, 0.4);
            lForearm.rotation.x = -1.8;
            lForearm.name = 'limb';
            enemy.add(lForearm);
            enemy.userData.lArm = lForearm;

            // ì† (Hands)
            const rHand = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.08), mSkin);
            rHand.position.set(0.4, 1.05, 0.5);
            enemy.add(rHand);
            const lHand = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.08), mSkin);
            lHand.position.set(-0.4, 1.05, 0.5);
            enemy.add(lHand);

            // ì™¼ë‹¤ë¦¬ (Left Leg) - ë” ìƒì„¸í•˜ê²Œ
            const lThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.4, 8), mClothes);
            lThigh.position.set(-0.15, 0.55, 0);
            lThigh.name = 'limb';
            enemy.add(lThigh);

            const lShin = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8), mClothes);
            lShin.position.set(-0.15, 0.175, 0);
            lShin.name = 'limb';
            enemy.add(lShin);

            // ì˜¤ë¥¸ë‹¤ë¦¬ (Right Leg) - ë” ìƒì„¸í•˜ê²Œ
            const rThigh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.4, 8), mClothes);
            rThigh.position.set(0.15, 0.55, 0);
            rThigh.name = 'limb';
            enemy.add(rThigh);

            const rShin = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8), mClothes);
            rShin.position.set(0.15, 0.175, 0);
            rShin.name = 'limb';
            enemy.add(rShin);

            // ë°œ (Feet)
            const lFoot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.2), mClothes);
            lFoot.position.set(-0.15, 0, 0.1);
            enemy.add(lFoot);
            const rFoot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.08, 0.2), mClothes);
            rFoot.position.set(0.15, 0, 0.1);
            enemy.add(rFoot);

            // HP Bar (Billboard)
            const hpGroup = new THREE.Group();
            const bgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpBg);
            const fgBar = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.08), matHpFg);
            fgBar.position.z = 0.01;
            hpGroup.add(bgBar);
            const fgWrapper = new THREE.Group();
            fgWrapper.add(fgBar);
            fgBar.position.x = 0.3; fgWrapper.position.x = -0.3; fgWrapper.position.z = 0.01;
            hpGroup.add(fgWrapper);
            hpGroup.position.set(0, 2.0, 0);
            enemy.add(hpGroup);
            enemy.userData.hpGroup = hpGroup;
            enemy.userData.hpBar = fgWrapper;

            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 20;
            enemy.position.set(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);

            // Generate safe spawn - ë” ë§ì€ ì‹œë„ì™€ ë” ì •í™•í•œ ì²´í¬
            let safe = false;
            for (let i = 0; i < 50; i++) {
                // Check if inside collider - ë” ì •í™•í•œ í¬ê¸°ë¡œ ì²´í¬
                const testBox = new THREE.Box3(
                    new THREE.Vector3(enemy.position.x - ENEMY_RADIUS, enemy.position.y, enemy.position.z - ENEMY_RADIUS),
                    new THREE.Vector3(enemy.position.x + ENEMY_RADIUS, enemy.position.y + 1.8, enemy.position.z + ENEMY_RADIUS)
                );
                let hits = false;
                for (let c of colliders) {
                    if (testBox.intersectsBox(c)) {
                        hits = true;
                        break;
                    }
                }
                if (!hits) {
                    safe = true;
                    break;
                }

                // Retry pos - ë” ë„“ì€ ë²”ìœ„ì—ì„œ ì‹œë„
                const ang = Math.random() * Math.PI * 2;
                const d = 15 + Math.random() * 35;
                enemy.position.set(Math.cos(ang) * d, 0, Math.sin(ang) * d);
            }

            // ì•ˆì „í•œ ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•´ë„ ìµœì¢… ìœ„ì¹˜ì—ì„œ ìŠ¤í° ì‹œë„ (ê²Œì„ ì§„í–‰ì„ ìœ„í•´)
            if (!safe) {
                // ìµœí›„ì˜ ìˆ˜ë‹¨: ì›ì ì—ì„œ ë” ë¨¼ ê±°ë¦¬ì—ì„œ ì‹œë„
                const finalAngle = Math.random() * Math.PI * 2;
                const finalDist = 25 + Math.random() * 20;
                enemy.position.set(Math.cos(finalAngle) * finalDist, 0, Math.sin(finalAngle) * finalDist);
                // ê·¸ë˜ë„ ì•ˆ ë˜ë©´ ê·¸ëƒ¥ ìŠ¤í° (ê²Œì„ ì§„í–‰ì„ ìœ„í•´)
            }

            enemy.userData.hp = 100;
            enemy.userData.maxHp = 100;
            enemy.userData.attackTimer = 0;
            enemy.userData.isDead = false;
            enemy.userData.moveSpeed = ZOMBIE_SPEED + Math.random();
            enemy.userData.animState = 0;
            enemy.userData.flashTimer = 0;
            enemy.userData.stuckTimer = 0; // ë¼ì–´ìˆëŠ” ì‹œê°„ ì¶”ì 
            enemy.userData.lastValidPos = enemy.position.clone(); // ë§ˆì§€ë§‰ ìœ íš¨í•œ ìœ„ì¹˜

            scene.add(enemy);
            enemies.push(enemy);
        }

        function updateEnemies(dt) {
            if (isDead) return;

            // Spawn - íƒ€ì´ë¨¸ëŠ” í•­ìƒ ì¦ê°€, ì  ìƒì„±ë§Œ ì¼ì‹œì •ì§€ ìƒíƒœê°€ ì•„ë‹ ë•Œ
            // ë¦¬ì   ìˆ˜ ì œí•œ ì—†ìŒ - ê²Œì„ì´ ëë‚  ë•Œê¹Œì§€ ê³„ì† ìŠ¤í°
            if (!isPaused) {
                spawnTimer += dt;
                if (spawnTimer >= SPAWN_INTERVAL) {
                    spawnTimer = 0; // íƒ€ì´ë¨¸ ë¦¬ì…‹ (ìƒì„± ì—¬ë¶€ì™€ ë¬´ê´€)
                    createEnemyAI();
                }
            }

            if (isPaused) return; // ì¼ì‹œì •ì§€ëŠ” ì  ì´ë™/ê³µê²©ë§Œ ì¤‘ì§€

            enemies.forEach(e => {
                if (e.userData.isDead) return;

                // Color Flash Update
                if (e.userData.flashTimer > 0) {
                    e.userData.flashTimer -= dt;
                    if (e.userData.flashTimer <= 0) {
                        e.children.forEach(c => {
                            if (c.isMesh && c.material && c.material.emissive) c.material.emissive.setHex(0x000000);
                        });
                    }
                }

                e.lookAt(position.x, e.position.y, position.z);
                e.userData.hpGroup.lookAt(camera.position);

                const dist = e.position.distanceTo(position);

                // --- Simple Enemy Collision vs Walls ---
                // Calculate desired move
                let nextPos = e.position.clone();
                if (dist > ATTACK_RANGE && e.userData.animState <= 0) {
                    const dir = new THREE.Vector3().subVectors(position, e.position).normalize();
                    const moveStep = dir.multiplyScalar(e.userData.moveSpeed * dt);

                    // í˜„ì¬ ìœ„ì¹˜ê°€ ë²½ì— ë¼ì–´ìˆëŠ”ì§€ ì²´í¬
                    const currentBox = new THREE.Box3(
                        new THREE.Vector3(e.position.x - ENEMY_RADIUS * 1.2, e.position.y, e.position.z - ENEMY_RADIUS * 1.2),
                        new THREE.Vector3(e.position.x + ENEMY_RADIUS * 1.2, e.position.y + 1.8, e.position.z + ENEMY_RADIUS * 1.2)
                    );
                    let isStuck = false;
                    for (const c of colliders) {
                        if (currentBox.intersectsBox(c)) {
                            isStuck = true;
                            break;
                        }
                    }

                    // ë²½ì— ë¼ì–´ìˆìœ¼ë©´ ë²½ì—ì„œ ë²—ì–´ë‚˜ë„ë¡ ì´ë™
                    if (isStuck) {
                        e.userData.stuckTimer += dt;

                        // 1ì´ˆ ì´ìƒ ë¼ì–´ìˆìœ¼ë©´ ê°•ì œ ì¬ë°°ì¹˜ (2ì´ˆâ†’1ì´ˆë¡œ ë‹¨ì¶•)
                        if (e.userData.stuckTimer > 1.0) {
                            // ì•ˆì „í•œ ìœ„ì¹˜ë¡œ ì¬ë°°ì¹˜
                            let newPos = null;
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const dist = 20 + Math.random() * 25;
                                const testPos = new THREE.Vector3(
                                    Math.cos(angle) * dist,
                                    0,
                                    Math.sin(angle) * dist
                                );
                                const testBox = new THREE.Box3(
                                    new THREE.Vector3(testPos.x - ENEMY_RADIUS * 1.5, testPos.y, testPos.z - ENEMY_RADIUS * 1.5),
                                    new THREE.Vector3(testPos.x + ENEMY_RADIUS * 1.5, testPos.y + 1.8, testPos.z + ENEMY_RADIUS * 1.5)
                                );
                                let canSpawn = true;
                                for (const c of colliders) {
                                    if (testBox.intersectsBox(c)) {
                                        canSpawn = false;
                                        break;
                                    }
                                }
                                if (canSpawn) {
                                    newPos = testPos;
                                    break;
                                }
                            }
                            if (newPos) {
                                e.position.copy(newPos);
                                e.userData.stuckTimer = 0;
                                e.userData.lastValidPos = newPos.clone();
                            }
                        } else {
                            // ë²½ì—ì„œ ë²—ì–´ë‚˜ê¸° ìœ„í•´ ë” ë§ì€ ë°©í–¥ê³¼ ë” ë¹ ë¥¸ ì†ë„ë¡œ ì‹œë„
                            const escapeDirs = [
                                new THREE.Vector3(1, 0, 0),
                                new THREE.Vector3(-1, 0, 0),
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3(0, 0, -1),
                                new THREE.Vector3(1, 0, 1).normalize(),
                                new THREE.Vector3(-1, 0, 1).normalize(),
                                new THREE.Vector3(1, 0, -1).normalize(),
                                new THREE.Vector3(-1, 0, -1).normalize(),
                                new THREE.Vector3(0.707, 0, 0.707),
                                new THREE.Vector3(-0.707, 0, 0.707),
                                new THREE.Vector3(0.707, 0, -0.707),
                                new THREE.Vector3(-0.707, 0, -0.707)
                            ];

                            let escaped = false;
                            for (const escapeDir of escapeDirs) {
                                // ë” ë¹ ë¥¸ íƒˆì¶œ ì†ë„ (5ë°°â†’8ë°°)
                                const escapeStep = escapeDir.multiplyScalar(e.userData.moveSpeed * dt * 8);
                                const escapePos = e.position.clone().add(escapeStep);
                                const escapeBox = new THREE.Box3(
                                    new THREE.Vector3(escapePos.x - ENEMY_RADIUS * 1.2, escapePos.y, escapePos.z - ENEMY_RADIUS * 1.2),
                                    new THREE.Vector3(escapePos.x + ENEMY_RADIUS * 1.2, escapePos.y + 1.8, escapePos.z + ENEMY_RADIUS * 1.2)
                                );
                                let canEscape = true;
                                for (const c of colliders) {
                                    if (escapeBox.intersectsBox(c)) {
                                        canEscape = false;
                                        break;
                                    }
                                }
                                if (canEscape) {
                                    e.position.copy(escapePos);
                                    e.userData.lastValidPos = escapePos.clone();
                                    escaped = true;
                                    break;
                                }
                            }

                            // ë²½ì—ì„œ ë²—ì–´ë‚˜ì§€ ëª»í•˜ë©´ ë§ˆì§€ë§‰ ìœ íš¨í•œ ìœ„ì¹˜ë¡œ ë³µê·€
                            if (!escaped) {
                                const distToLast = e.position.distanceTo(e.userData.lastValidPos);
                                if (distToLast > 0.5) {
                                    e.position.lerp(e.userData.lastValidPos, 0.3);
                                } else {
                                    // Yì¶•ìœ¼ë¡œë„ ì‹œë„
                                    e.position.y += 0.2;
                                }
                            } else {
                                e.userData.stuckTimer = 0; // íƒˆì¶œ ì„±ê³µ
                            }
                        }
                    } else {
                        // ì •ìƒ ì´ë™ ì¤‘ì´ë©´ ë§ˆì§€ë§‰ ìœ íš¨ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë° ë¼ì„ íƒ€ì´ë¨¸ ë¦¬ì…‹
                        e.userData.lastValidPos = e.position.clone();
                        e.userData.stuckTimer = 0;
                        // ì •ìƒ ì´ë™
                        let testPos = e.position.clone();
                        testPos.x += moveStep.x;
                        const eBoxX = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colX = false;
                        for (const c of colliders) { if (eBoxX.intersectsBox(c)) { colX = true; break; } }
                        if (!colX) e.position.x += moveStep.x;

                        testPos = e.position.clone();
                        testPos.z += moveStep.z;
                        const eBoxZ = new THREE.Box3(
                            new THREE.Vector3(testPos.x - ENEMY_RADIUS, testPos.y, testPos.z - ENEMY_RADIUS),
                            new THREE.Vector3(testPos.x + ENEMY_RADIUS, testPos.y + 1.8, testPos.z + ENEMY_RADIUS)
                        );
                        let colZ = false;
                        for (const c of colliders) { if (eBoxZ.intersectsBox(c)) { colZ = true; break; } }
                        if (!colZ) e.position.z += moveStep.z;
                    }

                    e.position.y = Math.abs(Math.sin(lastTime * 0.005)) * 0.1;
                }
                else if (dist <= ATTACK_RANGE) {
                    e.userData.attackTimer += dt;
                    if (e.userData.attackTimer > 1.0) {
                        e.userData.attackTimer = 0;
                        e.userData.animState = 0.5;
                        SoundGen.playZombieAttack();
                        damagePlayer(ZOMBIE_DMG);
                    }
                }

                if (e.userData.animState > 0) {
                    e.userData.animState -= dt;
                    const progress = 1 - (e.userData.animState / 0.5);
                    e.userData.rArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.userData.lArm.rotation.x = -1.6 - Math.sin(progress * Math.PI) * 1.0;
                    e.position.add(e.getWorldDirection(new THREE.Vector3()).multiplyScalar(Math.sin(progress * Math.PI) * 0.05));
                } else {
                    e.children.forEach(c => {
                        if (c.name === 'limb' && c.position.y > 1.0) c.rotation.x = -1.6;
                    });
                }
            });
        }

        function damagePlayer(amount) {
            if (isDead) return;
            playerHP -= amount;

            elHpBar.style.width = Math.max(0, playerHP) + '%';
            // HP number display removed - elHpText now shows "HP" only

            if (playerHP > 50) elHpBar.style.background = "#4caf50";
            else if (playerHP > 20) elHpBar.style.background = "#ff9800";
            else elHpBar.style.background = "#f44336";

            elDamage.style.opacity = 0.8;
            setTimeout(() => elDamage.style.opacity = 0, 100);

            if (playerHP <= 0) {
                isDead = true;
                elGameOver.style.display = 'flex';
                if (!isMobile && document.pointerLockElement === document.body) {
                    document.exitPointerLock();
                }
            }
        }

        function updatePlayersList() {
            const playersListEl = document.getElementById('players-list');
            playersListEl.innerHTML = '';
            playersList.forEach(player => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.textContent = player.name;
                playersListEl.appendChild(playerItem);
            });
            playersListEl.innerHTML += `<div style="margin-top: 10px; color: rgba(255,255,255,0.7);">ì°¸ì—¬ ì¸ì›: ${currentPlayers} / ${maxPlayers}</div>`;
        }

        function simulatePlayerJoin() {
            // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
        }


        // OLD DUPLICATE startCountdown - REMOVED (was shadowing the correct one at line 2470)
        // function startCountdown() { ... }

        // OLD DUPLICATE startGame - REMOVED (was shadowing the correct one at line 2493)
        // function startGame() { ... }


        function restartGame() {
            playerHP = 100;
            isDead = false;
            isPaused = false;
            spawnTimer = 0;
            elPauseOverlay.style.display = 'none';
            elHpBar.style.width = '100%';
            elHpText.innerText = "HP: 100";
            elGameOver.style.display = 'none';
            position.set(0, 1.7, 5);

            // ê²Œì„ í†µê³„ ë¦¬ì…‹
            gameStartTime = performance.now();
            killCount = 0;
            playTime = 0;
            if (elPlayTime) elPlayTime.innerText = "Time: 00:00";
            if (elKillCount) elKillCount.innerText = "Kills: 0";

            enemies.forEach(e => scene.remove(e));
            enemies = [];
            healthPills.forEach(pill => scene.remove(pill));
            healthPills = [];
            for (let i = 0; i < 6; i++) createEnemyAI();

            // ì¬ì‹œì‘ í›„ì—ëŠ” í¬ì¸í„° ì ê¸ˆì„ ìš”ì²­í•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ìê°€ í´ë¦­í•´ì•¼ í•¨)
            if (!isMobile && document.pointerLockElement === document.body) {
                document.exitPointerLock();
            }
        }

        // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ë³€ìˆ˜
        // ë” í™•ì‹¤í•œ ëª¨ë°”ì¼ ê°ì§€: User Agent + í„°ì¹˜ ì§€ì› + í™”ë©´ í¬ê¸°

        let touchMoveActive = false;
        let touchLookActive = false;
        let touchMoveId = null;
        let touchLookId = null;
        let lastTouchX = 0, lastTouchY = 0;
        let touchStartX = 0, touchStartY = 0;
        let isAimingHeld = false;

        function setupControls() {
            // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì„¤ì • - ë‹¤ì‹œ í•œë²ˆ í™•ì¸
            const isMobileDevice = isMobile ||
                ('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

            if (isMobileDevice) {
                setupMobileControls();
                console.log('Mobile controls enabled');
                // ëª¨ë°”ì¼ì—ì„œëŠ” í¬ì¸í„° ë½ ì‚¬ìš© ì•ˆ í•¨
            } else {
                console.log('Desktop controls enabled');
                // ë°ìŠ¤í¬í†±ì—ì„œë§Œ í¬ì¸í„° ë½ ì‚¬ìš©
                // í¬ì¸í„° ì ê¸ˆ ë³€ê²½ ê°ì§€
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement !== document.body && isPaused) {
                        // í¬ì¸í„° ì ê¸ˆì´ í•´ì œë˜ê³  ì¼ì‹œì •ì§€ ìƒíƒœë©´ ì˜¤ë²„ë ˆì´ ìœ ì§€
                        elPauseOverlay.style.display = 'flex';
                    }
                });

                document.body.addEventListener('mousedown', (e) => {
                    if (document.pointerLockElement !== document.body && !isDead && !isPaused) {
                        const promise = document.body.requestPointerLock();
                        if (promise) promise.catch(err => { });
                        return;
                    }
                    if (isDead || isPaused) return;
                    if (e.button === 0) isFiring = true;
                    if (e.button === 2) isAiming = true;
                });

                document.body.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { isFiring = false; hasFiredSemi = false; hasClickedEmpty = false; }
                    if (e.button === 2) isAiming = false;
                });
                document.body.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body && !isDead && !isPaused) {
                        const sens = isAiming ? SENSITIVITY_ADS : SENSITIVITY_MOUSE;
                        rotation.y -= e.movementX * sens;
                        rotation.x -= e.movementY * sens;
                        rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                        const ray = new THREE.Raycaster();
                        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const targets = scene.children.filter(c => c !== weaponContainer);
                        const hits = ray.intersectObjects(targets, true);

                        let enemyFound = false;
                        for (let h of hits) {
                            let p = h.object;
                            while (p) {
                                if (p.userData && p.userData.hp !== undefined) {
                                    enemyFound = true;
                                    break;
                                }
                                if (p.parent === scene) break;
                                p = p.parent;
                            }
                            if (enemyFound) break;
                        }

                        if (enemyFound) elCrosshair.classList.add('enemy-detected');
                        else elCrosshair.classList.remove('enemy-detected');
                    }
                });
            }

            window.addEventListener('keydown', e => {
                // ESC í‚¤ ì²˜ë¦¬ - keyì™€ code ëª¨ë‘ ì²´í¬
                if (e.key === 'Escape' || e.key === 'Esc' || e.code === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    if (!isPaused && !isDead) {
                        isPaused = true;
                        elPauseOverlay.style.display = 'flex';
                        if (document.pointerLockElement === document.body) {
                            document.exitPointerLock();
                        }
                    } else if (isPaused) {
                        isPaused = false;
                        elPauseOverlay.style.display = 'none';
                        // ì¬ê°œ ì‹œ í¬ì¸í„° ì ê¸ˆì€ ì‚¬ìš©ìê°€ í´ë¦­í•´ì•¼ í•¨
                    }
                    return false;
                }
                const k = e.key.toLowerCase();
                if (isDead || isPaused) return;
                if (k === 'w') keys.w = 1;
                if (k === 's') keys.s = 1;
                if (k === 'a') keys.a = 1;
                if (k === 'd') keys.d = 1;
                if (k === 'shift') keys.shift = true;
                if (k === 'control') keys.ctrl = true;
                if (k === ' ') {
                    if (!keys.space && isGrounded) {
                        velocityY = 8.0;
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }
                if (k === '1') switchWeaponTo(0);
                if (k === '2') switchWeaponTo(1);
                if (k === '3') switchWeaponTo(2);
                if (k === '4') switchWeaponTo(3);
                if (k === 'tab') { e.preventDefault(); switchWeaponTo((curWeaponIdx + 1) % 4); }
                if (k === 'r') doReload();
            });

            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if (k === 'w') keys.w = 0;
                if (k === 's') keys.s = 0;
                if (k === 'a') keys.a = 0;
                if (k === 'd') keys.d = 0;
                if (k === 'shift') keys.shift = false;
                if (k === 'control') keys.ctrl = false;
                if (k === ' ') keys.space = false;
            });
        }

        // ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ ì„¤ì •
        function setupMobileControls() {
            console.log('Setting up mobile controls');

            const screenWidth = window.innerWidth;
            const leftHalf = screenWidth / 2;

            // --- Mobile Controls Refactor (Joystick & Full Screen Look) ---

            // Joystick Variables
            const joystickZone = document.getElementById('joystick-zone');
            const joystickHandle = document.getElementById('joystick-handle');
            let joystickTouchId = null;
            const joystickMaxRadius = 35; // Handle movement range
            const joystickCenter = { x: 0, y: 0 };

            // Weapon Selector Variables
            const weaponSelectBtns = document.querySelectorAll('.weapon-select-btn');

            // 1. Joystick Logic
            if (joystickZone && joystickHandle) {
                joystickZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const touch = e.changedTouches[0];
                    joystickTouchId = touch.identifier;

                    // Center is relative to the zone
                    const rect = joystickZone.getBoundingClientRect();
                    joystickCenter.x = rect.left + rect.width / 2;
                    joystickCenter.y = rect.top + rect.height / 2;

                    updateJoystick(touch.clientX, touch.clientY);
                }, { passive: false });

                joystickZone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                    if (touch) {
                        updateJoystick(touch.clientX, touch.clientY);
                    }
                }, { passive: false });

                const endJoystick = (e) => {
                    e.preventDefault();
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickTouchId);
                    if (touch) {
                        joystickTouchId = null;
                        joystickHandle.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
                        keys.w = 0; keys.s = 0; keys.a = 0; keys.d = 0;
                    }
                };
                joystickZone.addEventListener('touchend', endJoystick);
                joystickZone.addEventListener('touchcancel', endJoystick);
            }

            function updateJoystick(clientX, clientY) {
                const dx = clientX - joystickCenter.x;
                const dy = clientY - joystickCenter.y;
                const distance = Math.min(Math.sqrt(dx * dx + dy * dy), joystickMaxRadius);
                const angle = Math.atan2(dy, dx);

                const moveX = distance * Math.cos(angle);
                const moveY = distance * Math.sin(angle);

                joystickHandle.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;

                // Map to keys (normalized 0-1)
                const normX = moveX / joystickMaxRadius;
                const normY = moveY / joystickMaxRadius; // Up is negative in screen coords

                // Reset keys
                keys.w = 0; keys.s = 0; keys.a = 0; keys.d = 0;

                // Threshold for movement
                if (Math.abs(normY) > 0.1) {
                    if (normY < 0) keys.w = Math.abs(normY);
                    else keys.s = Math.abs(normY);
                }
                if (Math.abs(normX) > 0.1) {
                    if (normX < 0) keys.a = Math.abs(normX);
                    else keys.d = Math.abs(normX);
                }
            }

            // 2. Camera Look Logic (Full Screen Drag)
            let touchLookId = null;
            let lastTouchX = 0;
            let lastTouchY = 0;

            document.body.addEventListener('touchstart', (e) => {
                const target = e.target;
                // Allow camera rotation while shooting/aiming (exclude only joystick, weapon selector, light toggle, jump, reload)
                if (target.closest('#joystick-zone') ||
                    target.closest('.weapon-select-btn') ||
                    target.closest('#light-toggle-btn') ||
                    target.closest('#btn-jump') ||
                    target.closest('#btn-reload')) {
                    return;
                }

                e.preventDefault();
                const touch = e.changedTouches[0];
                touchLookId = touch.identifier;
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }, { passive: false });

            document.body.addEventListener('touchmove', (e) => {
                if (touchLookId === null) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchLookId);
                if (!touch) return;

                const target = e.target;
                // Allow camera rotation while shooting/aiming (exclude only joystick, weapon selector, and light toggle)
                if (target.closest('#joystick-zone') ||
                    target.closest('.weapon-select-btn') ||
                    target.closest('#light-toggle-btn') ||
                    target.closest('#btn-jump') ||
                    target.closest('#btn-reload')) {
                    return;
                }

                const moveDx = touch.clientX - lastTouchX;
                const moveDy = touch.clientY - lastTouchY;

                // Sensitivity
                // Sensitivity - User requested 3-4x increase
                const sens = (isAiming ? SENSITIVITY_ADS * 5.0 : SENSITIVITY_MOUSE * 4.0);
                rotation.y -= moveDx * sens;
                rotation.x -= moveDy * sens;
                rotation.x = Math.max(-1.5, Math.min(1.5, rotation.x));

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }, { passive: false });

            document.body.addEventListener('touchend', (e) => {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchLookId);
                if (touch) {
                    touchLookId = null;
                }
            });

            // 3. Weapon Selector Logic
            weaponSelectBtns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.idx);
                    switchWeaponTo(idx);

                    // Update Active State
                    weaponSelectBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                }, { passive: false });
            });

            // ëª¨ë°”ì¼ ë²„íŠ¼ ì´ë²¤íŠ¸
            const btnJump = document.getElementById('btn-jump');
            const btnReload = document.getElementById('btn-reload');
            // btnCycle ì œê±°
            const btnShoot = document.getElementById('btn-shoot');
            const btnAim = document.getElementById('btn-aim');

            if (btnJump) {
                btnJump.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!keys.space && isGrounded) {
                        velocityY = 8.0;
                        isGrounded = false;
                        SoundGen.playJump(false);
                    }
                    keys.space = true;
                }, { passive: false });
                btnJump.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    keys.space = false;
                }, { passive: false });
            }

            if (btnReload) {
                btnReload.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    doReload();
                }, { passive: false });
            }

            // btnCycle logic removed

            if (btnShoot) {
                btnShoot.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // e.stopPropagation() ì œê±° - ê²©ë°œí•˜ë©´ì„œ ì¹´ë©”ë¼ íšŒì „ ê°€ëŠ¥í•˜ë„ë¡
                    isFiring = true;
                }, { passive: false });
                btnShoot.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    // e.stopPropagation() ì œê±°
                    isFiring = false;
                }, { passive: false });
            }

            // ì¡°ì¤€ ë²„íŠ¼ - ì €ê²© ëª¨ë“œëŠ” ì¡°ì¤€ë§Œ, ì†Œì´ì€ ì¡°ì¤€+ë°œì‚¬, ê¶Œì´ì€ ë°œì‚¬ë§Œ
            if (btnAim) {
                btnAim.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // e.stopPropagation() ì œê±° - ì¡°ì¤€í•˜ë©´ì„œ ì¹´ë©”ë¼ íšŒì „ ê°€ëŠ¥í•˜ë„ë¡
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // ê¶Œì´ì€ ì¡°ì¤€ ëª¨ë“œê°€ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë°œì‚¬ë§Œ
                        isFiring = true;
                    } else {
                        // ì†Œì´, ì €ê²©ì´ì€ ì¡°ì¤€ ëª¨ë“œ í™œì„±í™”
                        isAimingHeld = true;
                        isAiming = true;
                        if (w.type !== 'SNIPER') {
                            isFiring = true; // ì†Œì´ì€ ìë™ ë°œì‚¬ ì‹œì‘
                        } else {
                            isFiring = false; // ì €ê²© ëª¨ë“œëŠ” ì™¼ìª½ í„°ì¹˜ë¡œ ë°œì‚¬
                        }
                    }
                }, { passive: false });

                btnAim.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const w = WEAPONS[curWeaponIdx];

                    if (w.type === 'PISTOL') {
                        // ê¶Œì´ì€ ë°œì‚¬ë§Œ ì¤‘ì§€
                        isFiring = false;
                        hasFiredSemi = false;
                    } else {
                        // ì†Œì´, ì €ê²©ì´ì€ ì¡°ì¤€ ëª¨ë“œë„ í•´ì œ
                        isAimingHeld = false;
                        isAiming = false;
                        isFiring = false;
                        hasFiredSemi = false;
                    }
                }, { passive: false });
            }
        }

        // PC ê°ë„ ì¡°ì • ì„¤ì •
        function setupSensitivityControl() {
            if (isMobile) return; // ëª¨ë°”ì¼ì—ì„œëŠ” í‘œì‹œ ì•ˆ í•¨

            const sensitivityControl = document.getElementById('sensitivity-control');
            const sensitivitySlider = document.getElementById('sensitivity-slider');
            const sensitivityValue = document.getElementById('sensitivity-value');

            if (!sensitivityControl || !sensitivitySlider || !sensitivityValue) return;

            // PCì—ì„œë§Œ í‘œì‹œ
            sensitivityControl.style.display = 'block';

            // í˜„ì¬ ê°ë„ë¡œ ìŠ¬ë¼ì´ë” ì„¤ì •
            sensitivitySlider.value = SENSITIVITY_MOUSE;
            updateSensitivityDisplay();

            // ìŠ¬ë¼ì´ë” ë³€ê²½ ì´ë²¤íŠ¸
            sensitivitySlider.addEventListener('input', (e) => {
                const newSensitivity = parseFloat(e.target.value);
                SENSITIVITY_MOUSE = newSensitivity;
                SENSITIVITY_ADS = newSensitivity * 0.25; // ADSëŠ” ì¼ë°˜ ê°ë„ì˜ 25%

                // localStorageì— ì €ì¥
                localStorage.setItem('mouseSensitivity', newSensitivity.toString());

                updateSensitivityDisplay();
            });

            function updateSensitivityDisplay() {
                // 0.002ë¥¼ ê¸°ì¤€(1.0)ìœ¼ë¡œ í‘œì‹œ
                const displayValue = (SENSITIVITY_MOUSE / 0.002).toFixed(2);
                sensitivityValue.textContent = displayValue;
            }
        }

        function switchWeaponTo(idx) {
            if (curWeaponIdx === idx) return;
            isReloading = false;
            const w = WEAPONS[idx];
            // ëª¨ë°”ì¼ì—ì„œ ê¶Œì´ìœ¼ë¡œ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ì¡°ì¤€ ëª¨ë“œ í™œì„±í™”
            if (isMobile && w.type === 'PISTOL') {
                isAiming = true;
            } else {
                isAiming = false;
            }
            curWeaponIdx = idx;
            buildWeapon(curWeaponIdx);
            // ë¬´ê¸° ì „í™˜ ì‹œ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ë‚˜ì´í”„ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ)
            if (w.type !== 'KNIFE') {
                weaponModel.position.y = -0.5;
                weaponModel.position.x = 0;
                weaponModel.position.z = 0;
                weaponModel.rotation.x = 0;
                weaponModel.rotation.y = 0;
                weaponModel.rotation.z = 0;
            } else {
                // ë‚˜ì´í”„ëŠ” ê¸°ë³¸ ìœ„ì¹˜ ì„¤ì • (ê°œì„ ëœ ìœ„ì¹˜)
                weaponModel.position.x = 0.3;
                weaponModel.position.y = -0.2;
                weaponModel.position.z = -0.35;
                weaponModel.rotation.x = 0.25;
                weaponModel.rotation.y = 0;
                weaponModel.rotation.z = -0.15;
            }

            // ë¬´ê¸°ë³„ êµì²´ ì†Œë¦¬ ì ìš©
            if (w.type === 'KNIFE' && SoundGen.audioBuffers['c-sword']) {
                // ë‚˜ì´í”„ë¡œ ì „í™˜
                SoundGen.playAudioFile('c-sword', 0.8);
            } else if (w.type === 'RIFLE' && SoundGen.audioBuffers['c-sochong']) {
                // ì†Œì´ìœ¼ë¡œ ì „í™˜ (1ë²ˆ)
                SoundGen.playAudioFile('c-sochong', 0.8);
            } else if (w.type === 'PISTOL' && SoundGen.audioBuffers['c-gun']) {
                // ê¶Œì´ìœ¼ë¡œ ì „í™˜ (2ë²ˆ)
                SoundGen.playAudioFile('c-gun', 0.8);
            } else if (w.type === 'SNIPER' && SoundGen.audioBuffers['c-rifle']) {
                // ì €ê²©ì´ìœ¼ë¡œ ì „í™˜ (3ë²ˆ)
                SoundGen.playAudioFile('c-rifle', 0.8);
            } else {
                // ê¸°ì¡´ ì†Œë¦¬ (í´ë°±)
                SoundGen.playSwitch();
            }
            updateUI();
        }

        function updateUI() {
            const w = WEAPONS[curWeaponIdx];
            elWeaponLabel.innerText = w.name;
            elAmmoVal.classList.remove('no-ammo');
            if (w.type === 'KNIFE') elAmmoVal.innerText = "-";
            else elAmmoVal.innerText = w.ammo + " / " + w.maxAmmo * 4;
        }

        function doReload() {
            const w = WEAPONS[curWeaponIdx];
            if (w.type === 'KNIFE') return;
            isReloading = true;

            // ì €ê²©ì´ì€ c-rifle.mp3 ì‚¬ìš©, ë‹¤ë¥¸ ë¬´ê¸°ëŠ” ê¸°ì¡´ ì¬ì¥ì „ ì†Œë¦¬
            if (w.type === 'SNIPER' && SoundGen.audioBuffers['c-rifle']) {
                SoundGen.playAudioFile('c-rifle', 0.8);
            } else {
                SoundGen.playReload();
            }

            elWeaponLabel.innerText = "RELOADING...";
            weaponModel.rotation.z = 0.5;
            weaponModel.position.y = -0.1;
            setTimeout(() => {
                w.ammo = w.maxAmmo;
                isReloading = false;
                weaponModel.rotation.z = 0;
                weaponModel.position.y = 0;
                updateUI();
            }, 1000);
        }

        function createDecal(pos, normal) {
            if (!normal) return;
            const size = 0.1 + Math.random() * 0.05;
            const geo = new THREE.PlaneGeometry(size, size);
            const decal = new THREE.Mesh(geo, matDecal);
            decal.position.copy(pos);
            decal.lookAt(pos.clone().add(normal));
            decal.position.add(normal.multiplyScalar(0.01));
            scene.add(decal);
            decals.push(decal);
            if (decals.length > 50) {
                const old = decals.shift();
                scene.remove(old);
            }
        }

        function spawnShell() {
            const shell = new THREE.Mesh(shellGeo, shellMat);
            const weaponPos = new THREE.Vector3();
            weaponModel.getWorldPosition(weaponPos);
            const weaponQuat = new THREE.Quaternion();
            weaponModel.getWorldQuaternion(weaponQuat);

            shell.position.copy(weaponPos);
            shell.quaternion.copy(weaponQuat);

            shell.translateX(0.05);
            shell.translateY(0.08);
            shell.translateZ(-0.02);

            const force = 3.0 + Math.random();
            const vel = new THREE.Vector3(1.0, 0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
            vel.normalize().multiplyScalar(force);
            vel.applyQuaternion(shell.quaternion);

            scene.add(shell);

            shells.push({
                mesh: shell,
                velocity: vel,
                rotVel: new THREE.Vector3(Math.random(), Math.random(), Math.random()).multiplyScalar(10),
                life: 2.0
            });
        }

        function updateShells(dt) {
            for (let i = shells.length - 1; i >= 0; i--) {
                const s = shells[i];
                s.life -= dt;

                if (s.life <= 0) {
                    scene.remove(s.mesh);
                    shells.splice(i, 1);
                    continue;
                }

                s.velocity.y -= 9.8 * dt;
                s.mesh.position.addScaledVector(s.velocity, dt);

                s.mesh.rotation.x += s.rotVel.x * dt;
                s.mesh.rotation.y += s.rotVel.y * dt;
                s.mesh.rotation.z += s.rotVel.z * dt;

                if (s.mesh.position.y < 0.01) {
                    s.mesh.position.y = 0.01;
                    s.velocity.y *= -0.5;
                    s.velocity.x *= 0.7;
                    s.velocity.z *= 0.7;
                }
            }
        }

        // --- Blood Particle System ---
        function createBlood(pos) {
            const particleCount = 8;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).normalize().multiplyScalar(Math.random() * 2);
                velocities.push(vel);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particles = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xaa0000, size: 0.05 }));
            scene.add(particles);

            bloodParticles.push({ mesh: particles, velocities: velocities, life: 0.5 });
        }

        function updateParticles(dt) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const bp = bloodParticles[i];
                bp.life -= dt;
                if (bp.life <= 0) {
                    scene.remove(bp.mesh);
                    bloodParticles.splice(i, 1);
                    continue;
                }

                const positions = bp.mesh.geometry.attributes.position.array;
                for (let j = 0; j < bp.velocities.length; j++) {
                    positions[j * 3] += bp.velocities[j].x * dt;
                    positions[j * 3 + 1] += bp.velocities[j].y * dt;
                    positions[j * 3 + 2] += bp.velocities[j].z * dt;
                }
                bp.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        function createHealthPill(pos) {
            const pillGroup = new THREE.Group();
            // ì•Œì•½ í¬ê¸° í™•ëŒ€
            const pillBody = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.15, 8), matHealthPill);
            pillBody.rotation.x = Math.PI / 2;
            pillGroup.add(pillBody);

            // ë¹›ë‚˜ëŠ” íš¨ê³¼ë¥¼ ìœ„í•œ PointLight ì¶”ê°€
            const pillLight = new THREE.PointLight(0xff00ff, 1.5, 2);
            pillLight.position.set(0, 0, 0);
            pillGroup.add(pillLight);

            pillGroup.position.copy(pos);
            pillGroup.position.y = 0.8;
            pillGroup.userData.isHealthPill = true;
            pillGroup.userData.pillLight = pillLight;
            pillGroup.userData.baseY = 0.8; // ì›ë˜ Y ìœ„ì¹˜ ì €ì¥
            pillGroup.userData.floatTime = 0; // ë¶€ë™ ì• ë‹ˆë©”ì´ì…˜ìš© ì‹œê°„
            pillGroup.userData.lifeTime = 0; // ì•Œì•½ ìˆ˜ëª… (30ì´ˆ í›„ ì‚­ì œ)
            scene.add(pillGroup);
            healthPills.push(pillGroup);
        }

        function updateHealthPills(dt) {
            for (let i = healthPills.length - 1; i >= 0; i--) {
                const pill = healthPills[i];

                // ìˆ˜ëª… ì¦ê°€
                pill.userData.lifeTime += dt;

                // 30ì´ˆ ì§€ë‚˜ë©´ ì‚­ì œ
                if (pill.userData.lifeTime >= 30.0) {
                    scene.remove(pill);
                    healthPills.splice(i, 1);
                    continue;
                }

                // íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                pill.rotation.y += dt * 2;

                // ë¶€ë™ ì• ë‹ˆë©”ì´ì…˜ (ì›ë˜ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë¶€ìœ )
                pill.userData.floatTime += dt;
                pill.position.y = pill.userData.baseY + Math.sin(pill.userData.floatTime * 3) * 0.1;

                // í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ì²´í¬ (3D ê±°ë¦¬)
                const dist = pill.position.distanceTo(position);
                if (dist < 1.2) {
                    // HP íšŒë³µ
                    const oldHP = playerHP;
                    playerHP = Math.min(100, playerHP + 20);

                    if (playerHP !== oldHP) { // ì‹¤ì œë¡œ íšŒë³µëœ ê²½ìš°ì—ë§Œ
                        elHpBar.style.width = playerHP + '%';
                        elHpText.innerText = "HP: " + playerHP;
                        if (playerHP > 50) elHpBar.style.background = "#4caf50";
                        else if (playerHP > 20) elHpBar.style.background = "#ff9800";
                        else elHpBar.style.background = "#f44336";

                        // íš¨ê³¼ìŒ ì¬ìƒ
                        SoundGen.playHealthPill();
                    }

                    scene.remove(pill);
                    healthPills.splice(i, 1);
                }
            }
        }

        let fireTimer = 0;
        function handleShooting(dt) {
            if (isDead) return;
            const w = WEAPONS[curWeaponIdx];

            if (fireCooldown > 0) fireCooldown -= dt;

            if (knifeSwing > 0) {
                knifeSwing -= dt * 4.5; // ì•½ê°„ ëŠë¦¬ê²Œ (ë” ìì—°ìŠ¤ëŸ½ê²Œ)
                const swingProgress = knifeSwing; // 1.0 -> 0.0
                const swingPhase = 1.0 - swingProgress; // 0.0 -> 1.0

                // ë¶€ë“œëŸ¬ìš´ ê°€ì†/ê°ì† ê³¡ì„  (ease-in-out)
                const swingEase = 0.5 - 0.5 * Math.cos(swingPhase * Math.PI); // 0.0 -> 1.0 (ë¶€ë“œëŸ¬ìš´ Sì ê³¡ì„ )
                const swingEaseOut = Math.sin(swingPhase * Math.PI); // 0.0 -> 1.0 -> 0.0

                // ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í¬ê²Œ íœ˜ë‘ë¥´ê¸° - ë²”ìœ„ í™•ëŒ€
                const startX = -0.7;
                const endX = 0.7;
                weaponModel.position.x = startX + (endX - startX) * swingEase;

                // ì†ëª© íšŒì „ (Yì¶•) - ë” ë„“ì€ ë²”ìœ„ë¡œ íœ˜ë‘ë¥´ê¸°
                const rotationY = -2.5 + (2.5 - (-2.5)) * swingEase;
                weaponModel.rotation.y = rotationY;

                // ì†ëª© íšŒì „ (Zì¶•) - ìì—°ìŠ¤ëŸ¬ìš´ íœ˜ë‘ë¦„
                weaponModel.rotation.z = -0.15 + swingEaseOut * 0.7;

                // ì†ëª© íšŒì „ (Xì¶•) - ìœ„ì•„ë˜ ì›€ì§ì„
                weaponModel.rotation.x = 0.25 + swingEaseOut * 0.3;

                // ì•ë’¤ ì´ë™ - ë” í° ë²”ìœ„
                weaponModel.position.z = -0.3 + swingEaseOut * 0.3;

                // ìœ„ì•„ë˜ ì›€ì§ì„ - ë” ìì—°ìŠ¤ëŸ½ê²Œ
                weaponModel.position.y = -0.2 + swingEaseOut * 0.15;

                if (knifeSwing < 0) {
                    knifeSwing = 0;
                    // ê¸°ë³¸ ìœ„ì¹˜ë¡œ ë³µê·€
                    weaponModel.rotation.y = 0;
                    weaponModel.rotation.z = -0.15;
                    weaponModel.rotation.x = 0.25;
                    weaponModel.position.x = 0.3;
                    weaponModel.position.z = -0.35;
                    weaponModel.position.y = -0.2;
                }
            }

            if (isFiring && !isReloading) {
                if (w.type === 'KNIFE' || w.ammo > 0) {
                    if (fireCooldown <= 0) {
                        if (w.automatic) {
                            fireCooldown = w.fireRate;
                            shoot(w);
                        } else {
                            if (!hasFiredSemi) {
                                fireCooldown = w.fireRate;
                                shoot(w);
                                hasFiredSemi = true;
                            }
                        }
                    }
                } else if (w.ammo <= 0 && w.type !== 'KNIFE') {
                    // ë§¤ë²ˆ ë¹ˆ ê²©ë°œ ì†Œë¦¬ ì¬ìƒ (hasClickedEmpty ì²´í¬ ì œê±°)
                    if (fireCooldown <= 0) {
                        SoundGen.playDryFire();
                        elAmmoVal.classList.add('no-ammo');
                        setTimeout(() => elAmmoVal.classList.remove('no-ammo'), 200);
                        fireCooldown = 0.2; // ë¹ˆ ê²©ë°œë„ ì¿¨ë‹¤ìš´ ì ìš©
                    }
                }
            }
        }

        function shoot(w) {
            // ë©€í‹°í”Œë ˆì´ì–´ì—ì„œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ ë°œì‚¬ ì•Œë¦¼
            if (gameMode === 'multi' && socket && socket.connected) {
                socket.emit('playerAction', {
                    action: 'shoot',
                    weaponIdx: curWeaponIdx
                });
            }

            if (w.type !== 'KNIFE') {
                w.ammo--;
                updateUI();
                const kick = isAiming ? w.recoil * 0.3 : w.recoil;
                recoil.x += kick; recoil.z += kick;

                if (muzzleFlash) {
                    muzzleFlash.visible = true;
                    muzzleFlash.rotation.z = Math.random() * 6;
                    setTimeout(() => muzzleFlash.visible = false, 30);
                }

                if (w.type === 'SNIPER') {
                    // PC ëª¨ë“œì—ì„œë§Œ ì¬ì¥ì „ ì œìŠ¤ì²˜ ì¶”ê°€
                    if (!isMobile) {
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            sniperReloadGesture = true;
                            // ì¬ì¥ì „ ì œìŠ¤ì²˜: boltë¥¼ ë‹¹ê¸°ê³  ë‹¤ì‹œ ë°€ì–´ë„£ê¸°
                            const originalRotZ = weaponModel.rotation.z;
                            const originalPosZ = weaponModel.position.z;
                            const originalPosY = weaponModel.position.y;

                            // boltë¥¼ ë’¤ë¡œ ë‹¹ê¸°ê¸°
                            weaponModel.rotation.z = originalRotZ + 0.4;
                            weaponModel.position.z = originalPosZ - 0.08;
                            weaponModel.position.y = originalPosY - 0.04;
                            setTimeout(() => {
                                // boltë¥¼ ì•ìœ¼ë¡œ ë°€ì–´ë„£ê¸°
                                weaponModel.rotation.z = originalRotZ + 0.15;
                                setTimeout(() => {
                                    // ì›ë˜ ìœ„ì¹˜ë¡œ ë³µê·€
                                    weaponModel.rotation.z = originalRotZ;
                                    weaponModel.position.z = originalPosZ;
                                    weaponModel.position.y = originalPosY;
                                    sniperReloadGesture = false;
                                }, 150);
                            }, 250);
                        }, 600);
                    } else {
                        // ëª¨ë°”ì¼ì—ì„œëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
                        setTimeout(() => {
                            SoundGen.playBoltAction();
                            weaponModel.rotation.z = 0.2;
                            setTimeout(() => weaponModel.rotation.z = 0, 200);
                        }, 600);
                    }
                }

                // FIXED: REMOVED THE BUGGY EMISSIVE FLASH CODE HERE

                spawnShell();
                SoundGen.playShoot(w.type);
            } else {
                knifeSwing = 1.0;
                SoundGen.playKnife();
            }


            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            if (!isAiming && w.type !== 'KNIFE') {
                ray.ray.direction.x += (Math.random() - 0.5) * 0.05;
                ray.ray.direction.y += (Math.random() - 0.5) * 0.05;
            }
            const range = (w.type === 'KNIFE') ? 3.0 : 100;

            const targets = scene.children.filter(obj => obj !== weaponContainer);
            const hits = ray.intersectObjects(targets, true);

            for (let h of hits) {
                if (h.distance > range) continue;

                let isEnemy = false;
                let isOtherPlayer = false;
                let p = h.object;

                // Fix: Find parent with userData.hp
                while (p) {
                    if (p.userData && p.userData.hp !== undefined) {
                        // ë‹¤ë¥¸ í”Œë ˆì´ì–´ì¸ì§€ í™•ì¸ (playerIdê°€ ìˆìœ¼ë©´ ë‹¤ë¥¸ í”Œë ˆì´ì–´)
                        if (gameMode === 'multi' && p.userData.playerId !== undefined) {
                            isOtherPlayer = true;
                        } else {
                            isEnemy = true;
                        }
                        break;
                    }
                    if (p.parent === scene || !p.parent) break;
                    p = p.parent;
                }

                if (!isEnemy && !isOtherPlayer) {
                    // Check if it's a map collider before placing decal
                    if (w.type !== 'KNIFE' && h.object.geometry && h.face) createDecal(h.point, h.face.normal);
                }

                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—ê²Œ ë°ë¯¸ì§€
                if (isOtherPlayer && p.userData.hp > 0) {
                    let dmg = w.damage;
                    if (h.object.name === 'head') {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (h.object.name === 'limb') {
                        dmg *= 0.7;
                    }

                    // ì„œë²„ì— ë°ë¯¸ì§€ ì´ë²¤íŠ¸ ì „ì†¡
                    if (socket && socket.connected) {
                        socket.emit('damagePlayer', {
                            targetId: p.userData.playerId,
                            damage: dmg
                        });
                    }

                    // íˆíŠ¸ë§ˆì»¤ ë“±ì€ ë¡œì»¬ì—ì„œ ì¦‰ì‹œ í‘œì‹œ
                    elHitMarker.style.opacity = 1;
                    setTimeout(() => elHitMarker.style.opacity = 0, 100);
                    SoundGen.playHit();
                    createBlood(h.point);
                    break;
                }

                if (isEnemy && p.userData.hp > 0) {
                    // ê°•í•œ íˆíŠ¸ë§ˆì»¤ íš¨ê³¼
                    elHitMarker.style.opacity = 1;
                    elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1.5)";
                    elHitMarker.style.filter = "brightness(1.5) drop-shadow(0 0 8px red)";
                    setTimeout(() => {
                        elHitMarker.style.opacity = 0;
                        elHitMarker.style.transform = "translate(-50%, -50%) rotate(45deg) scale(1)";
                        elHitMarker.style.filter = "brightness(1) drop-shadow(0 0 4px red)";
                    }, 150);

                    // í”¼ê²© ì‚¬ìš´ë“œ íš¨ê³¼
                    SoundGen.playHit();

                    createBlood(h.point);

                    let dmg = w.damage;
                    if (h.object.name === 'head') {
                        dmg *= 3;
                        elHeadshot.classList.add('active');
                        setTimeout(() => elHeadshot.classList.remove('active'), 500);
                        SoundGen.playHeadshot();
                    } else if (h.object.name === 'limb') {
                        dmg *= 0.7;
                    }

                    // Flash Red - ë” ê°•í•˜ê²Œ
                    p.children.forEach(c => {
                        if (c.isMesh && c.material && c.material.emissive) {
                            c.material.emissive.setHex(0xff0000);
                            c.material.emissiveIntensity = 1.5; // ë” ë°ê²Œ
                        }
                    });
                    p.userData.flashTimer = 0.15; // ë” ì˜¤ë˜ ì§€ì† 

                    p.userData.hp -= dmg;
                    const hpPercent = Math.max(0, p.userData.hp / p.userData.maxHp);
                    p.userData.hpBar.scale.x = hpPercent;

                    if (p.userData.hp <= 0) {
                        p.userData.isDead = true;
                        const enemyPos = p.position.clone();
                        scene.remove(p);
                        const index = enemies.indexOf(p);
                        if (index > -1) enemies.splice(index, 1);

                        // Kill ì¹´ìš´íŠ¸ ì¦ê°€
                        killCount++;
                        if (elKillCount) {
                            elKillCount.innerText = `Kills: ${killCount}`;
                        }

                        // 30% í™•ë¥ ë¡œ HP íšŒë³µ ì•Œì•½ ë“œë
                        if (Math.random() < 0.3) {
                            createHealthPill(enemyPos);
                        }

                        // setTimeout ì œê±° - spawnTimer ì‹œìŠ¤í…œì´ ì²˜ë¦¬í•¨
                    }
                    break;
                }

                if (!isEnemy) break;
            }
        }

        function checkCollision(newPos) {
            const playerMin = new THREE.Vector3(newPos.x - PLAYER_RADIUS, newPos.y - 0.5, newPos.z - PLAYER_RADIUS);
            const playerMax = new THREE.Vector3(newPos.x + PLAYER_RADIUS, newPos.y + 0.5, newPos.z + PLAYER_RADIUS);
            const playerBox = new THREE.Box3(playerMin, playerMax);
            for (const collider of colliders) {
                if (playerBox.intersectsBox(collider)) return true;
            }
            return false;
        }

        function onResize() {
            // ëª¨ë°”ì¼ ê°€ë¡œ ëª¨ë“œì—ì„œ ì‹¤ì œ í™”ë©´ í¬ê¸° ê³„ì‚°
            let width, height;

            if (window.visualViewport) {
                // visualViewport API ì‚¬ìš© (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì € ì£¼ì†Œì°½ ì œì™¸)
                width = window.visualViewport.width;
                height = window.visualViewport.height;
            } else {
                // í´ë°±: window í¬ê¸° ì‚¬ìš©
                width = window.innerWidth;
                height = window.innerHeight;
            }

            // ëª¨ë°”ì¼ ê°€ë¡œ ëª¨ë“œì—ì„œ ìµœì†Œ ë†’ì´ ë³´ì¥
            if (isMobile && window.innerHeight < window.innerWidth) {
                // ê°€ë¡œ ëª¨ë“œ
                height = Math.max(height, window.screen.height || window.innerHeight);
            }

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            // í›„ì²˜ë¦¬ íš¨ê³¼ ë¦¬ì‚¬ì´ì¦ˆ
            if (postProcessingCanvas) {
                postProcessingCanvas.width = width;
                postProcessingCanvas.height = height;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // í”Œë ˆì´ ì‹œê°„ ì—…ë°ì´íŠ¸
            if (!isDead && !isPaused && gameStartTime > 0) {
                playTime = Math.floor((time - gameStartTime) / 1000);
                const minutes = Math.floor(playTime / 60);
                const seconds = playTime % 60;
                if (elPlayTime) {
                    elPlayTime.innerText = `Time: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }

            // Spectator Camera (Killcam) - Follow killer's position and rotation
            if (isSpectating && spectatingPlayerId && gameMode === 'multi') {
                const killerMesh = otherPlayersMap[spectatingPlayerId];
                if (killerMesh) {
                    // Position camera at killer's head position
                    camera.position.set(
                        killerMesh.position.x,
                        killerMesh.position.y + 1.7, // Eye height
                        killerMesh.position.z
                    );

                    // Match killer's rotation if available from server state
                    if (roomPlayersState[spectatingPlayerId] && roomPlayersState[spectatingPlayerId].rotation) {
                        rotation.x = roomPlayersState[spectatingPlayerId].rotation.x;
                        rotation.y = roomPlayersState[spectatingPlayerId].rotation.y;
                        const q = new THREE.Quaternion();
                        q.setFromEuler(new THREE.Euler(rotation.x, rotation.y, 0, 'YXZ'));
                        camera.quaternion.copy(q);
                    }
                }
                // Skip normal player control during spectating
                return;
            }

            if (!isDead && !isPaused) {
                handleShooting(dt);

                const targetHeight = keys.ctrl ? 1.0 : 1.7;
                let nextY = position.y + (targetHeight - position.y) * 10 * dt;
                velocityY -= 20.0 * dt;
                if (nextY < targetHeight && velocityY < 0) {
                    if (!isGrounded) SoundGen.playJump(true);
                    nextY = targetHeight; velocityY = 0; isGrounded = true;
                } else if (!isGrounded) {
                    nextY += velocityY * dt;
                }
                position.y = nextY;

                const w = WEAPONS[curWeaponIdx];
                let speed = 5.0;
                if (keys.shift && !isAiming && !keys.ctrl && w.type !== 'KNIFE') speed = 9.0;
                if (keys.ctrl) speed = 2.5; if (isAiming) speed = 2.0;

                const q = new THREE.Quaternion();
                q.setFromEuler(new THREE.Euler(rotation.x, rotation.y, 0, 'YXZ'));
                camera.quaternion.copy(q);

                const dx = keys.d - keys.a; const dy = keys.s - keys.w;
                if (dx !== 0 || dy !== 0) {
                    const fwd = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const rgt = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
                    const moveDir = fwd.multiplyScalar(-dy).add(rgt.multiplyScalar(dx)).normalize();
                    const moveStep = moveDir.multiplyScalar(speed * dt);
                    let nextPos = position.clone(); nextPos.x += moveStep.x;
                    if (!checkCollision(nextPos)) position.x = nextPos.x;
                    nextPos = position.clone(); nextPos.z += moveStep.z;
                    if (!checkCollision(nextPos)) position.z = nextPos.z;

                    if (!isAiming) {
                        if (isGrounded) {
                            moveDistance += speed * dt;
                            if (moveDistance > STEP_INTERVAL) {
                                SoundGen.playStep();
                                moveDistance = 0;
                            }
                        }

                        const bobFreq = keys.shift ? 15 : 8; const bobAmp = keys.shift ? 0.05 : 0.02;
                        weaponContainer.position.y += Math.sin(time * 0.001 * bobFreq) * bobAmp;
                        weaponContainer.position.x += Math.cos(time * 0.001 * (bobFreq / 2)) * bobAmp;
                    }
                }

                const isSniperAiming = isAiming && w.type === 'SNIPER';
                if (isSniperAiming) {
                    weaponContainer.visible = false;
                    elScope.style.display = 'block';
                    if (isMobile) {
                        elCrosshair.style.display = 'block';
                    } else {
                        elCrosshair.style.display = 'none';
                    }

                    // PC vs Mobile Scope Style Logic
                    if (isMobile) {
                        elScope.style.background = 'none'; // Mobile: Red dot / Open
                    } else {
                        // PC: Restore black scope overlay
                        elScope.style.background = 'radial-gradient(circle, transparent 20%, black 21%, black 100%)';
                    }
                } else {
                    weaponContainer.visible = true;
                    elScope.style.display = 'none';

                    // Sniper Scope - Show circular scope only for SNIPER when aiming
                    const sniperScope = document.getElementById('sniper-scope');
                    if (sniperScope) {
                        if (isAiming && w.type === 'SNIPER' && !isMobile) {
                            sniperScope.style.display = 'block';
                        } else {
                            sniperScope.style.display = 'none';
                        }
                    }

                    // Crosshair Logic
                    if (isMobile) {
                        // ëª¨ë°”ì¼: í•­ìƒ ì¡°ì¤€ì„  í‘œì‹œ (ì‚¬ìš©ì ìš”ì²­)
                        elCrosshair.style.display = 'block';
                        elCrosshair.style.opacity = 0.7; // ìƒì‹œ í‘œì‹œëŠ” ì•½ê°„ íˆ¬ëª…í•˜ê²Œ
                    } else if (w.type === 'PISTOL' || (!isAiming && w.type !== 'KNIFE')) {
                        // PC: ê¶Œì´ì´ê±°ë‚˜ ë¹„ì¡°ì¤€ ìƒíƒœ(ì¹¼ ì œì™¸)ì¼ ë•Œ í‘œì‹œ
                        elCrosshair.style.display = 'block';
                        elCrosshair.style.opacity = 1;
                    } else {
                        elCrosshair.style.display = 'none';
                    }
                }

                // Hide/Show front sight based on aiming
                weaponModel.traverse((child) => {
                    if (child.userData && child.userData.isSight) {
                        // ëª¨ë°”ì¼ì—ì„œ ê¶Œì´ì€ í•­ìƒ ì¡°ì¤€ ëª¨ë“œ
                        const shouldAim = isAiming || (isMobile && w.type === 'PISTOL');
                        child.visible = shouldAim;
                    }
                });

                let targetPos = w.posHip; let targetFov = 70;
                if (isAiming) {
                    if (w.type === 'SNIPER') targetFov = w.fovAds;
                    else if (w.type !== 'KNIFE') { targetPos = w.posAds; targetFov = w.fovAds; }
                    else targetPos = w.posAds;
                }

                currentPos.lerp(targetPos, 15 * dt);
                camera.fov += (targetFov - camera.fov) * 15 * dt;
                camera.updateProjectionMatrix();

                // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ ì ìš© (í”¼ê²© ê°ê°)
                if (hitShake.intensity > 0) {
                    hitShake.x = (Math.random() - 0.5) * hitShake.intensity;
                    hitShake.y = (Math.random() - 0.5) * hitShake.intensity;
                    hitShake.intensity *= 0.85; // ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
                    if (hitShake.intensity < 0.01) {
                        hitShake.intensity = 0;
                        hitShake.x = 0;
                        hitShake.y = 0;
                    }
                }

                camera.position.copy(position);
                camera.position.x += hitShake.x;
                camera.position.y += hitShake.y;
                weaponContainer.position.copy(position);
                weaponContainer.position.x += hitShake.x;
                weaponContainer.position.y += hitShake.y;
                weaponContainer.quaternion.copy(camera.quaternion);
                weaponContainer.translateX(currentPos.x);
                weaponContainer.translateY(currentPos.y);
                weaponContainer.translateZ(currentPos.z);

                recoil.x *= (1 - 10 * dt); recoil.z *= (1 - 10 * dt);

                // ë‚˜ì´í”„ì¼ ë•Œë§Œ íŠ¹ë³„í•œ ìœ„ì¹˜/íšŒì „ ì²˜ë¦¬
                if (w.type === 'KNIFE') {
                    if (knifeSwing === 0) {
                        // ë‚˜ì´í”„ ê¸°ë³¸ ê°ë„ ìœ ì§€ (ì†ì— ì¥” ê°ë„ - ê°œì„ ëœ ìœ„ì¹˜)
                        weaponModel.rotation.z = -0.15; // ì†ëª© ê°ë„ ìœ ì§€
                        weaponModel.rotation.x = 0.25; // ìœ„ë¡œ ê¸°ìš¸ì„
                        weaponModel.rotation.y = 0; // ê¸°ë³¸ Y íšŒì „
                        weaponModel.position.x = 0.3; // ê¸°ë³¸ X ìœ„ì¹˜
                        weaponModel.position.z = -0.35; // ê¸°ë³¸ Z ìœ„ì¹˜
                        weaponModel.position.y = -0.2; // ê¸°ë³¸ Y ìœ„ì¹˜
                    }
                } else {
                    // ë‹¤ë¥¸ ë¬´ê¸°ë“¤ì€ ì›ë˜ëŒ€ë¡œ (recoilë§Œ ì ìš©)
                    weaponModel.position.y = THREE.MathUtils.lerp(weaponModel.position.y, 0, 10 * dt);
                    weaponModel.rotation.x = recoil.x + (isReloading ? 0.5 : 0);
                    weaponModel.position.z = recoil.z;
                    // ì¬ì¥ì „ ì œìŠ¤ì²˜ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ rotation.z ì´ˆê¸°í™”
                    if (!sniperReloadGesture) {
                        weaponModel.rotation.z = 0;
                    }
                }
                elVignette.style.opacity = (isAiming && w.type !== 'KNIFE') ? 0.5 : 0;
            }

            updateShells(dt);
            updateParticles(dt);
            if (!isPaused) {
                updateHealthPills(dt);
            }
            // ëª¨ë“œë³„ ì—…ë°ì´íŠ¸
            if (gameMode === 'single') {
                updateEnemies(dt);
            } else if (gameMode === 'multi') {
                // ì›ê²© í”Œë ˆì´ì–´ HP ë°”ê°€ í•­ìƒ ì¹´ë©”ë¼ë¥¼ í–¥í•˜ê²Œ
                otherPlayers.forEach(p => {
                    p.lookAt(camera.position.x, p.position.y, camera.position.z);
                });

                // ìì‹ ì˜ ìƒíƒœ ì„œë²„ ì „ì†¡ (ì´ˆë‹¹ ì•½ 30~60íšŒ ë Œë”ë§ë§ˆë‹¤ ì „ì†¡í•˜ë©´ ë¶€í•˜ê°€ ìƒê¸¸ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìµœì í™” ê°€ëŠ¥)
                if (socket && socket.connected && !isDead) {
                    socket.emit('playerMove', {
                        position: { x: position.x, y: position.y, z: position.z },
                        rotation: { x: rotation.x, y: rotation.y }
                    });
                }
            }

            // ë¬¼ë¦¬ ì—”ì§„ ì—…ë°ì´íŠ¸
            if (usePhysics && physicsWorld) {
                updatePhysics(dt);
            }

            // ë Œë”ë§
            renderer.render(scene, camera);

            // í›„ì²˜ë¦¬ íš¨ê³¼ ì ìš© (ë Œë”ë§ í›„)
            if (usePostProcessing && postProcessingEnabled) {
                applyPostProcessing();
            }
        }

        // ëª¨ë°”ì¼ ì£¼ì†Œì°½ ìˆ¨ê¸°ê¸° - í˜ì´ì§€ ë¡œë“œ í›„ ìë™ ìŠ¤í¬ë¡¤
        window.addEventListener('load', function () {
            // iOS Safariì™€ Android í¬ë¡¬ì—ì„œ ì£¼ì†Œì°½ ìˆ¨ê¸°ê¸°
            setTimeout(function () {
                window.scrollTo(0, 1);
            }, 100);

            // í„°ì¹˜ ì‹œì‘ ì‹œì—ë„ ìŠ¤í¬ë¡¤ (ì£¼ì†Œì°½ ìë™ ìˆ¨ê¹€)
            document.body.addEventListener('touchstart', function () {
                window.scrollTo(0, 1);
            }, { once: true });
        });

        // í™”ë©´ ë°©í–¥ ë³€ê²½ ì‹œì—ë„ ì£¼ì†Œì°½ ìˆ¨ê¸°ê¸°
        window.addEventListener('orientationchange', function () {
            setTimeout(function () {
                window.scrollTo(0, 1);
            }, 100);
        });
    </script>

</body>

</html>